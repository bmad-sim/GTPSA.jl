var documenterSearchIndex = {"docs":
[{"location":"man/d_varsparams/#varsparams","page":"@vars, @params","title":"@vars, @params","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"Creates a vector of TPSs corresponding to each variable/parameter in the GTPSA","category":"page"},{"location":"man/d_varsparams/#Syntax","page":"@vars, @params","title":"Syntax","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"Δx  = @vars(descriptor [,complex=bool] [, dynamic=bool])\n\nΔk  = @params(descriptor [,complex=bool] [, dynamic=bool])","category":"page"},{"location":"man/d_varsparams/#Description","page":"@vars, @params","title":"Description","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"Δx = @vars(descriptor) creates a vector of TPSs corresponding to each of the variables in the GTPSA descriptor","category":"page"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"","category":"page"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"Δk = params(descriptor) creates a vector of TPSs corresponding to each of the parameters in the GTPSA descriptor`","category":"page"},{"location":"man/d_varsparams/#Optional-Argument","page":"@vars, @params","title":"Optional Argument","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"complex if true, will return the corresponding TPSs as ComplexTPS64. Default is false.","category":"page"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"dynamic if true, will use dynamic Descriptor resolution for the returned TPSs","category":"page"},{"location":"man/d_varsparams/#Examples","page":"@vars, @params","title":"Examples","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd1 = Descriptor(3, 5, 2, 5); # 3 vars, 2 params, all to order 5\nΔx = @vars(d1)\nΔxc = @vars(d1, complex=true)\nΔxd = @vars(d1, dynamic=true)\nΔk = @params(d1, complex=true, dynamic=true)","category":"page"},{"location":"man/d_varsparams/#Documentation","page":"@vars, @params","title":"Documentation","text":"","category":"section"},{"location":"man/d_varsparams/","page":"@vars, @params","title":"@vars, @params","text":"@vars\n@params","category":"page"},{"location":"man/d_varsparams/#GTPSA.@vars","page":"@vars, @params","title":"GTPSA.@vars","text":"@vars(descriptor [,complex=bool] [, dynamic=bool])\n\nConstructs a vector of TPSs corresponding to each of the variables in the GTPSA descriptor\n\nKeyword Arguments\n\ncomplex – If true, returns the variables as ComplexTPS64s. Default is false.\ndynamic – If true, the variables will use dynamic Descriptor resolution. Default is false.\n\n\n\n\n\n","category":"macro"},{"location":"man/d_varsparams/#GTPSA.@params","page":"@vars, @params","title":"GTPSA.@params","text":"@params(descriptor [,complex=bool] [, dynamic=bool])\n\nConstructs a vector of TPSs corresponding to each of the parameters in the GTPSA descriptor\n\nKeyword Arguments\n\ncomplex – If true, returns the parameters as ComplexTPS64s. Default is false.\ndynamic – If true, the parameters will use dynamic Descriptor resolution. Default is false.\n\n\n\n\n\n","category":"macro"},{"location":"man/e_monoindex/#monoindex","page":"Monomial Indexing","title":"Monomial Indexing","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"Get/set individual monomial coefficients","category":"page"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"Individual monomial coefficients in a TPS can be get/set with three methods of indexing: by monomial index, by order, and by sparse monomial. ","category":"page"},{"location":"man/e_monoindex/#By-Monomial-Index","page":"Monomial Indexing","title":"By Monomial Index","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[idx]\nt[param=param_idx]","category":"page"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"This indexing method requires care when indexing monomials above first order. Indexes the TPS with all monomials sorted by order. For example, for a TPS with one variable Delta x_1 and one parameter Delta k_1 the Delta x_1 monomial is indexed with t[1] and the Delta x_1^2 monomial is indexed with either t[3]. The Delta k_1 monomial can be indexed with either t[2] or equivalently using the param helper kwarg t[param=1], which simply adds the number of variables in the GTPSA to the provided index. Note that above first-order, the param kwarg is basically useless. The zeroth order part, or the scalar part of the TPS, can be set with t[0]. This method requires zero allocations for indexing, unlike the other two.","category":"page"},{"location":"man/e_monoindex/#Examples","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false; #hide\n# Example of indexing by monomial index -----------\nd = Descriptor(2, 10, 1, 10);\nt = TPS{d}(); # Create zero TPS based on d\n\nt[0] = 0;\nt[1] = 1;\nt[2] = 2;\nt[3] = 3;  # or t[param=1] = 3\nt[4] = 4;\nt[5] = 5; \nt[6] = 6;\nt[7] = 7;\nt[8] = 8;\nt[9] = 9;\nt[10] = 10;\nprint(t)","category":"page"},{"location":"man/e_monoindex/#By-Order","page":"Monomial Indexing","title":"By Order","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[[<var_1 order>, ..., <var_N order>,<param_1 order>, ..., <param_M order>]]\nt[(<var_1 order>, ..., <var_N order>,<param_1 order>, ..., <param_M order>)]","category":"page"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"A particular monomial can be indexed by specifying the orders of each variable and parameter. For example, for a TPS t with variables Delta x_1, Delta x_2 and parameters Delta k_1, Delta k_2, the Delta x_1^3Delta x_2^1Delta k_1^2 monomial coefficient is accessed with t[[3,1,2,0]] or equivalently t[[3,1,2]], as leaving out trailing zeros for unincluded variables/parameters is allowed. A tuple is also allowed instead of a vector for the list of orders.","category":"page"},{"location":"man/e_monoindex/#Examples-2","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd = Descriptor(2, 6, 3, 6); # 2 variables, 3 parameters all to 6th order\nΔx = @vars(d);\nΔk = @params(d);\nf = 5 + sin(Δx[1])*sin(Δx[2])*cos(Δk[1])\nf[[3,1,2]] # Leave out trailing zeros for unincluded variables/parameters\nf[[0]] # Scalar part\nf[(1,1,1,1,1)] = 123; # Set monomial coefficient\nprint(f)","category":"page"},{"location":"man/e_monoindex/#By-Sparse-Monomial","page":"Monomial Indexing","title":"By Sparse Monomial","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[[<ix_var> => <order>, ...], params=[<ix_param> => <order>, ...]]\nt[(<ix_var> => <order>, ...), params=(<ix_param> => <order>, ...)]","category":"page"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"In GTPSAs with many variables and parameters, indexing-by-order is inconvenient because each order needs to be included up to the last included variable/parameter with nonzero order. In this case, a particular monomial can be indexed instead by specifying each variable/parameter number and its corresponding order in pairs. For example, for a TPS with variables Delta x_1  Delta x_15 and parameters Delta k_1  Delta k_10, the Delta x_1^3Delta x_15^1Delta k_10^2 monomial coefficient is accessed with t[[1=>3, 15=>1], params=[10=>2]]. The scalar part of the TPS cannot be get/set with this method. A tuple is also allowed instead of a vector for the list of pairs.","category":"page"},{"location":"man/e_monoindex/#Examples-3","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/e_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd = Descriptor(15, 6, 10, 6); # 15 variables, 10 parameters all to 6th order\nGTPSA.show_sparse = true; # Use sparse output\nΔx = @vars(d);\nΔk = @params(d);\nf = 5 + sin(Δx[1])*sin(Δx[15])*cos(Δk[10])\nf[[1=>3, 15=>1], params=[10=>2]]\nf[(1=>1, 15=>2), params=(10=>3,)] = 123; # Set monomial coefficient\nprint(f)","category":"page"},{"location":"devel/#For-Developers","page":"For Developers","title":"For Developers","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Developers may fork the GTPSA.jl repo and then dev their forked repo in the REPL. For example, if my Github username is githubuser, then after forking GTPSA.jl I would run in the REPL:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"import Pkg\nPkg.develop(url=\"https://github.com/githubuser/GTPSA.jl\")","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The package consists of two layers: a low-level layer written in Julia that is 1-to-1 with the GTPSA C code, and a high-level, user-friendly layer that cleans up the notation for manipulating TPSs, manages temporaries generated during evaluation, and properly manages the memory in C when variables go out of scope in Julia. The low-level functions are listed at the bottom of this page.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"When it comes to managing memory in C via Julia, there are certain intricacies that have to be considered. First, let's consider the Descriptor, which is the simplest: ","category":"page"},{"location":"devel/#Descriptor","page":"For Developers","title":"Descriptor","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The Descriptor stores all information about the GTPSA, including the indexing table for indexing specific monomials. This is a static object, only created once for a GTPSA, which all TPSs refer to. In C, these structs must exist for the entirety of the program execution. In Julia, because they must not be destroyed when out-of-scope, we wrap these objects in immutable structs. In a single program, up to 250 Descriptors can exist simultanouesly, and they can be manually optionally destroyed using GTPSA.mad_desc_del!. At program termination all Descriptors are destroyed. Given the significantly large number allowed, as well as the danger of still-existing TPS and Descriptor structs after destruction, no front-facing interface to the user is given for destroying existing Descriptors.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The Descriptor struct simply wraps a C-pointer to a low-level struct called Desc: this struct is 1-to-1 equivalent to the C struct desc in GTPSA. See the documentation for GTPSA.Desc below. By having this struct in Julia, we can unsafe_load the struct and get values in the desc. For example, to access the first TPS{Float64} in the buffer of temporaries in the Descriptor, we can do","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"using GTPSA\nimport GTPSA: Desc\n\nd = Descriptor(5,8)\n\ndesc = unsafe_load(d.desc) # To access the low-level C struct\nt_jl = unsafe_load(Base.unsafe_convert(Ptr{Ptr{TPS{Float64}}}, desc.t), 1) # 1 in Julia = 0 in C","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"In Julia, if we were to then unsafe_load(t_jl), there would in fact be allocations, as its internally creating a copy of the TPS{Float64} in Julia. This is not well documented in the documentation of unsafe_load (see the discussion here).","category":"page"},{"location":"devel/#TPS","page":"For Developers","title":"TPS","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The TPS{Float64} struct in Julia corresponds exactly to the C struct tpsa and TPS{ComplexF64} struct in Julia corresponds exactly to ctpsa in C. To understand fully the TPS struct, some history is needed:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"In early development versions of GTPSA.jl, the TPS struct was very similar to the Descriptor struct: it used to just wrap a C Ptr to a low-level struct, and instead be mutable so out-of-scope TPSs and temporaries are cleaned up. This at the time seemed like the simplest solution, since in Julia there is no way to tag C pointers for Julia garbage collection. This created some problems though: firstly, there is one indirection because Julia would tag that particular mutable wrapper struct for GC, but then the member Ptr of that struct pointed to a different place in memory that had to be cleaned up. Secondly, when calling GTPSA C functions that want a Vector of TPS (e.g. Ptr to TPS), you would need to do a map(t->t.tpsa, x) where x is a Vector{TPS64} and tpsa is the field member of the wrapper TPS struct. Thirdly, and perhaps most significantly, Julia is not aware of how much memory the C is using. Therefore, it will not call the garbage collector very often, even if actually >100GB of memory is being used. Sometimes the OS will just kill the Julia process.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"In order to get around these problems, we must allocate the entire mutable TPS struct in Julia instead of in the C code (e.g. using GTPSA.mad_tpsa_newd). We then can use pointer_from_objref in Julia to get a pointer to that mutable, Julia-owned struct to pass to the C functions. ","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Sounds simple enough, right? If only! In the GTPSA C code, the coef member array is something called a flexible array member. This is great in C, because instead of the struct storing a pointer to an array (which would cause an indirection every time the coef array is accessed in a TPS), it actually stores the array right there in the struct, with variable size. This gives some performance gains. In Julia, there is no such analog. For those who know about StaticArrays.jl, you might think an SVector could work, but surprise, it doesn't because you cannot mutate the fields of an SVector and neither can the C code.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"So the only solution it seems is to change the actual C struct in mad_tpsa_impl.h and mad_ctpsa_impl.h to use regular arrays for coef instead of flexible array members, and indeed this is what is done for GTPSA.jl. There is a tiny speed reduction due to the indirection of accessing coef, however the benefits of Julia's garbage collector knowing how much memory it's using, and keeping memory usage sane, is worth the very tiny cost.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"On the Julia side, it turns out you cannot just use a regular Vector for the coef array in the TPS struct, because Julia's Vector structs are quite complex and play a lot of tricks. You might actually be able to use an MVector from StaticArrays, however using this struct might make GTPSA.jl significantly more complex because the size of the array has to be known at compile-time or else you suffer the drastic performance reductions caused by type-instabilities. The complexity of using this could be checked at some point in the future.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The decided solution was to, in the Julia, @ccall jl_malloc for the coef array, and in the finalizer for the mutable TPS struct call @ccall jl_free for the coef array. This gives us C-style arrays that Julia's garbage collector knows about, and so will make sure to keep the memory usage sane.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"When @ccall is used, the arguments are Base.unsafe_converted to the corresponding specified argument types. Therefore, for TPS all we had to do then was define","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Base.unsafe_convert(::Type{Ptr{TPS{T}}}, t::TPS{T}) where {T} = Base.unsafe_convert(Ptr{TPS{T}},pointer_from_objref(t))","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"and now we can pass our TPS structs to C using @ccall.","category":"page"},{"location":"devel/#TempTPS","page":"For Developers","title":"TempTPS","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Because unsafe_load of a Ptr{<:TPS} creates a copy and allocates, we cannot treat the constant buffer of pre-allocated temporaries in the Descriptor as bona-fide TPSs. Note that the memory addresses of the temporaries in the buffer are constant and do not need to be cleaned up; they are immutable!. The temporaries, which we give the type GTPSA.TempTPS, do not have any of the problems of just wrapping a pointer as do the TPSs, and so that's what they are. Also in Julia, in order to access the fields of a TempTPS (e.g. mo) via unsafe_load without allocating, we need an immutable struct having the same structure as TPS. This is the purpose of GTPSA.LowTempTPS. We need to use the mo field for @FastGTPSA to finally allocate the result TPS with the mo of the result TempTPS.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"As with TPS, we also had to define Base.unsafe_convert for TempTPS so we can @ccall. In this case, the unsafe_convert returns the member Ptr of the TempTPS.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.TempTPS","category":"page"},{"location":"devel/#GTPSA.TempTPS","page":"For Developers","title":"GTPSA.TempTPS","text":"struct TempTPS{T<:Union{Float64,ComplexF64},D}\n\nThis is for internal use only. TempTPS is a temporary TPS, which has  been pre-allocated in a buffer for each thread in the Descriptor C struct.  When using the @FastGTPSA macro, all temporaries generated will be used  from this buffer. \"Constructors\" of this type simply take a temporary from  that particular thread's buffer in a stack-like manner and \"Destructors\"  (which must be manually called because this is immutable) release it from  the stack.\n\nFields\n\nt::Ptr{TPS{T,D}} – Pointer to the TPS in the buffer in the Descriptor\n\n\n\n\n\n","category":"type"},{"location":"devel/#Library-Structure","page":"For Developers","title":"Library Structure","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"All operators have an in-place, mutating version specified with a bang (!). These are the lowest-level pure Julia code, following the convention that the first argument is the one to contain the result. In the GTPSA C library, the last argument contains the result, so this is accounted for in the file inplace_operators.jl. All in-place functions can receive either a regular TPS , which the user will be using, as well as a GTPSA.TempTPS, which the user should not concern themselves with. The constants RealTPS and ComplexTPS are defined respectively in low_level/rtpsa.jl and low_level/ctpsa.jl to simplify the notation. These are just:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"# Internal constants to aid multiple dispatch including temporaries \nconst RealTPS = Union{TempTPS{Float64}, TPS{Float64}}\nconst ComplexTPS = Union{TempTPS{ComplexF64}, TPS{ComplexF64}}","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"All this does is enforce correct types for the in-place functions, while keeping the notation/code simple. ","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The in-place, mutating functions, defined in inplace_operators.jl must all use the RealTPS and ComplexTPS \"types\". Then, the higher level out-of-place functions for both TPS and TempTPS, which do different things with the result, will use these in-place functions.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The out-of-place functions for TPS are defined in operators.jl, and the out-of-place functions for TempTPS are defined in fastgtpsa/operators.jl.","category":"page"},{"location":"devel/#Fast-GTPSA-Macros","page":"For Developers","title":"Fast GTPSA Macros","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The @FastGTPSA/@FastGTPSA! macros work by changes all arithmetic operators in different Julia arithmetic operators with the same operator precedence and unary operator capabilities. These special operators then dispatch on functions that use the temporaries when a TPS or TempTPS is passed, else default to their original operators, thereby making it completely transparent to non-TPS types. Both + and - must work as unary operators, and there is a very short list of allowed ones shown here. The other arithmetic operators were chosen somewhat randomly from the top of the same file, next to prec-plus, prec-times, and prec-power which defines the operator precedences. By taking this approach, we relieve ourselves of having to rewrite PEMDAS and instead let the Julia do it for us.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"All arithmetic operators are changed to GTPSA.:<special symbols>, e.g. + → GTPSA.:±. All non-arithmetic operators that are supported by GTPSA are then changed to GTPSA.__t_<operator>, e.g. sin → GTPSA.__t_sin, where the prefix __t_ is also chosen somewhat arbitrarily. These operators are all defined in fastgtpsa/operators.jl, and when they encounter a TPS type, they use the temporaries, and when other number types are detected, they fallback to the regular, non-__t_ operator. This approach works extraordinarily well, and introduces no problems externally because none of these functions/symbols are exported.","category":"page"},{"location":"devel/#Calling-the-C-library-with-pointers-and-pointer-to-pointers","page":"For Developers","title":"Calling the C-library with pointers and pointer-to-pointers","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"All of the GTPSA map functions require a vector of TPS as input, in C **tpsa. In Julia, this works automatically for AbstractArray{<:Union{TPS64,ComplexTPS64}} by specifying the C argument type in the C call as ::Ptr{TPS64} or ::Ptr{ComplexTPS64}.  However, this can be misleading to those C inputs which require *tpsa, e.g. also ::Ptr{TPS64}. For consistency in the low level library interface, all pointers are specified as ::Ref{TPS64} and ::Ref{ComplexTPS64}, and pointers-to-pointers are specified as Ptrs. For single TPSs, the cconvert to Ref in the ccall is handled automatically.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"However, in some cases, one might have only a single TPS64 and would like the call the corresponding map functions without having to allocate an array. After some experimenting, I've found the following overrides to gives zero allocations:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Base.unsafe_convert(::Type{Ptr{TPS{T}}}, r::Base.RefValue{Ptr{Nothing}}) where {T} = Base.unsafe_convert(Ptr{TPS{T}}, Base.unsafe_convert(Ptr{Cvoid}, r))\nBase.cconvert(::Type{Ptr{TPS{T}}}, t::TPS{T}) where {T} = Ref(pointer_from_objref(t))","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"NOTE: We need to have a GC.@preserve before the cconvert to keep t valid! As such, you will see in all map functions a call to GC.@preserve. ","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"This override is only necessary for the mutable TPS. The other array inputs of isbits types are ok and basically have the above defined for them. See this discussion for more details.","category":"page"},{"location":"devel/#Low-Level","page":"For Developers","title":"Low-Level","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Below is documentation for every single 1-to-1 C function in the GTPSA library. If there is any function missing, please submit an issue to GTPSA.jl.","category":"page"},{"location":"devel/#Monomial","page":"For Developers","title":"Monomial","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.mad_mono_add!\nGTPSA.mad_mono_cat!\nGTPSA.mad_mono_cmp\nGTPSA.mad_mono_copy!\nGTPSA.mad_mono_eq\nGTPSA.mad_mono_eqn\nGTPSA.mad_mono_fill!\nGTPSA.mad_mono_le\nGTPSA.mad_mono_lt\nGTPSA.mad_mono_max\nGTPSA.mad_mono_min\nGTPSA.mad_mono_ord\nGTPSA.mad_mono_ordp\nGTPSA.mad_mono_ordpf\nGTPSA.mad_mono_print\nGTPSA.mad_mono_prt!\nGTPSA.mad_mono_rcmp\nGTPSA.mad_mono_rev!\nGTPSA.mad_mono_str!\nGTPSA.mad_mono_sub!","category":"page"},{"location":"devel/#GTPSA.mad_mono_add!","page":"For Developers","title":"GTPSA.mad_mono_add!","text":"mad_mono_add!(n::Cint, a, b, r)\n\nSets monomial r = a + b.\n\nInput\n\nn – Length of monomials\na – Source monomial a\nb – Source monomial b\n\nOutput\n\nr – Destination monomial, r = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_cat!","page":"For Developers","title":"GTPSA.mad_mono_cat!","text":"mad_mono_cat!(n::Cint, a, m::Cint, b, r)\n\nSets monomial r equal to the concatenation of the monomials a and b\n\nInput\n\nn – Length of monomonial a\na – Source monomial a\nm – Length of monomial b\nb – Source monomial b\n\nOutput\n\nr – Destination monomial of concatenation of a and b (length n+m)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_cmp","page":"For Developers","title":"GTPSA.mad_mono_cmp","text":"mad_mono_cmp(n::Cint, a, b)::Cint\n\nCompares monomial a to monomial b, and returns the first difference in the lowest order variables.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – First a[i]-b[i] != 0\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_copy!","page":"For Developers","title":"GTPSA.mad_mono_copy!","text":"mad_mono_copy!(n::Cint, a, r)\n\nCopies monomial a to monomial r.  \n\nInput\n\nn – Length of monomials\na – Source monomial\nr – Destination monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_eq","page":"For Developers","title":"GTPSA.mad_mono_eq","text":"mad_mono_eq(n::Cint, a, b)::Bool\n\nChecks if the monomial a is equal to the monomial b.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – True if the monomials are equal, false if otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_eqn","page":"For Developers","title":"GTPSA.mad_mono_eqn","text":"mad_mono_eqn(n::Cint, a, b::Cuchar)::Bool\n\n???\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_fill!","page":"For Developers","title":"GTPSA.mad_mono_fill!","text":"mad_mono_fill!(n::Cint, a, v::Cuchar)\n\nFills the monomial a with the value v.\n\nInput\n\nn – Monomial length\na – Monomial\nv – Value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_le","page":"For Developers","title":"GTPSA.mad_mono_le","text":"mad_mono_le(n::Cint, a, b)::Bool\n\nChecks if monomial a is less than or equal to monomial b.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – True if a <= mono_b, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_lt","page":"For Developers","title":"GTPSA.mad_mono_lt","text":"mad_mono_lt(n::Cint, a, b)::Bool\n\nChecks if monomial a is less than monomial b.\n\nInput\n\nn  – Length of monomials\na  – Monomial a\nb  – Monomial b\n\nOutput\n\nret – True if a < b, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_max","page":"For Developers","title":"GTPSA.mad_mono_max","text":"mad_mono_max(n::Cint, a)::Cuchar\n\nReturns the maximum order of the monomial.\n\nInput\n\nn  – Length of monomial\na  – Monomial\n\nOutput\n\nmo – Maximum order of monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_min","page":"For Developers","title":"GTPSA.mad_mono_min","text":"mad_mono_min(n::Cint, a)::Cuchar\n\nReturns the minimum order of the monomial.\n\nInput\n\nn  – Length of monomial\na  – Monomial\n\nOutput\n\nmo – Mininum order of monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ord","page":"For Developers","title":"GTPSA.mad_mono_ord","text":"mad_mono_ord(n::Cint, a)::Cint\n\nReturns the sum of the orders of the monomial a.\n\nInput\n\nn – Monomial length\na – Monomial\n\nOutput\n\ns – Sum of orders of monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ordp","page":"For Developers","title":"GTPSA.mad_mono_ordp","text":"mad_mono_ordp(n::Cint, a, stp::Cint)::Cdouble\n\nReturns the product of each stp-th order in monomial a. For example, stp = 2 collects every order in the monomial with a step of 2 between each. As a is a pointer, the product can be started at any  element in the monomial.\n\nInput\n\nn   – Monomial length\na   – Monomial as byte array\nstp – Step over which orders to include in the product\n\nOutput\n\np   – Product of orders of monomial separated by stp.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ordpf","page":"For Developers","title":"GTPSA.mad_mono_ordpf","text":"mad_mono_ordpf(n::Cint, a, stp::Cint)::Cdouble\n\nReturns the product of factorials each stp-th order in monomial a. For example, stp = 2 collects  every order in the monomial with a step of 2 between each. As a is a pointer, the product can be started  at any element in the monomial.\n\nInput\n\nn   – Monomial length\na   – Monomial as byte array\nstp – Step over which orders to include in the product of factorials\n\nOutput\n\np   – Product of factorials of orders of monomial separated by stp\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_print","page":"For Developers","title":"GTPSA.mad_mono_print","text":"mad_mono_print(n::Cint, a, sep_::Cstring, fp_::Ptr{Cvoid})\n\nPrints the monomial to stdout.\n\nInput\n\nn  – Length of monomial\na  – Source monomial to print to stdout\nsep_ – Separator string\nfp_ – C FILE pointer, if null will print to stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_prt!","page":"For Developers","title":"GTPSA.mad_mono_prt!","text":"mad_mono_prt(n::Cint, a, s::Ptr{Cuchar})::Cstring\n\nWrites the monomial defined by the byte array a (with orders stored as hexadecimal) into  a null terminated string s.\n\nInput\n\nn – Monomial and string length\na – Monomial as byte array\n\nOutput\n\nret – Monomial as string\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_rcmp","page":"For Developers","title":"GTPSA.mad_mono_rcmp","text":"mad_mono_rcmp(n::Cint, a, b)::Cint\n\nCompares monomial a to monomial b starting from the right (when the monomials are ordered by variable,  which is almost never the case) and returns the first difference in the lowest order variables. \n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – First a[i]-b[i] != 0 where i starts from the end.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_rev!","page":"For Developers","title":"GTPSA.mad_mono_rev!","text":"mad_mono_rev!(n::Cint, a, r)\n\nSets destination monomial r equal to the reverse of source monomial a.\n\nInput\n\nn – Lengths of monomials\na – Source monomial a\n\nOutput\n\nr – Destination monomial of reverse monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_str!","page":"For Developers","title":"GTPSA.mad_mono_str!","text":"mad_mono_str!(n::Cint, a, s::Cstring)::Cint\n\nWrites the monomial defined in the string s, which stores the orders in a human-readable format  (e.g. 10 is 10, not 0xa), into the byte array a with the orders specified in hexadecimal.\n\nInput\n\nn – Monomial and string length\ns – Monomial as string \"[0-9]*\"\n\nOutput\n\na – Monomial as a byte array converted from the input string\ni – Adjusted size n of byte array if '\u0000' found\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_sub!","page":"For Developers","title":"GTPSA.mad_mono_sub!","text":"mad_mono_sub!(n::Cint, a, b, r)\n\nSets monomial r = a - b.\n\nInput\n\nn – Length of monomials\na – Source monomial a\nb – Source monomial b\n\nOutput\n\nr – Destination monomial, r = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#Desc","page":"For Developers","title":"Desc","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.Desc\nGTPSA.mad_desc_del!\nGTPSA.mad_desc_getnv!\nGTPSA.mad_desc_idxm\nGTPSA.mad_desc_idxs\nGTPSA.mad_desc_idxsm\nGTPSA.mad_desc_info\nGTPSA.mad_desc_isvalidm\nGTPSA.mad_desc_isvalids\nGTPSA.mad_desc_isvalidsm\nGTPSA.mad_desc_maxlen\nGTPSA.mad_desc_maxord\nGTPSA.mad_desc_mono!\nGTPSA.mad_desc_newv\nGTPSA.mad_desc_newvp\nGTPSA.mad_desc_newvpo\nGTPSA.mad_desc_nxtbyord\nGTPSA.mad_desc_nxtbyvar\nGTPSA.mad_desc_paropsth!","category":"page"},{"location":"devel/#GTPSA.Desc","page":"For Developers","title":"GTPSA.Desc","text":"`Desc`\n\nThis is a 1-to-1 struct for the C definition desc (descriptor) in GTPSA. Descriptors include all  information about the TPSA, including the number of variables/parameters and their orders, lookup tables for  the monomials, monomial indexing function, and pre-allocated permanent temporaries for fast evaluation.\n\nFields\n\nid::Cint                   – Index in list of registered descriptors\nnn::Cint                   – Number of variables + number of parameters, nn = nv+np <= 100000\nnv::Cint                   – Number of variables\nnp::Cint                   – Number of parameters\nmo::Cuchar                 – Max order of both variables AND parameters\npo::Cuchar                 – Max order of parameters\nsh::Cuchar                 – shared with id or -1\nno::Ptr{Cuchar}            – Array of orders of each variable (first nv entries) and parameters (last np entries), length nn. Note: In C this is const\nuno::Cint                  – User provided array of orders of each variable/parameter (with mad_desc_newvpo)\nnth::Cint                  – Max number of threads or 1\nnc::Cuint                  – Number of coefficients (max length of TPSA)\npmul::Cuint                – Threshold for parallel mult (0 = disable)\npcomp::Cuint               – Threshold for parallel compose (0 = disable)\nshared::Ptr{Cint}          – counter of shared desc (all tables below except prms)\nmonos::Ptr{Cuchar}         – 'Matrix' storing the monomials (sorted by variable)\nords::Ptr{Cuchar}          – Order of each monomial of To\nprms::Ptr{Cuchar}          – Order of parameters in each monomial of To (zero = no parameters)\nTo::Ptr{Ptr{Cuchar}}       – Table by orders - pointers to monomials, sorted by order\nTv::Ptr{Ptr{Cuchar}}       – Table by vars - pointers to monomials, sorted by variable\nocs::Ptr{Ptr{Cuchar}}      – ocs[t,i] -> o in mul, compute o on thread t 3 <= o <= mo aterminated with 0\nord2idx::Ptr{Cint}         – Order to polynomial start index in To (i.e. in TPSA coef)\ntv2to::Ptr{Cint}           – Lookup tv->to\nto2tv::Ptr{Cint}           – Lookup to->tv\nH::Ptr{Cint}               – Indexing matrix in Tv\nL::Ptr{Ptr{Cint}}          – Multiplication indexes L[oa,ob]->L_ord L_ord[ia,ib]->ic\nL_idx::Ptr{Ptr{Ptr{Cint}}} – L_idx[oa,ob]->[start] [split] [end] idxs in L\nsize::Culonglong           – Bytes used by desc. Unsigned Long Int: In 32 bit system is Int32 but 64 bit is Int64. Using Culonglong assuming 64 bit\ndst_n::Cdouble             – density count\ndst_mu::Cdouble            – density mean\ndst_var::Cdouble           – density variance\nt::Ptr{Ptr{Cvoid}}         – Temporary array contains 8 pointers to TPS{Float64}s already initialized\nct::Ptr{Ptr{Cvoid}}        – Temporary array contains 8 pointers to TPS{ComplexF64}s already initialized\nti::Ptr{Cint}              – idx of tmp used by each thread (length = # threads)\ncti::Ptr{Cint}             – idx of tmp used by each thread (length = # threads)                                                                                              \n\n\n\n\n\n","category":"type"},{"location":"devel/#GTPSA.mad_desc_del!","page":"For Developers","title":"GTPSA.mad_desc_del!","text":"mad_desc_del!(d_::Ptr{Desc})\n\nCalls the destructor for the passed descriptor.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_getnv!","page":"For Developers","title":"GTPSA.mad_desc_getnv!","text":"mad_desc_getnv!(d::Ptr{Desc}, mo_::Ref{Cuchar}, np_::Ref{Cint}, po_::Ref{Cuchar}::Cint\n\nReturns the number of variables in the descriptor, and sets the passed mo_, np_, and po_ to the maximum  order, number of parameters, and parameter order respectively.\n\nInput\n\nd – Descriptor\n\nOutput\n\nmo_ – (Optional) Maximum order of the descriptor\nnp_ – (Optional) Number of parameters of the descriptor\npo_ – (Optional) Parameter order of the descriptor\nret – Number of variables in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxm","page":"For Developers","title":"GTPSA.mad_desc_idxm","text":"mad_desc_idxm(d::Ptr{Desc}, n::Cint, m)::Cint\n\nReturns the index of the monomial as byte array m in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd – Descriptor\nn    – Monomial length\nm    – Monomial as byte array\n\nOutput\n\nret  – Monomial index or -1 if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxs","page":"For Developers","title":"GTPSA.mad_desc_idxs","text":"mad_desc_idxs(d::Ptr{Desc}, n::Cint, s::Cstring)::Cint\n\nReturns the index of the monomial as string s in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd   – Descriptor\nn   – String length or 0 if unknown\ns   – Monomial as string \"[0-9]*\"\n\nOutput\n\nret – Monomial index or -1 if invalid monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxsm","page":"For Developers","title":"GTPSA.mad_desc_idxsm","text":"mad_desc_idxsm(d::Ptr{Desc}, n::Cint, m)::Cint\n\nReturns the index of the monomial as sparse monomial m, indexed as [(i,o)], in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Sparse monomial [(idx,ord)]\n\nOutput\n\nret – Monomial index or -1 if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_info","page":"For Developers","title":"GTPSA.mad_desc_info","text":"mad_desc_info(d::Ptr{Desc}, fp::Ptr{Cvoid})\n\nFor debugging.\n\nInput\n\nd  – Descriptor to debug\nfp – File to write to. If null, will write to stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalidm","page":"For Developers","title":"GTPSA.mad_desc_isvalidm","text":"mad_desc_isvalidm(d::Ptr{Desc}, n::Cint, m)::Bool\n\nChecks if monomial as byte array m is valid given maximum order of descriptor.\n\nInput\n\nd  – Descriptor\nn  – Length of monomial\nm  – Monomial as byte array\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalids","page":"For Developers","title":"GTPSA.mad_desc_isvalids","text":"mad_desc_isvalids(d::Ptr{Desc}, n::Cint, s::Cstring)::Bool\n\nChecks if monomial as string s is valid given maximum order of descriptor.\n\nInput\n\nd  – Descriptor\nn  – Monomial string length\ns  – Monomial as string \"[0-9]*\"\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalidsm","page":"For Developers","title":"GTPSA.mad_desc_isvalidsm","text":"mad_desc_isvalidsm(d::Ptr{Desc}, n::Cint, m)::Bool\n\nChecks the monomial as sparse monomial m (monomial stored as sequence of integers with each pair  [(i,o)] such that i = index, o = order) is valid given the maximum order of the descriptor.\n\nInput\n\nd   – Descriptor\nn   – Length of monomial\nm   – Sparse monomial [(idx, ord)]\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_maxlen","page":"For Developers","title":"GTPSA.mad_desc_maxlen","text":"mad_desc_maxlen(d::Ptr{Desc}, mo::Cuchar)::Cint\n\nGets the maximum length of the TPSA given an order. \n\nInput\n\nd   – Descriptor\nmo  – Order (ordlen(maxord) == maxlen)\n\nOutput\n\nret – monomials in 0..order\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_maxord","page":"For Developers","title":"GTPSA.mad_desc_maxord","text":"mad_desc_maxord(d::Ptr{Desc}, nn::Cint, no_)::Cuchar\n\nSets the order of the variables and parameters of the TPSA to those specified in no_ and  returns the maximum order of the TPSA.\n\nInput\n\nd   – Descriptor\nnn  – Number of variables + number of parameters, no_[1..nn]\nno_ – (Optional) Orders of parameters to be filled if provided\n\nOutput\n\nret  – Maximum order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_mono!","page":"For Developers","title":"GTPSA.mad_desc_mono!","text":"mad_desc_mono!(d::Ptr{Desc}, i::Cint, n::Cint, m_, p_)::Cuchar\n\nReturns the order of the monomial at index i, and if n and m_ are provided, then will also fill m_  with the monomial at this index. Also will optionally return the order of the parameters in the monomial  if p_ is provided\n\nInput\n\nd   – Descriptor\ni   – Slot index (must be valid)\nn   – Monomial length (must be provided if m_ is to be filled)\n\nOutput\n\nret – Monomial order at slot index\nm_  – (Optional) Monomial to fill if provided\np_  – (Optional) Order of parameters in monomial if provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_newv","page":"For Developers","title":"GTPSA.mad_desc_newv","text":"mad_desc_newv(nv::Cint, mo::Cuchar)::Ptr{Desc}\n\nCreates a TPSA descriptor with the specified number of variables and maximum order.  The number of parameters is set to 0.\n\nInput\n\nnv  – Number of variables in the TPSA\nmo  – Maximum order of TPSA, mo = max(1, mo)\n\nOutput\n\nret – Descriptor with the specified number of variables and maximum order\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_newvp","page":"For Developers","title":"GTPSA.mad_desc_newvp","text":"mad_desc_newvp(nv::Cint, mo::Cuchar, np_::Cint, po_::Cuchar)::Ptr{Desc}\n\nCreates a TPSA descriptor with the specifed number of variables, maximum order, number of  parameters, and parameter order.\n\nInput\n\nnv  – Number of variables\nmo  – Maximum order of TPSA INCLUDING PARAMETERS, mo = max(1, mo)\nnp_ – (Optional) Number of parameters, default is 0\npo_ – (Optional) Order of parameters, po = max(1, po_)\n\nOutput\n\nret – Descriptor with the specified nv, mo, np, and po\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_newvpo","page":"For Developers","title":"GTPSA.mad_desc_newvpo","text":"mad_desc_newvpo(nv::Cint, mo::Cuchar, np_::Cint, po_::Cuchar, no_)::Ptr{Desc}\n\nCreates a TPSA descriptor with the specifed number of variables, maximum order for both variables and parameters, number of parameters,  parameter order, and individual variable/parameter orders specified in no. The first nv entries in no  correspond to the variables' orders and the next np entries correspond the parameters' orders.\n\nInput\n\nnv   – Number of variables\nmo   – Maximum order of TPSA (mo = max(mo , no[0 :nn-1]), nn = nv+np)\nnp_  – (Optional) Number of parameters, default is 0\npo_  – (Optional) Order of parameters (po = max(po_, no[nv:nn-1]), po <= mo)\nno_  – (Optional) Array of orders of variables and parameters\n\nOutput\n\nret – Descriptor with the specified nv, mo, np, po, no.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_nxtbyord","page":"For Developers","title":"GTPSA.mad_desc_nxtbyord","text":"mad_desc_nxtbyord(d::Ptr{Desc}, n::Cint, m)::Cint\n\nReturns the next monomial after monomial m in the TPSA when sorted by order.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Monomial as byte array\n\nOutput\n\nidx – Monomial index or -1 if no valid next monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_nxtbyvar","page":"For Developers","title":"GTPSA.mad_desc_nxtbyvar","text":"mad_desc_nxtbyvar(d::Ptr{Desc}, n::Cint, m)::Cint\n\nReturns the next monomial after monomial m in the TPSA when sorted by variable.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Monomial as byte array\n\nOutput\n\nidx – Monomial index or -1 if no valid next monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_paropsth!","page":"For Developers","title":"GTPSA.mad_desc_paropsth!","text":"mad_desc_paropsth!(d::Ptr{Desc}, mult_, comp_)\n\nSets the parallelised operations thresholds for multiplication (mult_) and/or composition (comp_). Will return in mult_ and/or comp_ the previous threshold.\n\nInput\n\nmult_ – (Optional) Ptr{Cint} to new multiplication OMP parallelization threshold\ncomp_ – (Optional) Ptr{Cint} to new composition OMP parallelization threshold\n\nOutput\n\nmult_ – (Optional) old multiplication parallelization threshold\ncomp_ – (Optional) old composition parallelization threshold\n\n\n\n\n\n","category":"function"},{"location":"devel/#TPS{Float64}","page":"For Developers","title":"TPS{Float64}","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.mad_tpsa_abs!\nGTPSA.mad_tpsa_acc!\nGTPSA.mad_tpsa_acos!\nGTPSA.mad_tpsa_acosh!\nGTPSA.mad_tpsa_acot!\nGTPSA.mad_tpsa_acoth!\nGTPSA.mad_tpsa_add!\nGTPSA.mad_tpsa_asin!\nGTPSA.mad_tpsa_asinc!\nGTPSA.mad_tpsa_asinh!\nGTPSA.mad_tpsa_asinhc!\nGTPSA.mad_tpsa_atan!\nGTPSA.mad_tpsa_atan2!\nGTPSA.mad_tpsa_atanh!\nGTPSA.mad_tpsa_ax2pby2pcz2!\nGTPSA.mad_tpsa_axpb!\nGTPSA.mad_tpsa_axpbypc!\nGTPSA.mad_tpsa_axpsqrtbpcx2!\nGTPSA.mad_tpsa_axypb!\nGTPSA.mad_tpsa_axypbvwpc!\nGTPSA.mad_tpsa_axypbzpc!\nGTPSA.mad_tpsa_clear!\nGTPSA.mad_tpsa_clrord!\nGTPSA.mad_tpsa_compose!\nGTPSA.mad_tpsa_convert!\nGTPSA.mad_tpsa_copy!\nGTPSA.mad_tpsa_cos!\nGTPSA.mad_tpsa_cosh!\nGTPSA.mad_tpsa_cot!\nGTPSA.mad_tpsa_coth!\nGTPSA.mad_tpsa_cpyi!\nGTPSA.mad_tpsa_cpym!\nGTPSA.mad_tpsa_cpys!\nGTPSA.mad_tpsa_cpysm!\nGTPSA.mad_tpsa_cutord!\nGTPSA.mad_tpsa_cycle!\nGTPSA.mad_tpsa_debug\nGTPSA.mad_tpsa_del!\nGTPSA.mad_tpsa_density\nGTPSA.mad_tpsa_deriv!\nGTPSA.mad_tpsa_derivm!\nGTPSA.mad_tpsa_desc\nGTPSA.mad_tpsa_dif!\nGTPSA.mad_tpsa_div!\nGTPSA.mad_tpsa_equ\nGTPSA.mad_tpsa_erf!\nGTPSA.mad_tpsa_erfc!\nGTPSA.mad_tpsa_eval!\nGTPSA.mad_tpsa_exp!\nGTPSA.mad_tpsa_exppb!\nGTPSA.mad_tpsa_fgrad!\nGTPSA.mad_tpsa_fld2vec!\nGTPSA.mad_tpsa_geti\nGTPSA.mad_tpsa_getm\nGTPSA.mad_tpsa_getord!\nGTPSA.mad_tpsa_gets\nGTPSA.mad_tpsa_getsm\nGTPSA.mad_tpsa_getv!\nGTPSA.mad_tpsa_hypot!\nGTPSA.mad_tpsa_hypot3!\nGTPSA.mad_tpsa_idxm\nGTPSA.mad_tpsa_idxs\nGTPSA.mad_tpsa_idxsm\nGTPSA.mad_tpsa_init!\nGTPSA.mad_tpsa_integ!\nGTPSA.mad_tpsa_inv!\nGTPSA.mad_tpsa_invsqrt!\nGTPSA.mad_tpsa_isnul\nGTPSA.mad_tpsa_isval\nGTPSA.mad_tpsa_isvalid\nGTPSA.mad_tpsa_len\nGTPSA.mad_tpsa_liebra!\nGTPSA.mad_tpsa_log!\nGTPSA.mad_tpsa_logaxpsqrtbpcx2!\nGTPSA.mad_tpsa_logpb!\nGTPSA.mad_tpsa_logxdy!\nGTPSA.mad_tpsa_maxord!\nGTPSA.mad_tpsa_mconv!\nGTPSA.mad_tpsa_minv!\nGTPSA.mad_tpsa_mnrm\nGTPSA.mad_tpsa_mo!\nGTPSA.mad_tpsa_mono!\nGTPSA.mad_tpsa_mord\nGTPSA.mad_tpsa_mul!\nGTPSA.mad_tpsa_nam\nGTPSA.mad_tpsa_new\nGTPSA.mad_tpsa_newd\nGTPSA.mad_tpsa_nrm\nGTPSA.mad_tpsa_ord\nGTPSA.mad_tpsa_ordv\nGTPSA.mad_tpsa_pminv!\nGTPSA.mad_tpsa_poisbra!\nGTPSA.mad_tpsa_pow!\nGTPSA.mad_tpsa_powi!\nGTPSA.mad_tpsa_pown!\nGTPSA.mad_tpsa_print\nGTPSA.mad_tpsa_scan\nGTPSA.mad_tpsa_scan_coef!\nGTPSA.mad_tpsa_scan_hdr\nGTPSA.mad_tpsa_scl!\nGTPSA.mad_tpsa_sclord!\nGTPSA.mad_tpsa_seti!\nGTPSA.mad_tpsa_setm!\nGTPSA.mad_tpsa_setprm!\nGTPSA.mad_tpsa_sets!\nGTPSA.mad_tpsa_setsm!\nGTPSA.mad_tpsa_setv!\nGTPSA.mad_tpsa_setval!\nGTPSA.mad_tpsa_setvar!\nGTPSA.mad_tpsa_sin!\nGTPSA.mad_tpsa_sinc!\nGTPSA.mad_tpsa_sincos!\nGTPSA.mad_tpsa_sincosh!\nGTPSA.mad_tpsa_sinh!\nGTPSA.mad_tpsa_sinhc!\nGTPSA.mad_tpsa_sqrt!\nGTPSA.mad_tpsa_sub!\nGTPSA.mad_tpsa_tan!\nGTPSA.mad_tpsa_tanh!\nGTPSA.mad_tpsa_taylor!\nGTPSA.mad_tpsa_taylor_h!\nGTPSA.mad_tpsa_translate!\nGTPSA.mad_tpsa_uid!\nGTPSA.mad_tpsa_unit!\nGTPSA.mad_tpsa_update!\nGTPSA.mad_tpsa_vec2fld!","category":"page"},{"location":"devel/#GTPSA.mad_tpsa_abs!","page":"For Developers","title":"GTPSA.mad_tpsa_abs!","text":"mad_tpsa_abs!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the absolute value of TPSA a. Specifically, the  result contains a TPSA with the abs of all coefficients.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = |a|\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acc!","page":"For Developers","title":"GTPSA.mad_tpsa_acc!","text":"mad_tpsa_acc!(a::RealTPS, v::Cdouble, c::RealTPS)\n\nAdds a*v to TPSA c. Aliasing OK.\n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acos!","page":"For Developers","title":"GTPSA.mad_tpsa_acos!","text":"mad_tpsa_acos!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the acos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acosh!","page":"For Developers","title":"GTPSA.mad_tpsa_acosh!","text":"mad_tpsa_acosh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the acosh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = acosh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acot!","page":"For Developers","title":"GTPSA.mad_tpsa_acot!","text":"mad_tpsa_acot!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the acot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acoth!","page":"For Developers","title":"GTPSA.mad_tpsa_acoth!","text":"mad_tpsa_acoth!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the acoth of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = acoth(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_add!","page":"For Developers","title":"GTPSA.mad_tpsa_add!","text":"mad_tpsa_add!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nSets the destination TPSA c = a + b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asin!","page":"For Developers","title":"GTPSA.mad_tpsa_asin!","text":"mad_tpsa_asin!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the asin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinc!","page":"For Developers","title":"GTPSA.mad_tpsa_asinc!","text":"mad_tpsa_asinc!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the asinc(a) = asin(a)/a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinc(a) = asin(a)/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinh!","page":"For Developers","title":"GTPSA.mad_tpsa_asinh!","text":"mad_tpsa_asinh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the asinh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = asinh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinhc!","page":"For Developers","title":"GTPSA.mad_tpsa_asinhc!","text":"mad_tpsa_asinhc!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the asinhc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = asinhc(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atan!","page":"For Developers","title":"GTPSA.mad_tpsa_atan!","text":"mad_tpsa_atan!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the atan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atan2!","page":"For Developers","title":"GTPSA.mad_tpsa_atan2!","text":"mad_tpsa_atan2!(y::RealTPS, x::RealTPS, r::RealTPS)\n\nSets TPSA r to atan2(y,x)\n\nInput\n\ny – Source TPSA y\nx – Source TPSA x\n\nOutput\n\nr – Destination TPSA r = atan2(y,x)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atanh!","page":"For Developers","title":"GTPSA.mad_tpsa_atanh!","text":"mad_tpsa_atanh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the atanh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = atanh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ax2pby2pcz2!","page":"For Developers","title":"GTPSA.mad_tpsa_ax2pby2pcz2!","text":"mad_tpsa_ax2pby2pcz2!(a::Cdouble, x::RealTPS, b::Cdouble, y::RealTPS, c::Cdouble, z::RealTPS, r::RealTPS)\n\nr = a*x^2 + b*y^2 + c*z^2\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\nz – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpb!","page":"For Developers","title":"GTPSA.mad_tpsa_axpb!","text":"mad_tpsa_axpb!(a::Cdouble, x::RealTPS, b::Cdouble, r::RealTPS)\n\nr = a*x + b\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpbypc!","page":"For Developers","title":"GTPSA.mad_tpsa_axpbypc!","text":"mad_tpsa_axpbypc!(a::Cdouble, x::RealTPS, b::Cdouble, y::RealTPS, c::Cdouble, r::RealTPS)\n\nr = a*x + b*y + c\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_tpsa_axpsqrtbpcx2!","text":"mad_tpsa_axpsqrtbpcx2!(x::RealTPS, a::Cdouble, b::Cdouble, c::Cdouble, r::RealTPS)\n\nr = a*x + sqrt(b + c*x^2)\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypb!","page":"For Developers","title":"GTPSA.mad_tpsa_axypb!","text":"mad_tpsa_axypb!(a::Cdouble, x::RealTPS, y::RealTPS, b::Cdouble, r::RealTPS)\n\nr = a*x*y + b\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypbvwpc!","page":"For Developers","title":"GTPSA.mad_tpsa_axypbvwpc!","text":"mad_tpsa_axypbvwpc!(a::Cdouble, x::RealTPS, y::RealTPS, b::Cdouble, v::RealTPS, w::RealTPS, c::Cdouble, r::RealTPS)\n\nr = a*x*y + b*v*w + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nv – TPSA v\nw – TPSA w\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypbzpc!","page":"For Developers","title":"GTPSA.mad_tpsa_axypbzpc!","text":"mad_tpsa_axypbzpc!(a::Cdouble, x::RealTPS, y::RealTPS, b::Cdouble, z::RealTPS, c::Cdouble, r::RealTPS)\n\nr = a*x*y + b*z + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nz – TPSA z\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_clear!","page":"For Developers","title":"GTPSA.mad_tpsa_clear!","text":"mad_tpsa_clear!(t::RealTPS)\n\nClears the TPSA (reset to 0)\n\nInput\n\nt – TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_clrord!","page":"For Developers","title":"GTPSA.mad_tpsa_clrord!","text":"mad_tpsa_clrord!(t::RealTPS, ord::Cuchar)\n\nClears all monomial coefficients of the TPSA at order ord\n\nInput\n\nt – TPSA\nord – Order to clear monomial coefficients\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_compose!","page":"For Developers","title":"GTPSA.mad_tpsa_compose!","text":"mad_tpsa_compose!(na::Cint, ma, nb::Cint, mb, mc)\n\nComposes two maps.\n\nInput\n\nna – Number of TPSAs in map ma\nma – map ma\nnb – Number of TPSAs in map mb\nmb – map mb\n\nOutput\n\nmc – Composition of maps ma and mb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_convert!","page":"For Developers","title":"GTPSA.mad_tpsa_convert!","text":"mad_tpsa_convert!(t::RealTPS, r::RealTPS, n::Cint, t2r_, pb::Cint)\n\nGeneral function to convert TPSAs to different orders and reshuffle canonical coordinates. The destination TPSA will  be of order n, and optionally have the variable reshuffling defined by t2r_ and poisson bracket sign. e.g. if  t2r_ = {1,2,3,4,6,5} and pb = -1, canonical coordinates 6 and 5 are swapped and the new 5th canonical coordinate  will be negated. Useful for comparing with different differential algebra packages.\n\nInput\n\nt    – Source TPSA\nn    – Length of vector\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nr    – Destination TPSA with specified order and canonical coordinate reshuffling.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_copy!","page":"For Developers","title":"GTPSA.mad_tpsa_copy!","text":"mad_tpsa_copy!(t::RealTPS, r::RealTPS)\n\nMakes a copy of the TPSA t to r.\n\nInput\n\nt – Source TPSA\n\nOutput\n\nr – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cos!","page":"For Developers","title":"GTPSA.mad_tpsa_cos!","text":"mad_tpsa_cos!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the cos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cosh!","page":"For Developers","title":"GTPSA.mad_tpsa_cosh!","text":"mad_tpsa_cosh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the cosh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cot!","page":"For Developers","title":"GTPSA.mad_tpsa_cot!","text":"mad_tpsa_cot!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the cot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_coth!","page":"For Developers","title":"GTPSA.mad_tpsa_coth!","text":"mad_tpsa_coth!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the coth of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = coth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cpyi!","page":"For Developers","title":"GTPSA.mad_tpsa_cpyi!","text":"mad_tpsa_cpyi!(t::RealTPS, r::RealTPS, i::Cint)\n\nCopies the monomial coefficient at index i in t into the  same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \ni – Index of monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cpym!","page":"For Developers","title":"GTPSA.mad_tpsa_cpym!","text":"mad_tpsa_cpym!(t::RealTPS, r::RealTPS, n::Cint, m)\n\nCopies the monomial coefficient at the monomial-as-vector-of-orders m in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of monomial m\nm – Monomial as vector of orders\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cpys!","page":"For Developers","title":"GTPSA.mad_tpsa_cpys!","text":"mad_tpsa_cpys!(t::RealTPS, r::RealTPS, n::Cint, s::Cstring)\n\nCopies the monomial coefficient at the monomial-as-string-of-order s in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of string\ns – Monomial as string\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cpysm!","page":"For Developers","title":"GTPSA.mad_tpsa_cpysm!","text":"mad_tpsa_cpysm!(t::RealTPS, r::RealTPS, n::Cint, m)\n\nCopies the monomial coefficient at the monomial-as-sparse-monomial m in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of monomial m\nm – Monomial as sparse-monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cutord!","page":"For Developers","title":"GTPSA.mad_tpsa_cutord!","text":"mad_tpsa_cutord!(t::RealTPS, r::RealTPS, ord::Cint)\n\nCuts the TPSA off at the given order and above, or if ord is negative, will cut orders below  abs(ord) (e.g. if ord = -3, then orders 0-3 are cut off).\n\nInput\n\nt   – Source TPSA\nord – Cut order: 0..-ord or ord..mo\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cycle!","page":"For Developers","title":"GTPSA.mad_tpsa_cycle!","text":"mad_tpsa_cycle!(t::RealTPS, i::Cint, n::Cint, m_, v_)::Cint\n\nUsed for scanning through each nonzero monomial in the TPSA. Given a starting index (-1 if starting at 0), will  optionally fill monomial m_ with the monomial at index i and the value at v_ with the monomials coefficient, and  return the next NONZERO monomial index in the TPSA. This is useful for building an iterator through the TPSA.\n\nInput\n\nt  – TPSA to scan\ni  – Index to start from (-1 to start at 0)\nn  – Length of monomial\nm_ – (Optional) Monomial to be filled if provided\nv_ – (Optional) Pointer to value of coefficient\n\nOutput\n\ni  – Index of next nonzero monomial in the TPSA, or -1 if reached the end\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_debug","page":"For Developers","title":"GTPSA.mad_tpsa_debug","text":"mad_tpsa_debug(t::RealTPS, name_::Cstring, fnam_::Cstring, line_::Cint, stream_::Ptr{Cvoid})::Cint\n\nPrints TPSA with all information of data structure.\n\nInput\n\nt       – TPSA\nname_   – (Optional) Name of TPSA\nfnam_   – (Optional) File name to print to\nline_   – (Optional) Line number in file to start at\nstream_ – (Optional) I/O stream to print to, default is stdout\n\nOutput\n\nret – Cint reflecting internal state of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_del!","page":"For Developers","title":"GTPSA.mad_tpsa_del!","text":"mad_tpsa_del!(t::Ref{TPS{Float64}})\n\nCalls the destructor for the TPSA.\n\nInput\n\nt – TPSA to destruct\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_density","page":"For Developers","title":"GTPSA.mad_tpsa_density","text":"mad_tpsa_density(t::RealTPS, stat_, reset::Bool)::Cdouble\n\nComputes the ratio of nz/nc in [0] U [lo,hi] or stat_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_deriv!","page":"For Developers","title":"GTPSA.mad_tpsa_deriv!","text":"mad_tpsa_deriv!(a::RealTPS, c::RealTPS, iv::Cint)\n\nDifferentiates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to differentiate\niv – Index of variable to take derivative wrt to (e.g. derivative wrt x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_derivm!","page":"For Developers","title":"GTPSA.mad_tpsa_derivm!","text":"mad_tpsa_derivm!(a::RealTPS, c::RealTPS, n::Cint, m)\n\nDifferentiates TPSA with respect to the monomial defined by byte array m.\n\nInput\n\na – Source TPSA to differentiate\nn – Length of monomial to differentiate wrt\nm – Monomial to take derivative wrt\n\nOutput\n\nc – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_desc","page":"For Developers","title":"GTPSA.mad_tpsa_desc","text":"mad_tpsa_desc(t::RealTPS)::Ptr{Desc}\n\nGets the descriptor for the TPSA.\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Descriptor for the TPS{Float64}\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_dif!","page":"For Developers","title":"GTPSA.mad_tpsa_dif!","text":"mad_tpsa_dif!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nFor each homogeneous polynomial in TPSAs a and b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_div!","page":"For Developers","title":"GTPSA.mad_tpsa_div!","text":"mad_tpsa_div!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nSets the destination TPSA c = a / b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_equ","page":"For Developers","title":"GTPSA.mad_tpsa_equ","text":"mad_tpsa_equ(a::RealTPS, b::RealTPS, tol_::Cdouble)::Bool\n\nChecks if the TPSAs a and b are equal within the specified tolerance tol_. If tol_ is not specified, DBL_GTPSA.show_epsILON is used.\n\nInput\n\na    – TPSA a\nb    – TPSA b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_erf!","page":"For Developers","title":"GTPSA.mad_tpsa_erf!","text":"mad_tpsa_erf!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the erf of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = erf(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_erfc!","page":"For Developers","title":"GTPSA.mad_tpsa_erfc!","text":"mad_tpsa_erfc!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the erfc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = erfc(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_eval!","page":"For Developers","title":"GTPSA.mad_tpsa_eval!","text":"mad_tpsa_eval!(na::Cint, ma, nb::Cint, tb, tc)\n\nEvaluates the map at the point tb\n\nInput\n\nna – Number of TPSAs in the map\nma – map ma\nnb – Length of tb\ntb – Point at which to evaluate the map\n\nOutput\n\ntc – Values for each TPSA in the map evaluated at the point tb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_exp!","page":"For Developers","title":"GTPSA.mad_tpsa_exp!","text":"mad_tpsa_exp!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the exponential of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = exp(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_exppb!","page":"For Developers","title":"GTPSA.mad_tpsa_exppb!","text":"mad_tpsa_exppb!(na::Cint, ma, mb, mc)\n\nComputes the exponential of fgrad of the vector fields ma and mb, literally exppb(ma, mb) = mb + fgrad(ma, mb) + fgrad(ma, fgrad(ma, mb))/2! + ...\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_fgrad!","page":"For Developers","title":"GTPSA.mad_tpsa_fgrad!","text":"mad_tpsa_fgrad!(na::Cint, ma, b::RealTPS, c::RealTPS)\n\nCalculates dot(ma, grad(b))\n\nInput\n\nna – Length of ma consistent with number of variables in b\nma – Vector of TPSA\nb  – TPSA\n\nOutput\n\nc  – dot(ma, grad(b))\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_fld2vec!","page":"For Developers","title":"GTPSA.mad_tpsa_fld2vec!","text":"mad_tpsa_fld2vec!(na::Cint, ma, c::RealTPS)\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the Hamiltonian one obtains  from ther vector field (in the form [da/dp1, -da/dq1, ...])\n\nInput\n\nna  – Number of TPSA in ma consistent with number of variables in c\nma  – Vector field \n\nOutput\n\nc   – Hamiltonian as a TPSA derived from the vector field ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_geti","page":"For Developers","title":"GTPSA.mad_tpsa_geti","text":"mad_tpsa_geti(t::RealTPS, i::Cint)::Cdouble\n\nGets the coefficient of the monomial at index i. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\ni   – Monomial index\n\nOutput\n\nret – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getm","page":"For Developers","title":"GTPSA.mad_tpsa_getm","text":"mad_tpsa_getm(t::RealTPS, n::Cint, m)::Cdouble\n\nGets the coefficient of the monomial m defined as a byte array. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as byte array\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getord!","page":"For Developers","title":"GTPSA.mad_tpsa_getord!","text":"mad_tpsa_getord!(t::RealTPS, r::RealTPS, ord::Cuchar)\n\nExtract one homogeneous polynomial of the given order\n\nInput\n\nt  – Source TPSA\nord – Order to retrieve\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_gets","page":"For Developers","title":"GTPSA.mad_tpsa_gets","text":"mad_tpsa_gets(t::RealTPS, n::Cint, s::Cstring)::Cdouble\n\nGets the coefficient of the monomial s defined as a string. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Coefficient of monomial s in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getsm","page":"For Developers","title":"GTPSA.mad_tpsa_getsm","text":"mad_tpsa_getsm(t::RealTPS, n::Cint, m)::Cdouble\n\nGets the coefficient of the monomial m defined as a sparse monomial. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as sparse monomial\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getv!","page":"For Developers","title":"GTPSA.mad_tpsa_getv!","text":"mad_tpsa_getv!(t::RealTPS, i::Cint, n::Cint, v)\n\nVectorized getter of the coefficients for monomials with indices i..i+n. Useful for extracting the 1st order parts of  a TPSA to construct a matrix (i = 1, n = nv+np = nn). \n\nInput\n\nt – TPSA\ni – Starting index of monomials to get coefficients\nn – Number of monomials to get coefficients of starting at i\n\nOutput\n\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_hypot!","page":"For Developers","title":"GTPSA.mad_tpsa_hypot!","text":"mad_tpsa_hypot!(x::RealTPS, y::RealTPS, r::RealTPS)\n\nSets TPSA r to sqrt(x^2+y^2). Used to oversimplify polymorphism in code but not optimized\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_hypot3!","page":"For Developers","title":"GTPSA.mad_tpsa_hypot3!","text":"mad_tpsa_hypot3!(x::RealTPS, y::RealTPS, z::RealTPS, r::RealTPS)\n\nSets TPSA r to sqrt(x^2+y^2+z^2). Does NOT allow for r = x, y, z !!!\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\nz – Source TPSA z\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2+z^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxm","page":"For Developers","title":"GTPSA.mad_tpsa_idxm","text":"mad_tpsa_idxm(t::RealTPS, n::Cint, m)::Cint\n\nReturns index of monomial in the TPSA given the monomial as a byte array\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as byte array\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxs","page":"For Developers","title":"GTPSA.mad_tpsa_idxs","text":"mad_tpsa_idxs(t::RealTPS, n::Cint, s::Cstring)::Cint\n\nReturns index of monomial in the TPSA given the monomial as string. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxsm","page":"For Developers","title":"GTPSA.mad_tpsa_idxsm","text":"mad_tpsa_idxsm(t::RealTPS, n::Cint, m)::Cint\n\nReturns index of monomial in the TPSA given the monomial as a sparse monomial. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as sparse monomial\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_init!","page":"For Developers","title":"GTPSA.mad_tpsa_init!","text":"mad_tpsa_init(t::RealTPS, d::Ptr{Desc}, mo::Cuchar)::RealTPS\n\nUnsafe initialization of an already existing TPSA t with maximum order mo to the descriptor d. mo must be less than  the maximum order of the descriptor. t is modified in place and also returned.\n\nInput\n\nt  – TPSA to initialize to descriptor d\nd  – Descriptor\nmo – Maximum order of the TPSA (must be less than maximum order of the descriptor)\n\nOutput\n\nt  – TPSA initialized to descriptor d with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_integ!","page":"For Developers","title":"GTPSA.mad_tpsa_integ!","text":"mad_tpsa_integ!(a::RealTPS, c::RealTPS, iv::Cint)\n\nIntegrates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to integrate\niv – Index of variable to integrate over (e.g. integrate over x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_inv!","page":"For Developers","title":"GTPSA.mad_tpsa_inv!","text":"mad_tpsa_inv!(a::RealTPS,  v::Cdouble, c::RealTPS)\n\nSets TPSA c to v/a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_invsqrt!","page":"For Developers","title":"GTPSA.mad_tpsa_invsqrt!","text":"mad_tpsa_invsqrt!(a::RealTPS, v::Cdouble, c::RealTPS)\n\nSets TPSA c to v/sqrt(a). \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_isnul","page":"For Developers","title":"GTPSA.mad_tpsa_isnul","text":"mad_tpsa_isnul(t::RealTPS)::Bool\n\nChecks if TPSA is 0 or not\n\nInput\n\nt    – TPSA to check\n\nOutput\n\nret  – True or false\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_isval","page":"For Developers","title":"GTPSA.mad_tpsa_isval","text":"mad_tpsa_isval(t::RealTPS)::Bool\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_isvalid","page":"For Developers","title":"GTPSA.mad_tpsa_isvalid","text":"mad_tpsa_isvalid(t::RealTPS)::Bool\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_len","page":"For Developers","title":"GTPSA.mad_tpsa_len","text":"mad_tpsa_len(t::RealTPS, hi_::Bool)::Cint\n\nGets the length of the TPSA itself (e.g. the descriptor may be order 10 but TPSA may only be order 2)\n\nInput\n\nt   – TPSA\nhi_ – If true, returns the length up to the hi order in the TPSA, else up to mo. Default is false\n\nOutput\n\nret – Length of TPS{Float64}\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_liebra!","page":"For Developers","title":"GTPSA.mad_tpsa_liebra!","text":"mad_tpsa_liebra!(na::Cint, ma, mb, mc)\n\nComputes the Lie bracket of the vector fields ma and mb, defined as  sumi mai (dmb/dxi) - mbi (dma/dx_i).\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_log!","page":"For Developers","title":"GTPSA.mad_tpsa_log!","text":"mad_tpsa_log!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the log of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = log(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logaxpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_tpsa_logaxpsqrtbpcx2!","text":"mad_tpsa_logaxpsqrtbpcx2!(x::RealTPS, a::Cdouble, b::Cdouble, c::Cdouble, r::RealTPS)\n\nr = log(a*x + sqrt(b + c*x^2))\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logpb!","page":"For Developers","title":"GTPSA.mad_tpsa_logpb!","text":"mad_tpsa_logpb!(na::Cint, ma, mb, mc)\n\nComputes the log of the Poisson bracket of the vector of TPSA ma and mb; the result  is the vector field F used to evolve to ma from mb.\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logxdy!","page":"For Developers","title":"GTPSA.mad_tpsa_logxdy!","text":"mad_tpsa_logxdy!(x::RealTPS, y::RealTPS, r::RealTPS)\n\nr = log(x / y)\n\nInput\n\nx – TPSA x\ny – TPSA y\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_maxord!","page":"For Developers","title":"GTPSA.mad_tpsa_maxord!","text":"mad_tpsa_maxord!(t::RealTPS, n::Cint, idx_)::Cint\n\nReturns the index to the monomial with maximum abs(coefficient) in the TPSA for all orders 0 to n. If idx_  is provided, it is filled with the indices for the maximum abs(coefficient) monomial for each order up to n. \n\nInput\n\nt    – TPSA\nn    – Highest order to include in finding the maximum abs(coefficient) in the TPSA, length of idx_ if provided\n\nOutput\n\nidx_ – (Optional) If provided, is filled with indices to the monomial for each order up to n with maximum abs(coefficient)\nmi   – Index to the monomial in the TPSA with maximum abs(coefficient)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mconv!","page":"For Developers","title":"GTPSA.mad_tpsa_mconv!","text":"mad_tpsa_mconv!(na::Cint, ma, nc::Cint, mc, n::Cint, t2r_, pb::Cint)\n\nEquivalent to mad_tpsa_convert, but applies the conversion to all TPSAs in the map ma.\n\nInput\n\nna   – Number of TPSAs in the map\nma   – map ma\nnc   – Number of TPSAs in the output map mc\nn    – Length of vector (size of t2r_)\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nmc   – map mc with specified conversions \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_minv!","page":"For Developers","title":"GTPSA.mad_tpsa_minv!","text":"mad_tpsa_minv!(na::Cint, ma, nb::Cint, mc)\n\nInverts the map. To include the parameters in the inversion, na = nn and the output map  length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\n\nOutput\n\nmc – Inversion of map ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mnrm","page":"For Developers","title":"GTPSA.mad_tpsa_mnrm","text":"mad_tpsa_mnrm(na::Cint, ma)::Cdouble\n\nComputes the norm of the map (sum of absolute value of coefficients of all TPSAs in the map).\n\nInput\n\nna  – Number of TPSAs in the map\nma  – map ma\n\nOutput\n\nnrm – Norm of map (sum of absolute value of coefficients of all TPSAs in the map)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mo!","page":"For Developers","title":"GTPSA.mad_tpsa_mo!","text":"mad_tpsa_mo!(t::RealTPS, mo::Cuchar)::Cuchar\n\nSets the maximum order mo of the TPSA t, and returns the original mo. mo should be less than or equal to the allocated order ao.\n\nInput\n\nt   – TPSA\nmo – Maximum order to set the TPSA\n\nOutput\n\nret – Original mo of the TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mono!","page":"For Developers","title":"GTPSA.mad_tpsa_mono!","text":"mad_tpsa_mono!(t::RealTPS, i::Cint, n::Cint, m_, p_)::Cuchar\n\nReturns the order of the monomial at index i in the TPSA and optionally the monomial at that index is returned in m_  and the order of parameters in the monomial in p_\n\nInput\n\nt   – TPSA\ni   – Index valid in TPSA\nn   – Length of monomial\n\nOutput\n\nm_  – (Optional) Monomial at index i in TPSA\np_  – (Optional) Order of parameters in monomial\nret – Order of monomial in TPSA at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mord","page":"For Developers","title":"GTPSA.mad_tpsa_mord","text":"mad_tpsa_mord(na::Cint, ma, hi::Bool)::Cuchar\n\nIf hi is false, getting the maximum mo among all TPSAs in ma.  If hi is true, gets the maximum hi of the map instead of mo\n\nInput\n\nna – Length of map ma\nma – Map (vector of TPSAs)\nhi – If true, returns maximum hi, else returns maximum mo of the map\n\nOutput\n\nret – Maximum hi of the map if hi is true, else returns maximum mo of the map\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mul!","page":"For Developers","title":"GTPSA.mad_tpsa_mul!","text":"mad_tpsa_mul!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nSets the destination TPSA c = a * b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_nam","page":"For Developers","title":"GTPSA.mad_tpsa_nam","text":"mad_tpsa_nam(t::RealTPS, nam_)::Cstring\n\nGet the name of the TPSA, and will optionally set if nam_ != null\n\nInput\n\nt    – TPSA\nnam_ – Name to set the TPSA\n\nOutput\n\nret  – Name of TPS{Float64} (null terminated in C)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_new","page":"For Developers","title":"GTPSA.mad_tpsa_new","text":"mad_tpsa_new(t::Ref{TPS{Float64}}, mo::Cuchar)\n\nCreates a blank TPSA with same number of variables/parameters of the inputted TPSA,  with maximum order specified by mo. If MAD_TPSA_SAME is passed for mo, the mo  currently in t is used for the created TPSA. Ok with t=(tpsa_t*)ctpsa\n\nInput\n\nt   – TPSA\nmo  – Maximum order of new TPSA\n\nOutput\n\nret – New blank TPSA with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_newd","page":"For Developers","title":"GTPSA.mad_tpsa_newd","text":"mad_tpsa_newd(d::Ptr{Desc}, mo::Cuchar)\n\nCreates a TPSA defined by the specified descriptor and maximum order. If MAD_TPSA_DEFAULT  is passed for mo, the mo defined in the descriptor is used. If mo > d_mo, then mo = d_mo.\n\nInput\n\nd  – Descriptor\nmo – Maximum order\n\nOutput\n\nt  – New TPSA defined by the descriptor\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_nrm","page":"For Developers","title":"GTPSA.mad_tpsa_nrm","text":"mad_tpsa_nrm(a::RealTPS)::Cdouble\n\nCalculates the 1-norm of TPSA a (sum of abs of all coefficients)\n\nInput\n\na   – TPSA\n\nOutput\n\nnrm – 1-Norm of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ord","page":"For Developers","title":"GTPSA.mad_tpsa_ord","text":"mad_tpsa_ord(t::RealTPS, hi_::Bool)::Cuchar\n\nGets the TPSA maximum order, or hi if hi_ is true.\n\nInput\n\nt   – TPSA\nhi_ – Set true if hi is returned, else mo is returned\n\nOutput\n\nret – Order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ordv","page":"For Developers","title":"GTPSA.mad_tpsa_ordv","text":"mad_tpsa_ordv(t::RealTPS, ts::RealTPS...)::Cuchar\n\nReturns maximum order of all TPSAs provided.\n\nInput\n\nt  – TPSA\nts – Variable number of TPSAs passed as parameters\n\nOutput\n\nmo – Maximum order of all TPSAs provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pminv!","page":"For Developers","title":"GTPSA.mad_tpsa_pminv!","text":"mad_tpsa_pminv!(na::Cint, ma, nb::Cint, mc, select)\n\nComputes the partial inverse of the map with only the selected variables, specified by 0s or 1s in select. To include the parameters in the inversion, na = nn and the output map length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\nselect – Array of 0s or 1s defining which variables to do inverse on (atleast same size as na)'\n\nOutput\n\nmc     – Partially inverted map using variables specified as 1 in the select array\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_poisbra!","page":"For Developers","title":"GTPSA.mad_tpsa_poisbra!","text":"mad_tpsa_poisbra!(a::RealTPS, b::RealTPS, c::RealTPS, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPSAs a and b.\n\nInput\n\na  – Source TPSA a\nb  – Source TPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pow!","page":"For Developers","title":"GTPSA.mad_tpsa_pow!","text":"mad_tpsa_pow!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nSets the destination TPSA c = a ^ b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_powi!","page":"For Developers","title":"GTPSA.mad_tpsa_powi!","text":"mad_tpsa_powi!(a::RealTPS, n::Cint, c::RealTPS)\n\nSets the destination TPSA c = a ^ n where n is an integer.\n\nInput\n\na – Source TPSA a\nn – Integer power\n\nOutput\n\nc – Destination TPSA c = a ^ n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pown!","page":"For Developers","title":"GTPSA.mad_tpsa_pown!","text":"mad_tpsa_pown!(a::RealTPS, v::Cdouble, c::RealTPS)\n\nSets the destination TPSA c = a ^ v where v is of double precision.\n\nInput\n\na – Source TPSA a\nv – \"double\" precision power\n\nOutput\n\nc – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_print","page":"For Developers","title":"GTPSA.mad_tpsa_print","text":"mad_tpsa_print(t::RealTPS, name_::Cstring, eps_::Cdouble, nohdr_::Cint, stream_::Ptr{Cvoid})\n\nPrints the TPSA coefficients with precision eps_. If nohdr_ is not zero,  the header is not printed. \n\nInput\n\nt       – TPSA to print\nname_   – (Optional) Name of TPSA\neps_    – (Optional) Precision to output\nnohdr_  – (Optional) If True, no header is printed\nstream_ – (Optional) FILE pointer of output stream. Default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan","page":"For Developers","title":"GTPSA.mad_tpsa_scan","text":"mad_tpsa_scan(stream_::Ptr{Cvoid})::RealTPS\n\nScans in a TPSA from the stream_.\n\nInput\n\nstream_ – (Optional) I/O stream from which to read the TPSA, default is stdin\n\nOutput\n\nt       – TPSA scanned from I/O stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan_coef!","page":"For Developers","title":"GTPSA.mad_tpsa_scan_coef!","text":"mad_tpsa_scan_coef!(t::RealTPS, stream_::Ptr{Cvoid})\n\nRead TPSA coefficients into TPSA t. This should be used with mad_tpsa_scan_hdr for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nt       – TPSA with coefficients scanned from stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan_hdr","page":"For Developers","title":"GTPSA.mad_tpsa_scan_hdr","text":"mad_tpsa_scan_hdr(kind_::Ref{Cint}, name_::Ptr{Cuchar}, stream_::Ptr{Cvoid})::Ptr{Desc}\n\nRead TPSA header. Returns descriptor for TPSA given the header. This is useful for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nkind_   – (Optional) Real or complex TPSA, or detect automatically if not provided.\nname_   – (Optional) Name of TPSA\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nret     – Descriptor for the TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scl!","page":"For Developers","title":"GTPSA.mad_tpsa_scl!","text":"mad_tpsa_scl!(a::RealTPS, v::Cdouble, c::RealTPS)\n\nSets TPSA c to v*a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sclord!","page":"For Developers","title":"GTPSA.mad_tpsa_sclord!","text":"mad_tpsa_sclord!(t::RealTPS, r::RealTPS, inv::Bool, prm::Bool)\n\nScales all coefficients by order. If inv == 0, scales coefficients by order (derivation), else  scales coefficients by 1/order (integration).\n\nInput\n\nt   – Source TPSA\ninv – Put order up, divide, scale by inv of value of order\nprm – Parameters flag. If set to 0x0, the scaling excludes the order of the parameters in the monomials. Else, scaling is with total order of monomial\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_seti!","page":"For Developers","title":"GTPSA.mad_tpsa_seti!","text":"mad_tpsa_seti!(t::RealTPS, i::Cint, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\ni – Index of monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setm!","page":"For Developers","title":"GTPSA.mad_tpsa_setm!","text":"mad_tpsa_setm!(t::RealTPS, n::Cint, m, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setprm!","page":"For Developers","title":"GTPSA.mad_tpsa_setprm!","text":"mad_tpsa_setprm!(t::RealTPS, v::Cdouble, ip::Cint)\n\nSets the 0th and 1st order values for the specified parameter, and sets the rest of the variables/parameters to 0.  The 1st order value scl_ of a parameter is always 1.\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\nip   – Parameter index (e.g. iv = 1 is nn-nv+1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sets!","page":"For Developers","title":"GTPSA.mad_tpsa_sets!","text":"mad_tpsa_sets!(t::RealTPS, n::Cint, s::Cstring, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setsm!","page":"For Developers","title":"GTPSA.mad_tpsa_setsm!","text":"mad_tpsa_setsm!(t::RealTPS, n::Cint, m, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setv!","page":"For Developers","title":"GTPSA.mad_tpsa_setv!","text":"mad_tpsa_setv!(t::RealTPS, i::Cint, n::Cint, v)\n\nVectorized setter of the coefficients for monomials with indices i..i+n. Useful for putting a matrix into a map.\n\nInput\n\nt – TPSA\ni – Starting index of monomials to set coefficients\nn – Number of monomials to set coefficients of starting at i\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setval!","page":"For Developers","title":"GTPSA.mad_tpsa_setval!","text":"mad_tpsa_setval!(t::RealTPS, v::Cdouble)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0).\n\nInput\n\nt – TPSA to set to scalar\nv – Scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setvar!","page":"For Developers","title":"GTPSA.mad_tpsa_setvar!","text":"mad_tpsa_setvar!(t::RealTPS, v::Cdouble, iv::Cint, scl_::Cdouble)\n\nSets the 0th and 1st order values for the specified variable, and sets the rest of the variables/parameters to 0\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\niv   – Variable index\nscl_ – 1st order variable value (typically will be 1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sin!","page":"For Developers","title":"GTPSA.mad_tpsa_sin!","text":"mad_tpsa_sin!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the sin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinc!","page":"For Developers","title":"GTPSA.mad_tpsa_sinc!","text":"mad_tpsa_sinc!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the sinc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sincos!","page":"For Developers","title":"GTPSA.mad_tpsa_sincos!","text":"mad_tpsa_sincos!(a::RealTPS, s::RealTPS, c::RealTPS)\n\nSets TPSA s = sin(a) and TPSA c = cos(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sin(a)\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sincosh!","page":"For Developers","title":"GTPSA.mad_tpsa_sincosh!","text":"mad_tpsa_sincosh!(a::RealTPS, s::RealTPS, c::RealTPS)\n\nSets TPSA s = sinh(a) and TPSA c = cosh(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sinh(a)\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinh!","page":"For Developers","title":"GTPSA.mad_tpsa_sinh!","text":"mad_tpsa_sinh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the sinh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinhc!","page":"For Developers","title":"GTPSA.mad_tpsa_sinhc!","text":"mad_tpsa_sinhc!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the sinhc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sqrt!","page":"For Developers","title":"GTPSA.mad_tpsa_sqrt!","text":"mad_tpsa_sqrt!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the sqrt of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sub!","page":"For Developers","title":"GTPSA.mad_tpsa_sub!","text":"mad_tpsa_sub!(a::RealTPS, b::RealTPS, c::RealTPS)\n\nSets the destination TPSA c = a - b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_tan!","page":"For Developers","title":"GTPSA.mad_tpsa_tan!","text":"mad_tpsa_tan!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the tan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_tanh!","page":"For Developers","title":"GTPSA.mad_tpsa_tanh!","text":"mad_tpsa_tanh!(a::RealTPS, c::RealTPS)\n\nSets TPSA c to the tanh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_taylor!","page":"For Developers","title":"GTPSA.mad_tpsa_taylor!","text":"mad_tpsa_taylor!(a::RealTPS, n::Cint, coef, c::RealTPS)\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0 is the scalar part of TPSA a.\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_taylor_h!","page":"For Developers","title":"GTPSA.mad_tpsa_taylor_h!","text":"mad_tpsa_taylor_h!(a::RealTPS, n::Cint, coef, c::RealTPS)\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for  the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0  is the scalar part of TPSA a.\n\nSame as mad_tpsa_taylor, but uses Horner's method (which is 50%-100% slower because mul is  always full order).\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_translate!","page":"For Developers","title":"GTPSA.mad_tpsa_translate!","text":"mad_tpsa_translate!(na::Cint, ma, nb::Cint, tb, mc)\n\nTranslates the expansion point of the map by the amount tb.\n\nInput\n\nna – Number of TPSAS in the map\nma – map ma\nnb – Length of tb\ntb – Vector of amount to translate for each variable\n\nOutput\n\nmc – Map evaluated at the new point translated tb from the original evaluation point\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_uid!","page":"For Developers","title":"GTPSA.mad_tpsa_uid!","text":"mad_tpsa_uid!(t::RealTPS, uid_::Cint)::Cint\n\nSets the TPSA uid if uid_ != 0, and returns the current (previous if set) TPSA uid. \n\nInput\n\nt    – TPSA\nuid_ – uid to set in the TPSA if uid_ != 0\n\nOutput\n\nret  – Current (previous if set) TPSA uid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_unit!","page":"For Developers","title":"GTPSA.mad_tpsa_unit!","text":"mad_tpsa_unit!(a::RealTPS, c::RealTPS)\n\nInterpreting TPSA as a vector, gets the \"unit vector\", e.g. c = a/norm(a).  May be useful for checking for convergence.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_update!","page":"For Developers","title":"GTPSA.mad_tpsa_update!","text":"mad_tpsa_update!(t::RealTPS)\n\nUpdates the lo and hi fields of the TPSA to reflect the current state  given the lowest/highest nonzero monomial coefficients.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_vec2fld!","page":"For Developers","title":"GTPSA.mad_tpsa_vec2fld!","text":"mad_tpsa_vec2fld!(na::Cint, a::RealTPS, mc)\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [da/dp1, -da/dq1, ...]\n\nInput\n\nna  – Number of TPSA in mc consistent with number of variables in a\na   – Hamiltonian as a TPSA\n\nOutput\n\nmc  – Vector field derived from a using Hamilton's equations \n\n\n\n\n\n","category":"function"},{"location":"devel/#TPS{ComplexF64}","page":"For Developers","title":"TPS{ComplexF64}","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.mad_ctpsa_acc!\nGTPSA.mad_ctpsa_acc_r!\nGTPSA.mad_ctpsa_acos!\nGTPSA.mad_ctpsa_acosh!\nGTPSA.mad_ctpsa_acot!\nGTPSA.mad_ctpsa_acoth!\nGTPSA.mad_ctpsa_add!\nGTPSA.mad_ctpsa_addt!\nGTPSA.mad_ctpsa_asin!\nGTPSA.mad_ctpsa_asinc!\nGTPSA.mad_ctpsa_asinh!\nGTPSA.mad_ctpsa_asinhc!\nGTPSA.mad_ctpsa_atan!\nGTPSA.mad_ctpsa_atanh!\nGTPSA.mad_ctpsa_ax2pby2pcz2!\nGTPSA.mad_ctpsa_ax2pby2pcz2_r!\nGTPSA.mad_ctpsa_axpb!\nGTPSA.mad_ctpsa_axpb_r!\nGTPSA.mad_ctpsa_axpbypc!\nGTPSA.mad_ctpsa_axpbypc_r!\nGTPSA.mad_ctpsa_axpsqrtbpcx2!\nGTPSA.mad_ctpsa_axpsqrtbpcx2_r!\nGTPSA.mad_ctpsa_axypb!\nGTPSA.mad_ctpsa_axypb_r!\nGTPSA.mad_ctpsa_axypbvwpc!\nGTPSA.mad_ctpsa_axypbvwpc_r!\nGTPSA.mad_ctpsa_axypbzpc!\nGTPSA.mad_ctpsa_axypbzpc_r!\nGTPSA.mad_ctpsa_cabs!\nGTPSA.mad_ctpsa_carg!\nGTPSA.mad_ctpsa_clear!\nGTPSA.mad_ctpsa_clrord!\nGTPSA.mad_ctpsa_compose!\nGTPSA.mad_ctpsa_conj!\nGTPSA.mad_ctpsa_convert!\nGTPSA.mad_ctpsa_copy!\nGTPSA.mad_ctpsa_cos!\nGTPSA.mad_ctpsa_cosh!\nGTPSA.mad_ctpsa_cot!\nGTPSA.mad_ctpsa_coth!\nGTPSA.mad_ctpsa_cplx!\nGTPSA.mad_ctpsa_cpyi!\nGTPSA.mad_ctpsa_cpym!\nGTPSA.mad_ctpsa_cpys!\nGTPSA.mad_ctpsa_cpysm!\nGTPSA.mad_ctpsa_cutord!\nGTPSA.mad_ctpsa_cycle!\nGTPSA.mad_ctpsa_debug\nGTPSA.mad_ctpsa_del!\nGTPSA.mad_ctpsa_density\nGTPSA.mad_ctpsa_deriv!\nGTPSA.mad_ctpsa_derivm!\nGTPSA.mad_ctpsa_desc\nGTPSA.mad_ctpsa_dif!\nGTPSA.mad_ctpsa_dift!\nGTPSA.mad_ctpsa_div!\nGTPSA.mad_ctpsa_divt!\nGTPSA.mad_ctpsa_equ\nGTPSA.mad_ctpsa_equt\nGTPSA.mad_ctpsa_erf!\nGTPSA.mad_ctpsa_erfc!\nGTPSA.mad_ctpsa_eval!\nGTPSA.mad_ctpsa_exp!\nGTPSA.mad_ctpsa_exppb!\nGTPSA.mad_ctpsa_fgrad!\nGTPSA.mad_ctpsa_fld2vec!\nGTPSA.mad_ctpsa_geti\nGTPSA.mad_ctpsa_geti_r!\nGTPSA.mad_ctpsa_getm\nGTPSA.mad_ctpsa_getm_r!\nGTPSA.mad_ctpsa_getord!\nGTPSA.mad_ctpsa_gets\nGTPSA.mad_ctpsa_gets_r!\nGTPSA.mad_ctpsa_getsm\nGTPSA.mad_ctpsa_getsm_r!\nGTPSA.mad_ctpsa_getv!\nGTPSA.mad_ctpsa_hypot!\nGTPSA.mad_ctpsa_hypot3!\nGTPSA.mad_ctpsa_idxm\nGTPSA.mad_ctpsa_idxs\nGTPSA.mad_ctpsa_idxsm\nGTPSA.mad_ctpsa_imag!\nGTPSA.mad_ctpsa_init!\nGTPSA.mad_ctpsa_integ!\nGTPSA.mad_ctpsa_inv!\nGTPSA.mad_ctpsa_inv_r!\nGTPSA.mad_ctpsa_invsqrt!\nGTPSA.mad_ctpsa_invsqrt_r!\nGTPSA.mad_ctpsa_isnul\nGTPSA.mad_ctpsa_isval\nGTPSA.mad_ctpsa_isvalid\nGTPSA.mad_ctpsa_len\nGTPSA.mad_ctpsa_liebra!\nGTPSA.mad_ctpsa_log!\nGTPSA.mad_ctpsa_logaxpsqrtbpcx2!\nGTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!\nGTPSA.mad_ctpsa_logpb!\nGTPSA.mad_ctpsa_logxdy!\nGTPSA.mad_ctpsa_maxord\nGTPSA.mad_ctpsa_mconv!\nGTPSA.mad_ctpsa_minv!\nGTPSA.mad_ctpsa_mnrm\nGTPSA.mad_ctpsa_mo!\nGTPSA.mad_ctpsa_mono!\nGTPSA.mad_ctpsa_mord\nGTPSA.mad_ctpsa_mul!\nGTPSA.mad_ctpsa_mult!\nGTPSA.mad_ctpsa_nam\nGTPSA.mad_ctpsa_new\nGTPSA.mad_ctpsa_newd\nGTPSA.mad_ctpsa_nrm\nGTPSA.mad_ctpsa_ord\nGTPSA.mad_ctpsa_ordv\nGTPSA.mad_ctpsa_pminv!\nGTPSA.mad_ctpsa_poisbra!\nGTPSA.mad_ctpsa_poisbrat!\nGTPSA.mad_ctpsa_polar!\nGTPSA.mad_ctpsa_pow!\nGTPSA.mad_ctpsa_powi!\nGTPSA.mad_ctpsa_pown!\nGTPSA.mad_ctpsa_pown_r!\nGTPSA.mad_ctpsa_powt!\nGTPSA.mad_ctpsa_print\nGTPSA.mad_ctpsa_real!\nGTPSA.mad_ctpsa_rect!\nGTPSA.mad_ctpsa_scan\nGTPSA.mad_ctpsa_scan_coef!\nGTPSA.mad_ctpsa_scan_hdr\nGTPSA.mad_ctpsa_scl!\nGTPSA.mad_ctpsa_scl_r!\nGTPSA.mad_ctpsa_sclord!\nGTPSA.mad_ctpsa_seti!\nGTPSA.mad_ctpsa_seti_r!\nGTPSA.mad_ctpsa_setm!\nGTPSA.mad_ctpsa_setm_r!\nGTPSA.mad_ctpsa_setprm!\nGTPSA.mad_ctpsa_setprm_r!\nGTPSA.mad_ctpsa_sets!\nGTPSA.mad_ctpsa_sets_r!\nGTPSA.mad_ctpsa_setsm!\nGTPSA.mad_ctpsa_setsm_r!\nGTPSA.mad_ctpsa_setv!\nGTPSA.mad_ctpsa_setval!\nGTPSA.mad_ctpsa_setval_r!\nGTPSA.mad_ctpsa_setvar!\nGTPSA.mad_ctpsa_setvar_r!\nGTPSA.mad_ctpsa_sin!\nGTPSA.mad_ctpsa_sinc!\nGTPSA.mad_ctpsa_sincos!\nGTPSA.mad_ctpsa_sincosh!\nGTPSA.mad_ctpsa_sinh!\nGTPSA.mad_ctpsa_sinhc!\nGTPSA.mad_ctpsa_sqrt!\nGTPSA.mad_ctpsa_sub!\nGTPSA.mad_ctpsa_subt!\nGTPSA.mad_ctpsa_tan!\nGTPSA.mad_ctpsa_tanh!\nGTPSA.mad_ctpsa_taylor!\nGTPSA.mad_ctpsa_taylor_h!\nGTPSA.mad_ctpsa_tdif!\nGTPSA.mad_ctpsa_tdiv!\nGTPSA.mad_ctpsa_tpoisbra!\nGTPSA.mad_ctpsa_tpow!\nGTPSA.mad_ctpsa_translate!\nGTPSA.mad_ctpsa_tsub!\nGTPSA.mad_ctpsa_uid!\nGTPSA.mad_ctpsa_unit!\nGTPSA.mad_ctpsa_update!\nGTPSA.mad_ctpsa_vec2fld!","category":"page"},{"location":"devel/#GTPSA.mad_ctpsa_acc!","page":"For Developers","title":"GTPSA.mad_ctpsa_acc!","text":"mad_ctpsa_acc!(a::ComplexTPS, v::ComplexF64, c::ComplexTPS)\n\nAdds a*v to TPSA c. Aliasing OK.\n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_acc_r!","text":"mad_ctpsa_acc_r!(a::ComplexTPS, v_re::Cdouble, v_im::Cdouble, c::ComplexTPS)\n\nAdds a*v to TPSA c. Aliasing OK. Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acos!","page":"For Developers","title":"GTPSA.mad_ctpsa_acos!","text":"mad_ctpsa_acos!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the acos of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_acosh!","text":"mad_ctpsa_acosh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the acosh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acot!","page":"For Developers","title":"GTPSA.mad_ctpsa_acot!","text":"mad_ctpsa_acot!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the acot of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acoth!","page":"For Developers","title":"GTPSA.mad_ctpsa_acoth!","text":"mad_ctpsa_acoth!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the acoth of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acoth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_add!","page":"For Developers","title":"GTPSA.mad_ctpsa_add!","text":"mad_ctpsa_add!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPSA c = a + b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_addt!","page":"For Developers","title":"GTPSA.mad_ctpsa_addt!","text":"mad_ctpsa_addt!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a + b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asin!","page":"For Developers","title":"GTPSA.mad_ctpsa_asin!","text":"mad_ctpsa_asin!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the asin of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinc!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinc!","text":"mad_ctpsa_asinc!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the asinc(a) = asin(a)/a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinc(a) = asin(a)/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinh!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinh!","text":"mad_ctpsa_asinh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the asinh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinhc!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinhc!","text":"mad_ctpsa_asinhc!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the asinhc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_atan!","page":"For Developers","title":"GTPSA.mad_ctpsa_atan!","text":"mad_ctpsa_atan!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the atan of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_atanh!","page":"For Developers","title":"GTPSA.mad_ctpsa_atanh!","text":"mad_ctpsa_atanh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the atanh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ax2pby2pcz2!","page":"For Developers","title":"GTPSA.mad_ctpsa_ax2pby2pcz2!","text":"mad_ctpsa_ax2pby2pcz2!(a::ComplexF64, x::ComplexTPS, b::ComplexF64, y::ComplexTPS, c::ComplexF64, z::ComplexTPS, r::ComplexTPS)\n\nr = a*x^2 + b*y^2 + c*z^2\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\nz – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ax2pby2pcz2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_ax2pby2pcz2_r!","text":"mad_ctpsa_ax2pby2pcz2_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, b_re::Cdouble, b_im::Cdouble, y::ComplexTPS, c_re::Cdouble, c_im::Cdouble, z::ComplexTPS, r::ComplexTPS)\n\nr = a*x^2 + b*y^2 + c*z^2. Same as mad_ctpsa_ax2pby2pcz2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\ny    – TPSA y\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\nz    – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpb!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpb!","text":"mad_ctpsa_axpb!(a::ComplexF64, x::ComplexTPS, b::ComplexF64, r::ComplexTPS)\n\nr = a*x + b\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpb_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpb_r!","text":"mad_ctpsa_axpb_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, b_re::Cdouble, b_im::Cdouble, r::ComplexTPS)\n\nr = a*x + b. Same as mad_ctpsa_axpb without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpbypc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpbypc!","text":"mad_ctpsa_axpbypc!(a::ComplexF64, x::ComplexTPS, b::ComplexF64, y::ComplexTPS, c::ComplexF64, r::ComplexTPS)\n\nr = a*x+b*y+c\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpbypc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpbypc_r!","text":"mad_ctpsa_axpbypc_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, b_re::Cdouble, b_im::Cdouble, y::ComplexTPS, c_re::Cdouble, c_im::Cdouble, r::ComplexTPS)\n\nr = a*x + b*y + c. Same as mad_ctpsa_axpbypc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\ny    – TPSA y\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpsqrtbpcx2!","text":"mad_ctpsa_axpsqrtbpcx2!(x::ComplexTPS, a::ComplexF64, b::ComplexF64, c::ComplexF64, r::ComplexTPS)\n\nr = a*x + sqrt(b + c*x^2)\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpsqrtbpcx2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpsqrtbpcx2_r!","text":"mad_ctpsa_axpsqrtbpcx2_r!(x::ComplexTPS, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble, c_re::Cdouble, c_im::Cdouble, r::ComplexTPS)\n\nr = a*x + sqrt(b + c*x^2). Same as mad_ctpsa_axpsqrtbpcx2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypb!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypb!","text":"mad_ctpsa_axypb!(a::ComplexF64, x::ComplexTPS, y::ComplexTPS, b::ComplexF64, r::ComplexTPS)\n\nr = a*x*y + b\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypb_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypb_r!","text":"mad_ctpsa_axypb_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, y::ComplexTPS, b_re::Cdouble, b_im::Cdouble, r::ComplexTPS)\n\nr = a*x*y + b. Same as mad_ctpsa_axypb without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbvwpc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbvwpc!","text":"mad_ctpsa_axypbvwpc!(a::ComplexF64, x::ComplexTPS, y::ComplexTPS, b::ComplexF64, v::ComplexTPS, w::ComplexTPS, c::ComplexF64, r::ComplexTPS)\n\nr = a*x*y + b*v*w + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nv – TPSA v\nw – TPSA w\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbvwpc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbvwpc_r!","text":"mad_ctpsa_axypbvwpc_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, y::ComplexTPS, b_re::Cdouble, b_im::Cdouble, v::ComplexTPS, w::ComplexTPS, c_re::Cdouble, c_im::Cdouble, r::ComplexTPS)\n\nr = a*x*y + b*v*w + c. Same as mad_ctpsa_axypbvwpc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nv    – TPSA v\nw    – TPSA w\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbzpc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbzpc!","text":"mad_ctpsa_axypbzpc!(a::ComplexF64, x::ComplexTPS, y::ComplexTPS, b::ComplexF64, z::ComplexTPS, c::ComplexF64, r::ComplexTPS)\n\nr = a*x*y + b*z + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nz – TPSA z\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbzpc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbzpc_r!","text":"mad_ctpsa_axypbzpc_r!(a_re::Cdouble, a_im::Cdouble, x::ComplexTPS, y::ComplexTPS, b_re::Cdouble, b_im::Cdouble, z::ComplexTPS, c_re::Cdouble, c_im::Cdouble, r::ComplexTPS)\n\nr = a*x*y + b*z + c. Same as mad_ctpsa_axypbzpc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nz    – TPSA z\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cabs!","page":"For Developers","title":"GTPSA.mad_ctpsa_cabs!","text":"mad_ctpsa_cabs!(t::ComplexTPS, r::RealTPS)\n\nSets the TPS{Float64} r equal to the aboslute value of TPS{ComplexF64} t. Specifically, the  result contains a TPSA with the abs of all coefficients.\n\nInput\n\nt – Source TPS{ComplexF64}\n\nOutput\n\nr – Destination TPS{Float64} with r = |t|\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_carg!","page":"For Developers","title":"GTPSA.mad_ctpsa_carg!","text":"mad_ctpsa_carg!(t::ComplexTPS, r::RealTPS)\n\nSets the TPS{Float64} r equal to the argument (phase) of TPS{ComplexF64} t\n\nInput\n\nt – Source TPS{ComplexF64}\n\nOutput\n\nr – Destination TPS{Float64} with r = carg(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_clear!","page":"For Developers","title":"GTPSA.mad_ctpsa_clear!","text":"mad_ctpsa_clear!(t::ComplexTPS)\n\nClears the TPSA (reset to 0)\n\nInput\n\nt – Complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_clrord!","page":"For Developers","title":"GTPSA.mad_ctpsa_clrord!","text":"mad_ctpsa_clrord!(t::ComplexTPS, ord::Cuchar)\n\nClears all monomial coefficients of the TPSA at order ord\n\nInput\n\nt – TPSA\nord – Order to clear monomial coefficients\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_compose!","page":"For Developers","title":"GTPSA.mad_ctpsa_compose!","text":"mad_ctpsa_compose!(na::Cint, ma, nb::Cint, mb, mc)\n\nComposes two maps.\n\nInput\n\nna – Number of TPSAs in Map ma\nma – Map ma\nnb – Number of TPSAs in Map mb\nmb – Map mb\n\nOutput\n\nmc – Composition of maps ma and mb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_conj!","page":"For Developers","title":"GTPSA.mad_ctpsa_conj!","text":"mad_ctpsa_conj(a::ComplexTPS, c::ComplexTPS)\n\nCalculates the complex conjugate of of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = conj(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_convert!","page":"For Developers","title":"GTPSA.mad_ctpsa_convert!","text":"mad_ctpsa_convert!(t::ComplexTPS, r::ComplexTPS, n::Cint, t2r_, pb::Cint)\n\nGeneral function to convert TPSAs to different orders and reshuffle canonical coordinates. The destination TPSA will  be of order n, and optionally have the variable reshuffling defined by t2r_ and poisson bracket sign. e.g. if  t2r_ = {1,2,3,4,6,5} and pb = -1, canonical coordinates 6 and 5 are swapped and the new 5th canonical coordinate  will be negated. Useful for comparing with different differential algebra packages.\n\nInput\n\nt    – Source complex TPSA\nn    – Length of vector\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nr    – Destination complex TPSA with specified order and canonical coordinate reshuffling.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_copy!","page":"For Developers","title":"GTPSA.mad_ctpsa_copy!","text":"mad_ctpsa_copy!(t::ComplexTPS, r::ComplexTPS)\n\nMakes a copy of the complex TPSA t to r.\n\nInput\n\nt – Source complex TPSA\n\nOutput\n\nr – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cos!","page":"For Developers","title":"GTPSA.mad_ctpsa_cos!","text":"mad_ctpsa_cos!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the cos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_cosh!","text":"mad_ctpsa_cosh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the cosh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cot!","page":"For Developers","title":"GTPSA.mad_ctpsa_cot!","text":"mad_ctpsa_cot!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the cot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_coth!","page":"For Developers","title":"GTPSA.mad_ctpsa_coth!","text":"mad_ctpsa_coth!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the coth of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = coth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cplx!","page":"For Developers","title":"GTPSA.mad_ctpsa_cplx!","text":"mad_ctpsa_cplx!(re_, im_, r::ComplexTPS)\n\nCreates a TPS{ComplexF64} with real and imaginary parts from the TPS{Float64}s re_ and im_ respectively.\n\nInput\n\nre_ – Real part of TPS{ComplexF64} to make\nim_ – Imaginary part of TPS{ComplexF64} to make\n\nOutput\n\nr   – Destination TPS{ComplexF64} with r = re_ + im*im_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cpyi!","page":"For Developers","title":"GTPSA.mad_ctpsa_cpyi!","text":"mad_ctpsa_cpyi!(t::ComplexTPS, r::ComplexTPS, i::Cint)\n\nCopies the monomial coefficient at index i in t into the  same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \ni – Index of monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cpym!","page":"For Developers","title":"GTPSA.mad_ctpsa_cpym!","text":"mad_ctpsa_cpym!(t::ComplexTPS, r::ComplexTPS, n::Cint, m)\n\nCopies the monomial coefficient at the monomial-as-vector-of-orders m in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of monomial m\nm – Monomial as vector of orders\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cpys!","page":"For Developers","title":"GTPSA.mad_ctpsa_cpys!","text":"mad_ctpsa_cpys!(t::ComplexTPS, r::ComplexTPS, n::Cint, s::Cstring)\n\nCopies the monomial coefficient at the monomial-as-string-of-order s in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of string\ns – Monomial as string\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cpysm!","page":"For Developers","title":"GTPSA.mad_ctpsa_cpysm!","text":"mad_ctpsa_cpysm!(t::ComplexTPS, r::ComplexTPS, n::Cint, m)\n\nCopies the monomial coefficient at the monomial-as-sparse-monomial m in t into the same monomial coefficient in r\n\nInput\n\nt – Source TPSA\nr – Destination TPSA \nn – Length of sparse monomial m\nm – Monomial as sparse-monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cutord!","page":"For Developers","title":"GTPSA.mad_ctpsa_cutord!","text":"mad_ctpsa_cutord!(t::ComplexTPS, r::ComplexTPS, ord::Cint)\n\nCuts the TPSA off at the given order and above, or if ord is negative, will cut orders below  abs(ord) (e.g. if ord = -3, then orders 0-3 are cut off).\n\nInput\n\nt   – Source complex TPSA\nord – Cut order: 0..-ord or ord..mo\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cycle!","page":"For Developers","title":"GTPSA.mad_ctpsa_cycle!","text":"mad_ctpsa_cycle!(t::ComplexTPS, i::Cint, n::Cint, m_, v_)::Cint\n\nUsed for scanning through each nonzero monomial in the TPSA. Given a starting index (-1 if starting at 0), will  optionally fill monomial m_ with the monomial at index i and the value at v_ with the monomials coefficient, and  return the next NONZERO monomial index in the TPSA. This is useful for building an iterator through the TPSA.\n\nInput\n\nt  – TPSA to scan\ni  – Index to start from (-1 to start at 0)\nn  – Size of monomial\nm_ – (Optional) Monomial to be filled if provided\nv_ – (Optional) Pointer to value of coefficient\n\nOutput\n\ni  – Index of next nonzero monomial in the TPSA, or -1 if reached the end\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_debug","page":"For Developers","title":"GTPSA.mad_ctpsa_debug","text":"mad_ctpsa_debug(t::ComplexTPS, name_::Cstring, fnam_::Cstring, line_::Cint, stream_::Ptr{Cvoid})::Cint\n\nPrints TPSA with all information of data structure.\n\nInput\n\nt       – TPSA\nname_   – (Optional) Name of TPSA\nfnam_   – (Optional) File name to print to\nline_   – (Optional) Line number in file to start at\nstream_ – (Optional) I/O stream to print to, default is stdout\n\nOutput\n\nret – Cint reflecting internal state of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_del!","page":"For Developers","title":"GTPSA.mad_ctpsa_del!","text":"mad_ctpsa_del!(t::Ref{TPS{ComplexF64}})\n\nCalls the destructor for the complex TPSA.\n\nInput\n\nt – Complex TPSA to destruct\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_density","page":"For Developers","title":"GTPSA.mad_ctpsa_density","text":"mad_ctpsa_density(t::ComplexTPS, stat_, reset::Bool)::Cdouble\n\nComputes the ratio of nz/nc in [0] U [lo,hi] or stat_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_deriv!","page":"For Developers","title":"GTPSA.mad_ctpsa_deriv!","text":"mad_ctpsa_deriv!(a::ComplexTPS, c::ComplexTPS, iv::Cint)\n\nDifferentiates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to differentiate\niv – Index of variable to take derivative wrt to (e.g. derivative wrt x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_derivm!","page":"For Developers","title":"GTPSA.mad_ctpsa_derivm!","text":"mad_ctpsa_derivm!(a::ComplexTPS, c::ComplexTPS, n::Cint, m)\n\nDifferentiates TPSA with respect to the monomial defined by byte array m.\n\nInput\n\na – Source TPSA to differentiate\nn – Length of monomial to differentiate wrt\nm – Monomial to take derivative wrt\n\nOutput\n\nc – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_desc","page":"For Developers","title":"GTPSA.mad_ctpsa_desc","text":"mad_ctpsa_desc(t::ComplexTPS)::Ptr{Desc}\n\nGets the descriptor for the complex TPSA.\n\nInput\n\nt   – Complex TPSA\n\nOutput\n\nret – Descriptor for the TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_dif!","page":"For Developers","title":"GTPSA.mad_ctpsa_dif!","text":"mad_ctpsa_dif!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nFor each homogeneous polynomial in TPSAs a and b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_dift!","page":"For Developers","title":"GTPSA.mad_ctpsa_dift!","text":"mad_ctpsa_dift!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nFor each homogeneous polynomial in TPS{ComplexF64} a and TPS{Float64} b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_div!","page":"For Developers","title":"GTPSA.mad_ctpsa_div!","text":"mad_ctpsa_div!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPSA c = a / b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_divt!","page":"For Developers","title":"GTPSA.mad_ctpsa_divt!","text":"mad_ctpsa_divt!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a / b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_equ","page":"For Developers","title":"GTPSA.mad_ctpsa_equ","text":"mad_ctpsa_equ(a::ComplexTPS, b::ComplexTPS, tol_::Cdouble)::Bool\n\nChecks if the TPSAs a and b are equal within the specified tolerance tol_. If tol_ is not specified, DBL_GTPSA.show_epsILON is used.\n\nInput\n\na    – TPSA a\nb    – TPSA b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_equt","page":"For Developers","title":"GTPSA.mad_ctpsa_equt","text":"mad_ctpsa_equt(a::ComplexTPS, b::RealTPS, tol::Cdouble)::Bool\n\nChecks if the TPS{ComplexF64} a is equal to the TPS{Float64} b within the specified tolerance tol_  (internal real-to-complex conversion).\n\nInput\n\na    – TPS{ComplexF64} a\nb    – TPS{Float64} b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_erf!","page":"For Developers","title":"GTPSA.mad_ctpsa_erf!","text":"mad_ctpsa_erf!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the erf of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = erf(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_erfc!","page":"For Developers","title":"GTPSA.mad_ctpsa_erfc!","text":"mad_ctpsa_erfc!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the erfc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = erfc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_eval!","page":"For Developers","title":"GTPSA.mad_ctpsa_eval!","text":"mad_ctpsa_eval!(na::Cint, ma, nb::Cint, tb, tc)\n\nEvaluates the map at the point tb\n\nInput\n\nna – Number of TPSAs in the map\nma – Map ma\nnb – Length of tb\ntb – Point at which to evaluate the map\n\nOutput\n\ntc – Values for each TPSA in the map evaluated at the point tb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_exp!","page":"For Developers","title":"GTPSA.mad_ctpsa_exp!","text":"mad_ctpsa_exp!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the exp of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = exp(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_exppb!","page":"For Developers","title":"GTPSA.mad_ctpsa_exppb!","text":"mad_ctpsa_exppb!(na::Cint, ma, mb, mc)\n\nComputes the exponential of fgrad of the vector fields ma and mb, literally exppb(ma, mb) = mb + fgrad(ma, mb) + fgrad(ma, fgrad(ma, mb))/2! + ...\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_fgrad!","page":"For Developers","title":"GTPSA.mad_ctpsa_fgrad!","text":"mad_ctpsa_fgrad!(na::Cint, ma, b::ComplexTPS, c::ComplexTPS)\n\nCalculates dot(ma, grad(b))\n\nInput\n\nna – Length of ma consistent with number of variables in b\nma – Vector of TPSA\nb  – TPSA\n\nOutput\n\nc  – dot(ma, grad(b))\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_fld2vec!","page":"For Developers","title":"GTPSA.mad_ctpsa_fld2vec!","text":"mad_ctpsa_fld2vec!(na::Cint, ma, c::ComplexTPS)\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the Hamiltonian one obtains  from ther vector field (in the form [da/dp1, -da/dq1, ...])\n\nInput\n\nna  – Number of TPSA in ma consistent with number of variables in c\nma  – Vector field \n\nOutput\n\nc   – Hamiltonian as a TPSA derived from the vector field ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_geti","page":"For Developers","title":"GTPSA.mad_ctpsa_geti","text":"mad_ctpsa_geti(t::ComplexTPS, i::Cint)::ComplexF64\n\nGets the coefficient of the monomial at index i.  Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\ni   – Monomial index\n\nOutput\n\nret – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_geti_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_geti_r!","text":"mad_ctpsa_geti_r!(t::ComplexTPS, i::Cint,  r)\n\nGets the coefficient of the monomial at index i in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\ni – Monomial index\n\nOutput\n\nr – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getm","page":"For Developers","title":"GTPSA.mad_ctpsa_getm","text":"mad_ctpsa_getm(t::ComplexTPS, n::Cint, m)::ComplexF64\n\nGets the coefficient of the monomial m defined as a byte array. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as byte array\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_getm_r!","text":"mad_ctpsa_getm_r!(t::ComplexTPS, n::Cint, m, r)\n\nGets the coefficient of the monomial m defined as a byte array in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\n\nOutput\n\nr – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getord!","page":"For Developers","title":"GTPSA.mad_ctpsa_getord!","text":"mad_ctpsa_getord!(t::ComplexTPS, r::ComplexTPS, ord::Cuchar)\n\nExtract one homogeneous polynomial of the given order\n\nInput\n\nt  – Sourcecomplex TPSA\nord – Order to retrieve\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_gets","page":"For Developers","title":"GTPSA.mad_ctpsa_gets","text":"mad_ctpsa_gets(t::ComplexTPS, n::Cint, s::Cstring)::ComplexF64\n\nGets the coefficient of the monomial s defined as a string. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Size of monomial\ns   – Monomial as string\n\nOutput\n\nret – Coefficient of monomial s in TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_gets_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_gets_r!","text":"mad_ctpsa_gets_r!(t::ComplexTPS, n::Cint, s::Cstring, r)\n\nGets the coefficient of the monomial s defined as a string in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\n\nOutput\n\nr – Coefficient of monomial s in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getsm","page":"For Developers","title":"GTPSA.mad_ctpsa_getsm","text":"mad_ctpsa_getsm(t::ComplexTPS, n::Cint, m)::ComplexF64\n\nGets the coefficient of the monomial m defined as a sparse monomial. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as sparse monomial\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getsm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_getsm_r!","text":"mad_ctpsa_getsm_r!(t::ComplexTPS, n::Cint, m, r)\n\nGets the coefficient of the monomial m defined as a sparse monomial in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\n\nOutput\n\nr – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getv!","page":"For Developers","title":"GTPSA.mad_ctpsa_getv!","text":"mad_ctpsa_getv!(t::ComplexTPS, i::Cint, n::Cint, v)\n\nVectorized getter of the coefficients for monomials with indices i..i+n. Useful for extracting the 1st order parts of  a TPSA to construct a matrix (i = 1, n = nv+np = nn). \n\nInput\n\nt – TPSA\ni – Starting index of monomials to get coefficients\nn – Number of monomials to get coefficients of starting at i\n\nOutput\n\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_hypot!","page":"For Developers","title":"GTPSA.mad_ctpsa_hypot!","text":"mad_ctpsa_hypot!(x::ComplexTPS, y::ComplexTPS, r::ComplexTPS)\n\nSets TPSA r to sqrt(real(x)^2+real(y)^2) + im*sqrt(imag(x)^2+imag(y)^2)\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\n\nOutput\n\nr – Destination TPSA sqrt(real(x)^2+real(y)^2) + im*sqrt(imag(x)^2+imag(y)^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_hypot3!","page":"For Developers","title":"GTPSA.mad_ctpsa_hypot3!","text":"mad_ctpsa_hypot3!(x::ComplexTPS, y::ComplexTPS, z::ComplexTPS, r::ComplexTPS)\n\nSets TPSA r to sqrt(x^2+y^2+z^2).  Does NOT allow for r = x, y, z !!!\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\nz – Source TPSA z\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2+z^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxm","page":"For Developers","title":"GTPSA.mad_ctpsa_idxm","text":"mad_ctpsa_idxm(t::ComplexTPS, n::Cint, m)::Cint\n\nReturns index of monomial in the TPSA given the monomial as a byte array. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as byte array\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxs","page":"For Developers","title":"GTPSA.mad_ctpsa_idxs","text":"mad_ctpsa_idxs(t::ComplexTPS, n::Cint, s::Cstring)::Cint\n\nReturns index of monomial in the TPSA given the monomial as string. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxsm","page":"For Developers","title":"GTPSA.mad_ctpsa_idxsm","text":"mad_ctpsa_idxsm(t::ComplexTPS, n::Cint, m)::Cint\n\nReturns index of monomial in the TPSA given the monomial as a sparse monomial. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as sparse monomial\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_imag!","page":"For Developers","title":"GTPSA.mad_ctpsa_imag!","text":"mad_ctpsa_imag!(t::ComplexTPS, r::RealTPS)\n\nSets the TPS{Float64} r equal to the imaginary part of TPS{ComplexF64} t.\n\nInput\n\nt – Source TPS{ComplexF64}\n\nOutput\n\nr – Destination TPS{Float64} with r = Im(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_init!","page":"For Developers","title":"GTPSA.mad_ctpsa_init!","text":"mad_ctpsa_init(t::ComplexTPS, d::Ptr{Desc}, mo::Cuchar)::ComplexTPS\n\nUnsafe initialization of an already existing TPSA t with maximum order mo to the descriptor d. mo must be less than  the maximum order of the descriptor. t is modified in place and also returned.\n\nInput\n\nt  – TPSA to initialize to descriptor d\nd  – Descriptor\nmo – Maximum order of the TPSA (must be less than maximum order of the descriptor)\n\nOutput\n\nt  – TPSA initialized to descriptor d with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_integ!","page":"For Developers","title":"GTPSA.mad_ctpsa_integ!","text":"mad_ctpsa_integ!(a::ComplexTPS, c::ComplexTPS, iv::Cint)\n\nIntegrates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to integrate\niv – Index of variable to integrate over (e.g. integrate over x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_inv!","page":"For Developers","title":"GTPSA.mad_ctpsa_inv!","text":"mad_ctpsa_inv!(a::ComplexTPS,  v::ComplexF64, c::ComplexTPS)\n\nSets TPSA c to v/a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_inv_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_inv_r!","text":"mad_ctpsa_inv_r!(a::ComplexTPS, v_re::Cdouble, v_im::Cdouble, c::ComplexTPS)\n\nSets TPSA c to v/a.  Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_invsqrt!","page":"For Developers","title":"GTPSA.mad_ctpsa_invsqrt!","text":"mad_ctpsa_invsqrt!(a::ComplexTPS, v::ComplexF64, c::ComplexTPS)\n\nSets TPSA c to v/sqrt(a). \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_invsqrt_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_invsqrt_r!","text":"mad_ctpsa_invsqrt_r!(a::ComplexTPS, v_re::Cdouble, v_im::Cdouble, c::ComplexTPS)\n\nSets TPSA c to v/sqrt(a). Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_isnul","page":"For Developers","title":"GTPSA.mad_ctpsa_isnul","text":"mad_ctpsa_isnul(t::ComplexTPS)::Bool\n\nChecks if TPSA is 0 or not\n\nInput\n\nt    – Complex TPSA to check\n\nOutput\n\nret  – True or false\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_isval","page":"For Developers","title":"GTPSA.mad_ctpsa_isval","text":"mad_ctpsa_isval(t::ComplexTPS)::Bool\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_isvalid","page":"For Developers","title":"GTPSA.mad_ctpsa_isvalid","text":"mad_ctpsa_isvalid(t::ComplexTPS)::Bool\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – Complex TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_len","page":"For Developers","title":"GTPSA.mad_ctpsa_len","text":"mad_ctpsa_len(t::ComplexTPS, hi_::Bool)::Cint\n\nGets the length of the TPSA itself (e.g. the descriptor may be order 10 but TPSA may only be order 2)\n\nInput\n\nt   – Complex TPSA\nhi_ – If true, returns the length up to the hi order in the TPSA, else up to mo. Default is false\n\nOutput\n\nret – Length of TPS{ComplexF64}\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_liebra!","page":"For Developers","title":"GTPSA.mad_ctpsa_liebra!","text":"mad_ctpsa_liebra!(na::Cint, ma, mb, mc)\n\nComputes the Lie bracket of the vector fields ma and mb, defined as  sumi mai (dmb/dxi) - mbi (dma/dx_i).\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_log!","page":"For Developers","title":"GTPSA.mad_ctpsa_log!","text":"mad_ctpsa_log!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the log of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = log(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logaxpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_ctpsa_logaxpsqrtbpcx2!","text":"mad_ctpsa_logaxpsqrtbpcx2!(x::ComplexTPS, a::ComplexF64, b::ComplexF64, c::ComplexF64, r::ComplexTPS)\n\nr = log(a*x + sqrt(b + c*x^2))\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!","text":"mad_ctpsa_logaxpsqrtbpcx2_r!(x::ComplexTPS, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble, c_re::Cdouble, c_im::Cdouble, r::ComplexTPS)\n\nr = log(a*x + sqrt(b + c*x^2)). Same as mad_ctpsa_logaxpsqrtbpcx2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logpb!","page":"For Developers","title":"GTPSA.mad_ctpsa_logpb!","text":"mad_ctpsa_logpb!(na::Cint, ma, mb, mc)\n\nComputes the log of the Poisson bracket of the vector of TPSA ma and mb; the result  is the vector field F used to evolve to ma from mb.\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logxdy!","page":"For Developers","title":"GTPSA.mad_ctpsa_logxdy!","text":"mad_ctpsa_logxdy!(x::ComplexTPS, y::ComplexTPS, r::ComplexTPS)\n\nr = log(x / y)\n\nInput\n\nx – TPSA x\ny – TPSA y\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_maxord","page":"For Developers","title":"GTPSA.mad_ctpsa_maxord","text":"mad_ctpsa_maxord(t::ComplexTPS, n::Cint, idx_)::Cint\n\nReturns the index to the monomial with maximum abs(coefficient) in the TPSA for all orders 0 to n. If idx_  is provided, it is filled with the indices for the maximum abs(coefficient) monomial for each order up to n. \n\nInput\n\nt    – Complex TPSA\nn    – Highest order to include in finding the maximum abs(coefficient) in the TPSA, length of idx_ if provided\n\nOutput\n\nidx_ – (Optional) If provided, is filled with indices to the monomial for each order up to n with maximum abs(coefficient)\nmi   – Index to the monomial in the TPSA with maximum abs(coefficient)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mconv!","page":"For Developers","title":"GTPSA.mad_ctpsa_mconv!","text":"mad_ctpsa_mconv!(na::Cint, ma, nc::Cint, mc, n::Cint, t2r_, pb::Cint)\n\nEquivalent to mad_tpsa_convert, but applies the conversion to all TPSAs in the map ma.\n\nInput\n\nna   – Number of TPSAs in the map\nma   – Map ma\nnc   – Number of TPSAs in the output map mc\nn    – Length of vector (size of t2r_)\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nmc   – Map mc with specified conversions \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_minv!","page":"For Developers","title":"GTPSA.mad_ctpsa_minv!","text":"mad_ctpsa_minv!(na::Cint, ma, nb::Cint, mc)\n\nInverts the map. To include the parameters in the inversion, na = nn and the output map  length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\n\nOutput\n\nmc – Inversion of map ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mnrm","page":"For Developers","title":"GTPSA.mad_ctpsa_mnrm","text":"mad_ctpsa_mnrm(na::Cint, ma)::Cdouble\n\nComputes the norm of the map (sum of absolute value of coefficients of all TPSAs in the map).\n\nInput\n\nna  – Number of TPSAs in the map\nma  – Map ma\n\nOutput\n\nnrm – Norm of map (sum of absolute value of coefficients of all TPSAs in the map)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mo!","page":"For Developers","title":"GTPSA.mad_ctpsa_mo!","text":"mad_ctpsa_mo!(t::ComplexTPS, mo::Cuchar)::Cuchar\n\nSets the maximum order mo of the TPSA t, and returns the original mo. mo should be less than or equal to the allocated order ao.\n\nInput\n\nt   – TPSA\nmo – Maximum order to set the TPSA\n\nOutput\n\nret – Original mo of the TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mono!","page":"For Developers","title":"GTPSA.mad_ctpsa_mono!","text":"mad_ctpsa_mono!(t::ComplexTPS, i::Cint, n::Cint, m_, p_)::Cuchar\n\nReturns the order of the monomial at index i in the TPSA and optionally the monomial at that index is returned in m_ and the order of parameters in the monomial in p_\n\nInput\n\nt   – TPSA\ni   – Index valid in TPSA\nn   – Length of monomial\n\nOutput\n\nm_  – (Optional) Monomial at index i in TPSA\np_  – (Optional) Order of parameters in monomial\nret – Order of monomial in TPSA a index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mord","page":"For Developers","title":"GTPSA.mad_ctpsa_mord","text":"mad_ctpsa_mord(na::Cint, ma, hi::Bool)::Cuchar\n\nIf hi is false, getting the maximum mo among all TPSAs in ma.  If hi is true, gets the maximum hi of the map instead of mo\n\nInput\n\nna – Length of map ma\nma – Map (vector of TPSAs)\nhi – If true, returns maximum hi, else returns maximum mo of the map\n\nOutput\n\nret – Maximum hi of the map if hi is true, else returns maximum mo of the map\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mul!","page":"For Developers","title":"GTPSA.mad_ctpsa_mul!","text":"mad_ctpsa_mul!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPSA c = a * b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mult!","page":"For Developers","title":"GTPSA.mad_ctpsa_mult!","text":"mad_ctpsa_mult!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a * b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_nam","page":"For Developers","title":"GTPSA.mad_ctpsa_nam","text":"mad_ctpsa_nam(t::ComplexTPS, nam_::Cstring)::Cstring\n\nGet the name of the TPSA, and will optionally set if nam_ != null\n\nInput\n\nt    – TPSA\nnam_ – Optional name to set the TPSA\n\nOutput\n\nret  – Name of TPS{ComplexF64} (Null terminated in C)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_new","page":"For Developers","title":"GTPSA.mad_ctpsa_new","text":"mad_ctpsa_new(t::Ref{TPS{ComplexF64}}, mo::Cuchar)\n\nCreates a blank TPSA with same number of variables/parameters of the inputted TPSA,  with maximum order specified by mo. If MAD_TPSA_SAME is passed for mo, the mo  currently in t is used for the created TPSA. Ok with t=(tpsa_t*)ctpsa\n\nInput\n\nt   – TPSA\nmo  – Maximum order of new TPSA\n\nOutput\n\nret – New blank TPSA with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_newd","page":"For Developers","title":"GTPSA.mad_ctpsa_newd","text":"mad_ctpsa_newd(d::Ptr{Desc}, mo::Cuchar)\n\nCreates a complex TPSA defined by the specified descriptor and maximum order. If MADTPS{ComplexF64}DEFAULT  is passed for mo, the mo defined in the descriptor is used. If mo > d_mo, then mo = d_mo.\n\nInput\n\nd  – Descriptor\nmo – Maximum order\n\nOutput\n\nt  – New complex TPSA defined by the descriptor\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_nrm","page":"For Developers","title":"GTPSA.mad_ctpsa_nrm","text":"mad_ctpsa_nrm(a::ComplexTPS)::Cdouble\n\nCalculates the 1-norm of TPSA a (sum of abs of all coefficients)\n\nInput\n\na   – TPSA\n\nOutput\n\nnrm – 1-Norm of TPSA a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ord","page":"For Developers","title":"GTPSA.mad_ctpsa_ord","text":"mad_ctpsa_ord(t::ComplexTPS, hi_::Bool)::Cuchar\n\nGets the TPSA maximum order, or hi if hi_ is true.\n\nInput\n\nt   – TPSA\nhi_ – Set true if hi is returned, else mo is returned\n\nOutput\n\nret – Order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ordv","page":"For Developers","title":"GTPSA.mad_ctpsa_ordv","text":"mad_ctpsa_ordv(t::ComplexTPS, ts::ComplexTPS...)::Cuchar\n\nReturns maximum order of all TPSAs provided.\n\nInput\n\nt  – TPSA\nts – Variable number of TPSAs passed as parameters\n\nOutput\n\nmo – Maximum order of all TPSAs provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pminv!","page":"For Developers","title":"GTPSA.mad_ctpsa_pminv!","text":"mad_ctpsa_pminv!(na::Cint, ma, nb::Cint, mc, select)\n\nComputes the partial inverse of the map with only the selected variables, specified by 0s or 1s in select. To include the parameters in the inversion, na = nn and the output map length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\nselect – Array of 0s or 1s defining which variables to do inverse on (atleast same size as na)'\n\nOutput\n\nmc     – Partially inverted map using variables specified as 1 in the select array\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_poisbra!","page":"For Developers","title":"GTPSA.mad_ctpsa_poisbra!","text":"mad_ctpsa_poisbra!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPSAs a and b.\n\nInput\n\na  – Source TPSA a\nb  – Source TPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_poisbrat!","page":"For Developers","title":"GTPSA.mad_ctpsa_poisbrat!","text":"mad_ctpsa_poisbrat!(a::ComplexTPS, b::RealTPS, c::ComplexTPS, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPS{ComplexF64} aand TPS{Float64} b (internal real-to-complex conversion).\n\nInput\n\na  – Source TPS{ComplexF64} a\nb  – Source TPS{Float64} b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPS{ComplexF64} c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_polar!","page":"For Developers","title":"GTPSA.mad_ctpsa_polar!","text":"mad_ctpsa_polar!(t::ComplexTPS, r::ComplexTPS)\n\nSets r = |t| + im*atan2(Im(t), Re(t))\n\nInput\n\nt – Source TPS{ComplexF64}\nr – Destination TPS{ComplexF64}\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pow!","page":"For Developers","title":"GTPSA.mad_ctpsa_pow!","text":"mad_ctpsa_pow!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPSA c = a ^ b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_powi!","page":"For Developers","title":"GTPSA.mad_ctpsa_powi!","text":"mad_ctpsa_powi!(a::ComplexTPS, n::Cint, c::ComplexTPS)\n\nSets the destination TPSA c = a ^ n where n is an integer.\n\nInput\n\na – Source TPSA a\nn – Integer power\n\nOutput\n\nc – Destination TPSA c = a ^ n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pown!","page":"For Developers","title":"GTPSA.mad_ctpsa_pown!","text":"mad_ctpsa_pown!(a::ComplexTPS, v::ComplexF64, c::ComplexTPS)\n\nSets the destination TPSA c = a ^ v where v is of double precision.\n\nInput\n\na – Source TPSA a\nv – Power, ComplexF64\n\nOutput\n\nc – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pown_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_pown_r!","text":"mad_ctpsa_pown_r!(a::ComplexTPS, v_re::Cdouble, v_im::Cdouble, c::ComplexTPS)\n\nSets the destination TPSA c = a ^ v where v is of double precision. Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of power\nv_im – Imaginary part of power\n\nOutput\n\nc    – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_powt!","page":"For Developers","title":"GTPSA.mad_ctpsa_powt!","text":"mad_ctpsa_powt!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a ^ b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_print","page":"For Developers","title":"GTPSA.mad_ctpsa_print","text":"mad_ctpsa_print(t::ComplexTPS, name_ eps_::Cdouble, nohdr_::Cint, stream_::Ptr{Cvoid})\n\nPrints the TPSA coefficients with precision eps_. If nohdr_ is not zero,  the header is not printed. \n\nInput\n\nt       – TPSA to print\nname_   – (Optional) Name of TPSA\neps_    – (Optional) Precision to output\nnohdr_  – (Optional) If True, no header is printed\nstream_ – (Optional) FILE pointer of output stream. Default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_real!","page":"For Developers","title":"GTPSA.mad_ctpsa_real!","text":"mad_ctpsa_real!(t::ComplexTPS, r::RealTPS)\n\nSets the TPS{Float64} r equal to the real part of TPS{ComplexF64} t.\n\nInput\n\nt – Source TPS{ComplexF64}\n\nOutput\n\nr – Destination TPS{Float64} with r = Re(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_rect!","page":"For Developers","title":"GTPSA.mad_ctpsa_rect!","text":"mad_ctpsa_rect!(t::ComplexTPS, r::ComplexTPS)\n\nSets r = Re(t)*cos(Im(t)) + im*Re(t)*sin(Im(t))\n\nInput\n\nt – Source TPS{ComplexF64}\nr – Destination TPS{ComplexF64}\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan","page":"For Developers","title":"GTPSA.mad_ctpsa_scan","text":"mad_ctpsa_scan(stream_::Ptr{Cvoid})::ComplexTPS\n\nScans in a TPSA from the stream_.\n\nInput\n\nstream_ – (Optional) I/O stream from which to read the TPSA, default is stdin\n\nOutput\n\nt       – TPSA scanned from I/O stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan_coef!","page":"For Developers","title":"GTPSA.mad_ctpsa_scan_coef!","text":"mad_ctpsa_scan_coef!(t::ComplexTPS, stream_::Ptr{Cvoid})\n\nRead TPSA coefficients into TPSA t. This should be used with mad_tpsa_scan_hdr for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nstream_ – (Optional) I/O stream to read TPSA from, default is stdin\n\nOutput\n\nt       – TPSA with coefficients scanned from stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan_hdr","page":"For Developers","title":"GTPSA.mad_ctpsa_scan_hdr","text":"mad_ctpsa_scan_hdr(kind_::Ref{Cint}, name_::Ptr{Cuchar}, stream_::Ptr{Cvoid})::Ptr{Desc}\n\nRead TPSA header. Returns descriptor for TPSA given the header. This is useful for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nkind_   – (Optional) Real or complex TPSA, or detect automatically if not provided.\nname_   – (Optional) Name of TPSA\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nret     – Descriptor for the TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scl!","page":"For Developers","title":"GTPSA.mad_ctpsa_scl!","text":"mad_ctpsa_scl!(a::ComplexTPS, v::ComplexF64, c::ComplexTPS)\n\nSets TPSA c to v*a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scl_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_scl_r!","text":"mad_ctpsa_scl_r!(a::ComplexTPS, v_re::Cdouble, v_im::Cdouble,, c::ComplexTPS)\n\nSets TPSA c to v*a.  Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sclord!","page":"For Developers","title":"GTPSA.mad_ctpsa_sclord!","text":"mad_ctpsa_sclord!(t::ComplexTPS, r::ComplexTPS, inv::Bool, prm::Bool)\n\nScales all coefficients by order. If inv == 0, scales coefficients by order (derivation), else scales coefficients  by 1/order (integration).\n\nInput\n\nt   – Source complex TPSA\ninv – Put order up, divide, scale by inv of value of order\nprm – Parameters flag. If set to 0x0, the scaling excludes the order of the parameters in the monomials. Else, scaling is with total order of monomial\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_seti!","page":"For Developers","title":"GTPSA.mad_ctpsa_seti!","text":"mad_ctpsa_seti!(t::ComplexTPS, i::Cint, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\ni – Index of monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_seti_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_seti_r!","text":"mad_ctpsa_seti_r!(t::ComplexTPS, i::Cint, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_seti but without complex-by-value arguments.\n\nInput\n\nt – TPSA\ni – Index of monomial\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setm!","page":"For Developers","title":"GTPSA.mad_ctpsa_setm!","text":"mad_ctpsa_setm!(t::ComplexTPS, n::Cint, m, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setm_r!","text":"mad_ctpsa_setm_r!(t::ComplexTPS, n::Cint, m, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_setm but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setprm!","page":"For Developers","title":"GTPSA.mad_ctpsa_setprm!","text":"mad_ctpsa_setprm!(t::ComplexTPS, v::ComplexF64, ip::Cint)\n\nSets the 0th and 1st order values for the specified parameter, and sets the rest of the variables/parameters to 0.  The 1st order value scl_ of a parameter is always 1.\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\nip   – Parameter index (e.g. iv = 1 is nn-nv+1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setprm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setprm_r!","text":"mad_ctpsa_setprm_r!(t::ComplexTPS, v_re::Cdouble, v_im::Cdouble, ip::Cint)\n\nSets the 0th and 1st order values for the specified parameter. Equivalent to mad_ctpsa_setprm but without complex-by-value arguments. The 1st order value scl_ of a parameter is always 1.\n\nInput\n\nt       – Complex TPSA\nv_re    – Real part of 0th order value\nv_im    – Imaginary part of 0th order value\nip      – Parameter index\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sets!","page":"For Developers","title":"GTPSA.mad_ctpsa_sets!","text":"mad_ctpsa_sets!(t::ComplexTPS, n::Cint, s::Cstring, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sets_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_sets_r!","text":"mad_ctpsa_sets_r!(t::ComplexTPS, n::Cint, s::Cstring, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_set but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setsm!","page":"For Developers","title":"GTPSA.mad_ctpsa_setsm!","text":"mad_ctpsa_setsm!(t::ComplexTPS, n::Cint, m, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setsm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setsm_r!","text":"mad_ctpsa_setsm_r!(t::ComplexTPS, n::Cint, m, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_setsm but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setv!","page":"For Developers","title":"GTPSA.mad_ctpsa_setv!","text":"mad_ctpsa_setv!(t::ComplexTPS, i::Cint, n::Cint, v)\n\nVectorized setter of the coefficients for monomials with indices i..i+n. Useful for putting a matrix into a map.\n\nInput\n\nt – TPSA\ni – Starting index of monomials to set coefficients\nn – Number of monomials to set coefficients of starting at i\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setval!","page":"For Developers","title":"GTPSA.mad_ctpsa_setval!","text":"mad_ctpsa_setval!(t::ComplexTPS, v::ComplexF64)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0).\n\nInput\n\nt – TPSA to set to scalar\nv – Scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setval_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setval_r!","text":"mad_ctpsa_setval_r!(t::ComplexTPS, v_re::Cdouble, v_im::Cdouble)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0). Equivalent to mad_ctpsa_setval but without complex-by-value arguments.\n\nInput\n\nt    – TPSA to set to scalar\nv_re – Real part of scalar value to set TPSA\nv_im – Imaginary part of scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setvar!","page":"For Developers","title":"GTPSA.mad_ctpsa_setvar!","text":"madctpsasetvar!(t::ComplexTPS, v::ComplexF64, iv::Cint, scl_::ComplexF64)\n\nSets the 0th and 1st order values for the specified variable, and sets the rest of the variables to 0\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\niv   – Variable index\nscl_ – 1st order variable value (typically will be 1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setvar_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setvar_r!","text":"mad_ctpsa_setvar_r!(t::ComplexTPS, v_re::Cdouble, v_im::Cdouble, iv::Cint, scl_re_::Cdouble, scl_im_::Cdouble)\n\nSets the 0th and 1st order values for the specified variable. Equivalent to mad_ctpsa_setvar but without complex-by-value arguments.\n\nInput\n\nt       – Complex TPSA\nv_re    – Real part of 0th order value\nv_im    – Imaginary part of 0th order value\niv      – Variable index\nscl_re_ – (Optional) Real part of 1st order variable value\nscl_im_ – (Optional)Imaginary part of 1st order variable value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sin!","page":"For Developers","title":"GTPSA.mad_ctpsa_sin!","text":"mad_ctpsa_sin!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the sin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinc!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinc!","text":"mad_ctpsa_sinc!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the sinc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sincos!","page":"For Developers","title":"GTPSA.mad_ctpsa_sincos!","text":"mad_ctpsa_sincos!(a::ComplexTPS, s::ComplexTPS, c::ComplexTPS)\n\nSets TPSA s = sin(a) and TPSA c = cos(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sin(a)\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sincosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_sincosh!","text":"mad_ctpsa_sincosh!(a::ComplexTPS, s::ComplexTPS, c::ComplexTPS)\n\nSets TPSA s = sinh(a) and TPSA c = cosh(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sinh(a)\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinh!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinh!","text":"mad_ctpsa_sinh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the sinh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinhc!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinhc!","text":"mad_ctpsa_sinhc!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the sinhc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sqrt!","page":"For Developers","title":"GTPSA.mad_ctpsa_sqrt!","text":"mad_ctpsa_sqrt!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the sqrt of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sub!","page":"For Developers","title":"GTPSA.mad_ctpsa_sub!","text":"mad_ctpsa_sub!(a::ComplexTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPSA c = a - b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_subt!","page":"For Developers","title":"GTPSA.mad_ctpsa_subt!","text":"mad_ctpsa_subt!(a::ComplexTPS, b::RealTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a - b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{ComplexF64} a\nb – Source TPS{Float64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tan!","page":"For Developers","title":"GTPSA.mad_ctpsa_tan!","text":"mad_ctpsa_tan!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the tan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tanh!","page":"For Developers","title":"GTPSA.mad_ctpsa_tanh!","text":"mad_ctpsa_tanh!(a::ComplexTPS, c::ComplexTPS)\n\nSets TPSA c to the tanh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_taylor!","page":"For Developers","title":"GTPSA.mad_ctpsa_taylor!","text":"mad_ctpsa_taylor!(a::ComplexTPS, n::Cint, coef, c::ComplexTPS)\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0 is the scalar part of TPSA a\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_taylor_h!","page":"For Developers","title":"GTPSA.mad_ctpsa_taylor_h!","text":"mad_ctpsa_taylor_h!(a::ComplexTPS, n::Cint, coef, c::ComplexTPS)\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for  the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0  is the scalar part of TPSA a.\n\nSame as mad_ctpsa_taylor, but uses Horner's method (which is 50%-100% slower because mul is  always full order).\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tdif!","page":"For Developers","title":"GTPSA.mad_ctpsa_tdif!","text":"mad_ctpsa_tdif!(a::RealTPS, b::ComplexTPS, c::ComplexTPS)\n\nFor each homogeneous polynomial in TPS{Float64} a and TPS{ComplexF64} b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPS{Float64} a\nb – Source TPS{ComplexF64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tdiv!","page":"For Developers","title":"GTPSA.mad_ctpsa_tdiv!","text":"mad_ctpsa_tdiv!(a::RealTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a / b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{Float64} a\nb – Source TPS{ComplexF64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tpoisbra!","page":"For Developers","title":"GTPSA.mad_ctpsa_tpoisbra!","text":"mad_ctpsa_tpoisbra!(a::RealTPS, b::ComplexTPS, c::ComplexTPS, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPS{Float64} a and TPS{ComplexF64} b (internal real-to-complex conversion).\n\nInput\n\na  – Source TPS{Float64} a\nb  – Source TPS{ComplexF64} b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPS{ComplexF64} c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tpow!","page":"For Developers","title":"GTPSA.mad_ctpsa_tpow!","text":"mad_ctpsa_tpow!(a::RealTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a ^ b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{Float64} a\nb – Source TPS{ComplexF64} b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_translate!","page":"For Developers","title":"GTPSA.mad_ctpsa_translate!","text":"mad_ctpsa_translate!(na::Cint, ma, nb::Cint, tb, mc)\n\nTranslates the expansion point of the map by the amount tb.\n\nInput\n\nna – Number of TPSAS in the map\nma – Map ma\nnb – Length of tb\ntb – Vector of amount to translate for each variable\n\nOutput\n\nmc – Map evaluated at the new point translated tb from the original evaluation point\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tsub!","page":"For Developers","title":"GTPSA.mad_ctpsa_tsub!","text":"mad_ctpsa_tsub!(a::RealTPS, b::ComplexTPS, c::ComplexTPS)\n\nSets the destination TPS{ComplexF64} c = a - b (internal real-to-complex conversion).\n\nInput\n\na – Source TPS{Float64} a\nb – Source TPS{ComplexF64} b\n\nOutput\n\nc – Destination TPS{ComplexF64} c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_uid!","page":"For Developers","title":"GTPSA.mad_ctpsa_uid!","text":"mad_ctpsa_uid!(t::ComplexTPS, uid_::Cint)::Cint\n\nSets the TPSA uid if uid_ != 0, and returns the current (previous if set) TPSA uid. \n\nInput\n\nt    – Complex TPSA\nuid_ – uid to set in the TPSA if uid_ != 0\n\nOutput\n\nret  – Current (previous if set) TPSA uid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_unit!","page":"For Developers","title":"GTPSA.mad_ctpsa_unit!","text":"mad_ctpsa_unit!(a::ComplexTPS, c::ComplexTPS)\n\nInterpreting TPSA as a vector, gets the \"unit vector\", e.g. c = a/norm(a). May be useful for checking for convergence.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_update!","page":"For Developers","title":"GTPSA.mad_ctpsa_update!","text":"mad_ctpsa_update!(t::ComplexTPS)\n\nUpdates the lo and hi fields of the TPSA to reflect the current state  given the lowest/highest nonzero monomial coefficients.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_vec2fld!","page":"For Developers","title":"GTPSA.mad_ctpsa_vec2fld!","text":"mad_ctpsa_vec2fld!(na::Cint, a::ComplexTPS, mc)\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [da/dp1, -da/dq1, ...]\n\nInput\n\nna  – Number of TPSA in mc consistent with number of variables in a\na   – Hamiltonian as a TPSA\n\nOutput\n\nmc  – Vector field derived from a using Hamilton's equations \n\n\n\n\n\n","category":"function"},{"location":"man/a_toc/#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"man/a_toc/","page":"Table of Contents","title":"Table of Contents","text":"Descriptor: Defines the number of variables and parameters, and orders for each in the GTPSA\nTPS: Truncated Power Series struct\n@vars, @params: Creates a vector of TPSs corresponding to each variable (Delta x_i) or parameter (Delta k_j) in the GTPSA\nMonomial Indexing: Get/set individual monomial coefficients\nmono: Creates a TPS corresponding to a specific monomial\ngradient, jacobian, hessian: Extracts specific partial derivatives from a TPS\nSlicing and par: Indexing a specific polynomial within a TPS\nTPS-Specific Functions: Evaluate, compose, translate, integrate, differentiate, invert, etc.\n@FastGTPSA/@FastGTPSA! Macros: Speed up evaluation of expressions containing TPSs, transparent to other types\nI/O: Reading/writing TPSs\nGlobal Variables: Global non-constant variables\nAll Overloaded Functions: List of all overloaded Base functions and more ","category":"page"},{"location":"man/c_tps/#tps","page":"TPS","title":"TPS","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"Truncated Power Series struct TPS{T<:Union{Float64,ComplexF64},D} <: Number","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"T is the number type of the monomial coefficients in the TPS. Currently, GTPSA only supports TPSs with Float64 or ComplexF64 monomial coefficients.","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"D is either a Descriptor (for static Descriptor resolution) or GTPSA.Dynamic (for dynamic Descriptor resolution). ","category":"page"},{"location":"man/c_tps/#Aliases","page":"TPS","title":"Aliases","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"const TPS64 = TPS{Float64}\nconst ComplexTPS64 = TPS{ComplexF64}","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"Note that TPS{Float64}{D} == TPS{Float64,D} == TPS64{D}. See the Julia documentation for UnionAll types for more details.","category":"page"},{"location":"man/c_tps/#Syntax","page":"TPS","title":"Syntax","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"t = TPS[{descriptor|numtype}]([number] [, use=(descriptor|tps)])\n\n# Static Descriptor resolution:\nt = TPS{descriptor}([number])\nt = TPS{Float64|ComplexF64, descriptor}([number])\n\n# Dynamic Descriptor resolution:\nt = TPS([number] [, use=(descriptor|tps)]) \nt = TPS{Float64|ComplexF64 [, GTPSA.Dynamic]}([number] [, use=(descriptor|tps)]) ","category":"page"},{"location":"man/c_tps/#Static-Descriptor-Resolution","page":"TPS","title":"Static Descriptor Resolution","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"t = TPS{descriptor}([number]) constructs a new TPS using descriptor, equal to number if provided. If number is a TPS and has the same Descriptor, then this is a copy constructor. If number is a TPS and has a different Descriptor, then this will change the Descriptor granted the number of variables + parameters are equivalent. The monomial coefficient number type is inferred from number, defaulting to Float64.","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"t = TPS{Float64|ComplexF64, descriptor}([number]) is the same as t = TPS{descriptor}([number]) but with the monomial coefficient number type explicitly specified.","category":"page"},{"location":"man/c_tps/#Examples","page":"TPS","title":"Examples","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd1 = Descriptor(1, 1); # 1 variable to order 1\nt1_1 = TPS{d1}()\nt2_1 = TPS{d1}(5im)\nt3_1 = TPS{d1}(t2_1)\nd2 = Descriptor(1, 10); # New Descriptor to order 10\nt1_2 = TPS64{d2}() # Uses d2\nt2_2 = ComplexTPS64{d2}(6)\nt3_2 = ComplexTPS64{d2}(t3_1) # Promotes and changes Descriptor","category":"page"},{"location":"man/c_tps/#Dynamic-Descriptor-Resolution","page":"TPS","title":"Dynamic Descriptor Resolution","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"t = TPS([number] [, use=(descriptor|tps)]) construct a new TPS, equal to number if provided, and inferring the Descriptor from the input arguments:","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"Ctor Call Descriptor\nTPS() GTPSA.desc_current\nTPS(use=descriptor) descriptor\nTPS(use=tps1) That of tps1\nTPS(tps) That of tps\nTPS(number) GTPSA.desc_current\nTPS(number, use=(descriptor or tps1) ) descriptor or that of tps1\nTPS(tps, use=(descriptor or tps1) ) descriptor or that of tps1 (copies + changes Descriptor!)","category":"page"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"t = TPS{Float64|ComplexF64 [, GTPSA.Dynamic]}([number] [, use=(descriptor|tps)]) is the same as TPS([number] [, use=(descriptor|tps)]) but with the monomial coefficient number type explicitly specified, and optionally the GTPSA.Dynamic dynamic mode identifier explicitly specified.","category":"page"},{"location":"man/c_tps/#Optional-Keyword-Argument","page":"TPS","title":"Optional Keyword Argument","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"use=(descriptor|tps) creates a new TPS having a Descriptor equal to that passed. If changing the Descriptor of a TPS, the number of variable + number of parameters must be equivalent, and invalid monomials in the new Descriptor will be removed.","category":"page"},{"location":"man/c_tps/#Examples-2","page":"TPS","title":"Examples","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd1 = Descriptor(1, 1); # 1 variable to order 1\nt1_1 = TPS()\nt2_1 = TPS(5im)\nt3_1 = TPS(t2_1)\nd2 = Descriptor(1, 10); # New Descriptor to order 10\nt1_2 = TPS64() # Uses d2\nt2_2 = ComplexTPS64(6)\nt3_2 = ComplexTPS64(t3_1, use=d2) # Promotes and changes Descriptor","category":"page"},{"location":"man/c_tps/#Documentation","page":"TPS","title":"Documentation","text":"","category":"section"},{"location":"man/c_tps/","page":"TPS","title":"TPS","text":"TPS","category":"page"},{"location":"man/c_tps/#GTPSA.TPS","page":"TPS","title":"GTPSA.TPS","text":"TPS{D}([number]) where {D}\nTPS{T,D}([number]) where {T<:Union{Float64,ComplexF64}}\n\nTPS([number] [, use=(descriptor|tps)])\nTPS{T}([number] [, use=(descriptor|tps)]) where {T<:Union{Float64,ComplexF64}}\nTPS{T,GTPSA.Dynamic}([number] [, use=(descriptor|tps)]) where {T<:Union{Float64,ComplexF64}}\n\nConstructor to create a new TPS, equal to number if provided. \n\nA constructed TPS must correspond to some previously defined Descriptor. As such, two \"modes\" of the TPS type may be  constructed to determine how the Descriptor to use is resolved:\n\nDynamic Descriptor resolution – The Descriptor is inferred at runtime, based on the passed arguments:\n\nCtor Call Descriptor\nTPS() GTPSA.desc_current\nTPS(use=descriptor) descriptor\nTPS(use=tps1) That of tps1\nTPS(tps) That of tps\nTPS(number) GTPSA.desc_current\nTPS(number, use=(descriptor or tps1) ) descriptor or that of tps1\nTPS(tps, use=(descriptor or tps1) ) descriptor or that of tps1 (copies + changes Descriptor!)\n\nThe same applies for all of the above constructor calls with the constructors TPS64(...) and ComplexTPS64(...). The created type will be a TPS{T,GTPSA.Dynamic} where {T<:Union{Float64,ComplexF64}}. Dynamic Descriptor resolution  will always be type stable, as the Descriptor for each TPS is not stored in the type definition. E.g., one can have  an array with elements of the concrete type TPS{T,GTPSA.Dynamic} even though the individual TPSs in the array may  have differing Descriptors. Another example is typing the field of a struct as TPS{T,GTPSA.Dynamic}, so that field  can contain TPSs of different Descriptors in a type-stable fashion. However, with dynamic Descriptor resolution  the use kwarg must be specified if the Descriptor is both not inferrable nor GTPSA.desc_current is the desired  Descriptor. For calls such as zeros(TPS64, N) or TPS64(5.0), only GTPSA.desc_current can be inferred.\n\nStatic Descriptor resolution – The Descriptor is stored explicitly in the TPS type:\n\nCtor Call Descriptor\nTPS{descriptor}([number]) descriptor\nTPS{descriptor2}(::TPS{T,descriptor1}) descriptor2 (copies + changes Descriptor!)\nTPS(::TPS{T,descriptor}) descriptor\n\nThe same applies for all of the above constructor calls with the constructors TPS64{...}(...) and ComplexTPS64{...}(...). The created type will be a TPS{T,descriptor} where {T<:Union{Float64,ComplexF64}}. Care must be taken with static  Descriptor resolution to ensure type-stability, and in some cases it may not be possible. However, static resolution has  the benefit that the Descriptor is stored explicitly in the type. As such, GTPSA.desc_current is never used with this mode,  nor is the use kwarg. Calls such as zeros(TPS64{descriptor}, N) can be made ensuring the Descriptor of the output is correct.\n\n\n\n\n\n","category":"type"},{"location":"man/k_io/#io","page":"I/O","title":"I/O","text":"","category":"section"},{"location":"man/k_io/#Global-Variables","page":"I/O","title":"Global Variables","text":"","category":"section"},{"location":"man/k_io/","page":"I/O","title":"I/O","text":"There are two non-constant global variables which can be set to customize the printed output of TPSs:","category":"page"},{"location":"man/k_io/","page":"I/O","title":"I/O","text":"show_eps::Float64 =  0.0     # Print epsilon\nshow_sparse::Bool = false    # Use sparse monomial print","category":"page"},{"location":"man/k_io/","page":"I/O","title":"I/O","text":"show_eps defines the value below which the absolute value of a monomial coefficient is NOT printed","category":"page"},{"location":"man/k_io/","page":"I/O","title":"I/O","text":"show_sparse specifies whether the sparse monomial format is used for printing. This is useful for GTPSAs containing a large number of variables and parameters","category":"page"},{"location":"man/k_io/#Examples","page":"I/O","title":"Examples","text":"","category":"section"},{"location":"man/k_io/","page":"I/O","title":"I/O","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nd = Descriptor(100, 1, 10, 1)\nx = @vars() # Doesn't fit on screen\nGTPSA.show_sparse = true;\nx","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#descmodes","page":"Advanced Usage","title":"Static and Dynamic Descriptor Resolution","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"A constructed TPS must correspond to some previously defined Descriptor. Two \"modes\" of the TPS type may be constructed to determine how the Descriptor to use is resolved:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Static Descriptor resolution (Default): The Descriptor is stored explicitly in the TPS type:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Ctor Call Descriptor\nTPS{descriptor}([number]) descriptor\nTPS{descriptor2}(::TPS{T,descriptor1}) descriptor2 (copies + changes Descriptor!)\nTPS(::TPS{T,descriptor}) descriptor","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The same applies for all of the above constructor calls with the constructors TPS64{...}(...) and ComplexTPS64{...}(...). The created type will be a TPS{T,descriptor} where {T<:Union{Float64,ComplexF64}}. Care must be taken with static Descriptor resolution to ensure type-stability, and in some cases it may not be possible. However, static resolution has the benefit that the Descriptor is stored explicitly in the type. Calls such as zeros(TPS64{descriptor}, N) can be made ensuring the Descriptor of the output is correct.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Dynamic Descriptor resolution: The Descriptor is inferred at runtime, based on the passed arguments. A non-constant global variable GTPSA.desc_current stores the most recently-defined Descriptor to use if no Descriptor is inferrable. GTPSA.desc_current can also be set manually at any time by the user. Alternatively, the Descriptor to use can be provided to the use keyword argument of a TPS constructor.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Ctor Call Descriptor\nTPS() GTPSA.desc_current\nTPS(use=descriptor) descriptor\nTPS(use=tps1) That of tps1\nTPS(tps) That of tps\nTPS(number) GTPSA.desc_current\nTPS(number, use=(descriptor or tps1) ) descriptor or that of tps1\nTPS(tps, use=(descriptor or tps1) ) descriptor or that of tps1 (copies + changes Descriptor!)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The same applies for all of the above constructor calls with the constructors TPS64(...) and ComplexTPS64(...). The created type will be a TPS{T,GTPSA.Dynamic} where {T<:Union{Float64,ComplexF64}}. Dynamic Descriptor resolution will always be type stable, as the Descriptor for each TPS is not stored in the type definition. E.g., one can have an array with elements of the concrete type TPS{T,GTPSA.Dynamic} even though the individual TPSs in the array may have differing Descriptors. Another example is typing the field of a struct as TPS{T,GTPSA.Dynamic}, so that field can contain TPSs of different Descriptors in a type-stable fashion. However, with dynamic Descriptor resolution the use kwarg must be specified if the Descriptor is both not inferrable nor GTPSA.desc_current is the desired Descriptor. For calls such as zeros(TPS64, N) or TPS64(5.0), only GTPSA.desc_current can be inferred.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Note that static Descriptor resolution has no knowledge of GTPSA.desc_current, nor is the use kwarg allowed.","category":"page"},{"location":"advanced/#Parameters","page":"Advanced Usage","title":"Parameters","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"GTPSA allows one to explicitly distinguish between variables and parameters. Generally, a variable would be a dependent variable in a differential equation, and a parameter would be variations in something defining or influencing the system (for example, in a harmonic oscillator with restoring constant k, a \"parameter\" in the context of GTPSA.jl would be Delta k).","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"The parameters part of a monomial may be specified with its own truncation order, referred to as the parameter order. Basically, the parameter order defines when to truncate the entire monomial, once the parameters only part exceeds the parameter order. This is best shown with an example.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Example: allowed monomials for GTPSA with one variable and two parameters, with maximum order 2 and varying parameter orders:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Exponents Parameter Order = 1 Parameter Order = 2\n1quad  quad 0 quad 0 ✅ ✅\n0quad  quad 1 quad 0 ✅ ✅\n0quad  quad 0 quad 1 ✅ ✅\n2quad  quad 0 quad 0 ✅ ✅\n1quad  quad 1 quad 0 ✅ ✅\n0quad  quad 2 quad 0 ❌ ✅\n1quad  quad 0 quad 1 ✅ ✅\n0quad  quad 1 quad 1 ❌ ✅\n0quad  quad 0 quad 2 ❌ ✅","category":"page"},{"location":"advanced/#cto","page":"Advanced Usage","title":"Custom Truncation Orders","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"GTPSA allows for significant customization in the truncation of specific variables within a monomial of the truncated power series (TPS). One can specify individually the truncation orders for each variable in a truncated power series, as well as the maximum truncation order for an entire monomial in the TPS. This is best shown with an example:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Suppose we'd like to express a function f(x_1x_2) as a truncated power series, and keep only terms that are up to 1st-order in x_1 but up to 2nd order in x_2; basically, we should not have any monomials where x_1 has an exponent > 1, nor any monomials where x_2 has an exponent > 2. GTPSA allows one to select the individual truncation orders for variables in a monomial in this manner. The next question to consider is the maximum truncation order for the entire monomial; in the above example, note that the 3rd-order term x_1x_2^2 follows the rules we layed out so far. But what if we'd also like to truncate all monomials with order 3 and above, and not allow this monomial? This can be achieved by setting the maximum truncation order equal to 2. When defining a GTPSA, the user must always specify the maximum truncation order, which when specifying individual truncation orders must lie within the range textrmmax(textrmindividual truncation orders) textrmsum(textrmindividual truncation orders). If individual truncation orders are not specified, then they are automatically set to the maximum truncation order.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Example: allowed monomials for f(x_1x_2) with individual variable truncation orders [1,2] and different maximum truncation orders:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Exponents Max Order = 2 Max Order = 3\n1quad 0 ✅ ✅\n0quad 1 ✅ ✅\n2quad 0 ❌ ❌\n1quad 1 ✅ ✅\n0quad 2 ✅ ✅\n3quad 0 ❌ ❌\n2quad 1 ❌ ❌\n1quad 2 ❌ ✅\n0quad 3 ❌ ❌","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"We can define these two GTPSA Descriptors respectively with:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using GTPSA; GTPSA.show_sparse=false; #hide\nd2 = Descriptor([1, 2], 2) # Variable truncation orders [1, 2] and MO=2\nd3 = Descriptor([1, 2], 3) # Variable truncation orders [1, 2] and MO=2","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Individual truncation orders for the parameters may be specified too. The parameters part of a monomial is treated separately, truncated at the parameter order always.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Example: allowed monomials for f(x_1k_1k_2) (one variable, two parameters) with individual variable truncation order [1], individual parameter truncation orders [1,1], maximum order = 3, and different parameter orders:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Exponents Parameter Order = 1 Parameter Order = 2\n0quad  quad 1 quad 0 ✅ ✅\n0quad  quad 0 quad 1 ✅ ✅\n0quad  quad 1 quad 1 ❌ ✅\n1quad  quad 1 quad 0 ✅ ✅\n1quad  quad 0 quad 1 ✅ ✅\n1quad  quad 1 quad 1 ❌ ✅","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"(Note: many monomials are excluded for brevity in the above table)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"We can define these two GTPSA Descriptors respectively with:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"dp1 = Descriptor([1], 3, [1, 1], 1)\ndp1 = Descriptor([1], 3, [1, 1], 2)","category":"page"},{"location":"man/i_methods/#tpsmethods","page":"TPS-Specific Functions","title":"TPS-Specific Functions","text":"","category":"section"},{"location":"man/i_methods/","page":"TPS-Specific Functions","title":"TPS-Specific Functions","text":"clearord\nclearord!\nclear!\ncomplex!\ncompose!\ncutord\ncutord!\ncycle!\nderiv\nderiv!\nevaluate\nevaluate!\nfgrad\nfgrad!\ngetord\ngetord!\ninteg\ninteg!\ninv!\nnormTPS\nnumcoefs\nnumtype\nscalar\nsetTPS!\ntranslate\ntranslate!","category":"page"},{"location":"man/i_methods/#GTPSA.clearord","page":"TPS-Specific Functions","title":"GTPSA.clearord","text":"clearord(t1::TPS, order::Integer)\n\nReturns a new TPS equal to t1 but with all monomial coefficients  at the given order cleared (set equal to 0).\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.clearord!","page":"TPS-Specific Functions","title":"GTPSA.clearord!","text":"clearord!(t::TPS, order::Integer) -> t\n\nClears all monomial coefficients in t at order order.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.clear!","page":"TPS-Specific Functions","title":"GTPSA.clear!","text":"clear!(t::TPS)\n\nClears all monomial coefficients in the TPS (sets to 0).\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.complex!","page":"TPS-Specific Functions","title":"GTPSA.complex!","text":"complex!(t::ComplexTPS64; tre=nothing, tim=nothing)\n\nSets t to so that real(t)=tre and imag(t)=tim in place.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.compose!","page":"TPS-Specific Functions","title":"GTPSA.compose!","text":"compose!(m, m2, m1) -> m\n\nComposes the TPSs (or TPS maps) m2 ∘ m1, and sets m equal to the result. If  the GTPSA has more than 1 variable or parameter, then m1 must be an array with length  equal to the total number of variables and parameters.\n\nArguments\n\nm::Union{AbstractArray{TPS{T,D}},TPS{T,D}}    \nm2::Union{AbstractArray{TPS{T,D2}},TPS{T,D2}}\nm1::Union{AbstractArray{TPS{T,D1}},TPS{T,D1}}\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.cutord","page":"TPS-Specific Functions","title":"GTPSA.cutord","text":"cutord(t1::TPS, order::Integer)\n\nCuts out the monomials in t1 at the given order and above. Or, if order  is negative, will cut monomials with orders at and below abs(order).\n\nExamples\n\njulia> d = Descriptor(1, 10);\n\njulia> Δx = first(@vars(d));\n\njulia> cutord(sin(Δx), 5)\nTPS64{Descriptor(NV=1, MO=10)}:\n Coefficient                Order   Exponent\n  1.0000000000000000e+00      1      1\n -1.6666666666666666e-01      3      3\n\n\njulia> cutord(sin(Δx), -5)\nTPS64{Descriptor(NV=1, MO=10)}:\n Coefficient                Order   Exponent\n -1.9841269841269841e-04      7      7\n  2.7557319223985893e-06      9      9\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.cutord!","page":"TPS-Specific Functions","title":"GTPSA.cutord!","text":"cutord!(t::TPS{T}, t1::TPS{T}, order::Integer) where {T} -> t\n\nCuts out the monomials in t1 at the given order and above. Or, if order  is negative, will cut monomials with orders at and below abs(order). t  is set to the result. See the documentation for cutord for examples.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.cycle!","page":"TPS-Specific Functions","title":"GTPSA.cycle!","text":"cycle!(t::TPS, i, n, m_, v_)\n\nGiven a starting index i (-1 if starting at 0), will optionally fill monomial m_ (if m != C_NULL, and m_ is a DenseVector{UInt8}) with the monomial at index i  and optionally the value at v_ with the monomials coefficient (if v_ != C_NULL,  and v_ is a Ref{<:Union{Float64,ComplexF64}}), and return the next NONZERO monomial  index in the TPS. This is useful for iterating through each monomial in the TPSA.\n\nInput\n\nt  – TPS to scan\ni  – Index to start from (-1 to start at 0)\nn  – Length of monomial\nm_ – (Optional) Monomial to be filled if provided\nv_ – (Optional) Pointer to value of coefficient\n\nOutput\n\ni  – Index of next nonzero monomial in the TPSA, or -1 if reached the end\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.deriv","page":"TPS-Specific Functions","title":"GTPSA.deriv","text":"deriv(t1::TPS, monomialindex)\n∂(t1::TPS, monomialindex)\n\nDifferentiates t1 wrt the variable/parameter specified by the variable/parameter index, or  alternatively any monomial specified by indexing-by-order OR indexing-by-sparse monomial.\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(2, 5);\n\njulia> Δx = @vars(d);\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], 1)\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  1.0000000000000000e+00      0      0   0\n  3.0000000000000000e+00      1      0   1\n\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], 2)\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0\n  3.0000000000000000e+00      1      1   0\n\nExamples: Monomial Index-by-Order\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], [1,0])\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  1.0000000000000000e+00      0      0   0\n  3.0000000000000000e+00      1      0   1\n\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], [1,1])\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  3.0000000000000000e+00      0      0   0\n\nExamples: Monomial Index-by-Sparse Monomial\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], [1=>1])\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  1.0000000000000000e+00      0      0   0\n  3.0000000000000000e+00      1      0   1\n\n\njulia> deriv(Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], [2=>1])\nTPS64{Descriptor(NV=2, MO=5)}:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0\n  3.0000000000000000e+00      1      1   0\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.deriv!","page":"TPS-Specific Functions","title":"GTPSA.deriv!","text":"deriv!(t::TPS{T}, t1::TPS{T}, monomialindex) where {T} -> t \n∂!(t::TPS{T}, t1::TPS{T}, monomialindex)     where {T} -> t\n\nDifferentiates t1 wrt the variable/parameter specified by the variable/parameter index, or  alternatively any monomial specified by indexing-by-order OR indexing-by-sparse monomial, and  sets t equal to the result in-place. See the deriv documentation for examples.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.evaluate","page":"TPS-Specific Functions","title":"GTPSA.evaluate","text":"evaluate(m, x)\n\nEvaluates the TPS function m at the result x.\n\nArguments\n\nm::Union{TPS,AbstractArray{TPS{T,D}}}    – TPS or TPS map to evaluate\nx::Union{Number,AbstractArray{<:Number}} – Value(s) of the variable(s) to evaluate m at\n\nEvaluate can also be called by \"calling\" m, e.g. m(x), m([x[1], x[2], ...]), or  m(x[1], x[2], ...) is also allowed.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.evaluate!","page":"TPS-Specific Functions","title":"GTPSA.evaluate!","text":"evaluate!(y, m, x) -> y\n\nEvaluates the TPS function m at the point x and mutates y to contain the result.\n\nArguments\n\ny::Union{Ref{T},AbstractArray{T}}          – Container to store result of evaluating m at x\nm::Union{TPS{T,D},AbstractArray{TPS{T,D}}} – TPS or TPS map to evaluate\nx::Union{Ref{T},AbstractArray{T}}          – Value(s) of the variables to evaluate m at\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.fgrad","page":"TPS-Specific Functions","title":"GTPSA.fgrad","text":"fgrad(F::AbstractArray{TPS{T,D}}, h::TPS) where {T,D}\n\nCalculates F⋅∇h.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.fgrad!","page":"TPS-Specific Functions","title":"GTPSA.fgrad!","text":"fgrad!(g::TPS{T}, F::AbstractArray{TPS{T,D}}, h::TPS{T}) where {T,D} -> g\n\nCalculates F⋅∇h and sets g equal to the result.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.getord","page":"TPS-Specific Functions","title":"GTPSA.getord","text":"getord(t1::TPS, order::Integer)\n\nExtracts one homogenous polynomial from t1 of the given order.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.getord!","page":"TPS-Specific Functions","title":"GTPSA.getord!","text":"getord!(t::TPS{T}, t1::TPS{T}, order::Integer) where {T} -> t\n\nExtracts one homogenous polynomial from t1 of the given order and  sets t to the result in-place.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.integ","page":"TPS-Specific Functions","title":"GTPSA.integ","text":"integ(t1::TPS, var::Integer=1)\n∫(t1::TPS, var::Integer=1)\n\nIntegrates t1 wrt the variable var. Integration wrt  parameters is not allowed, and integration wrt higher order  monomials is not currently supported.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.integ!","page":"TPS-Specific Functions","title":"GTPSA.integ!","text":"integ!(t::TPS{T}, t1::TPS{T}, var=1) where {T} -> t\n∫!(t::TPS{T}, t1::TPS{T}, var=1) where {T} -> t\n\nIntegrates t1 wrt the variable var and sets t equal to the result.  Integration with respect to parameters is not allowed.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.inv!","page":"TPS-Specific Functions","title":"GTPSA.inv!","text":"inv!(m, m1)\n\nInverts the TPS map m1 and sets m equal to the result. The scalar part of  m1 is ignored, so the user is responsible for ensuring the coordinate system  is correct by either translating m or translating the coordinate system.\n\nAlso see GTPSA.inv, which only acts on AbstractArray{TPS{T,D}} types.\n\nArguments\n\nm::Union{AbstractArray{TPS{T,D}},TPS{T,D}}\nm1::Union{AbstractArray{TPS{T,D1}},TPS{T,D1}}\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.normTPS","page":"TPS-Specific Functions","title":"GTPSA.normTPS","text":"normTPS(t1::TPS)\n\nCalculates the 1-norm of the TPS, which is the sum of  the abs of all coefficients.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.numcoefs","page":"TPS-Specific Functions","title":"GTPSA.numcoefs","text":"numcoefs(t::TPS)\n\nReturns the maximum number of monomials (including the scalar part) in the TPS/ComplexTPS64 given its Descriptor. \n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.numtype","page":"TPS-Specific Functions","title":"GTPSA.numtype","text":"numtype(t::Number)\nnumtype(::Type{T}) where {T<:Number}\n\nIf a TPS, then returns the type of number which the TPS  represents. Else, returns that number type.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.scalar","page":"TPS-Specific Functions","title":"GTPSA.scalar","text":"scalar(t::TPS)\n\nExtracts the scalar part of the TPS. Equivalent to t[0] but  this can be easily broadcasted.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.setTPS!","page":"TPS-Specific Functions","title":"GTPSA.setTPS!","text":"setTPS!(t::TPS, t1::Number; change::Bool=false) -> t\n\nGeneral function for setting a TPS t equal to t1. If change is true, then t and t1 can have different Descriptors (with invalid monomials removed) so  long as the number of variables + number of parameters are equal.\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.translate","page":"TPS-Specific Functions","title":"GTPSA.translate","text":"translate(m1, x) where {T1,D}\n\nTranslates the expansion point of m1 by x.\n\nArguments\n\nm1::Union{AbstractArray{TPS{T1,D}},TPS}  – TPS or TPS map to translate\nx::Union{Number,AbstractArray{<:Number}} – Amount(s) to translate the expansion point of each variable\n\n\n\n\n\n","category":"function"},{"location":"man/i_methods/#GTPSA.translate!","page":"TPS-Specific Functions","title":"GTPSA.translate!","text":"translate!(m, m1, x) -> m\n\nSets m to m1 with its expansion point translated by x.\n\nArguments\n\nm::Union{AbstractArray{TPS{T,D}},TPS{T,D}}    – Output TPS or TPS map containing m translated by x\nm1::Union{AbstractArray{TPS{T,D1}},TPS{T,D1}} – TPS or TPS map to translate by x\nx::Union{Ref{T},AbstractArray{T}}             – Amount to translate the expansion point of m1 by each variable. If the GTPSA has only 1 variable, then this may be a Ref.\n\n\n\n\n\n","category":"function"},{"location":"man/j_fastgtpsa/#fastgtpsa","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"","category":"section"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"Speed up evaluation of expressions containing TPSs, transparent to other types","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"The thread-safe macros @FastGTPSA/@FastGTPSA! can be used to speed up evaluation of expressions that may contain TPSs. Both macros are completely transparent to all other types, so they can be prepended to any existing expressions while still maintaining type-generic code. Any functions in the expression that are not overloaded by GTPSA will be ignored. Both macros do not use any -ffast-math business (so still IEEE compliant), but instead will use a thread-safe pre-allocated buffer in the Descriptor for any temporaries that may be generated during evaluation of the expression.","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"The first macro, @FastGTPSA can be prepended to an expression following assignment (=, +=, etc) to only construct one TPS (which requires two allocations), instead of a TPS for every temporary:","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"using GTPSA, BenchmarkTools\n\nd = Descriptor(3, 7);  Δx = @vars(d);\n\n@btime $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n\n@btime @FastGTPSA $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n\ny = rand(3); # transparent to non-TPS types\n\n@btime $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n\n@btime @FastGTPSA $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"The second macro, @FastGTPSA! can be prepended to the LHS of an assignment, and will fill a preallocated TPS with the result of an expression. @FastGTPSA! will calculate a TPS expression with zero allocations, and will still have no impact if a non-TPS type is used. The only requirement is that all symbols in the expression are defined:","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d); # hide\n\nt = ComplexTPS64(); # pre-allocate\n\n@btime @FastGTPSA! $t = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im; \n\ny = rand(3); @gensym z; # transparent to non-TPS types\n\n@btime @FastGTPSA! $z = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"Both @FastGTPSA and @FastGTPSA! can also be prepended to a block of code, in which case they are applied to each assignment in the block:","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d);\n\ny = rand(3);\n\n@btime @FastGTPSA begin\n        t1 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        t2 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        z  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n       end;\n\nt3 = ComplexTPS64(); t4 = ComplexTPS64(); @gensym w;\n\n@btime @FastGTPSA! begin\n        $t3 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        $t4 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        $w  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n       end;\n","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"@FastGTPSA and @FastGTPSA! are also compatible with broadcasted, vectorized operators. This can be very useful for example if a structure-of-arrays (SoA) layout is used in a simulation program, but you would like to calculate a Taylor map of the output by propagating GTPSAs through. Note that for @FastGTPSA, which allocates the result, that there are two allocations per TPS and one for the Array. For @FastGTPSA!, which requires a pre-allocated output, there are zero allocations. Both are still transparent to non-TPS types for universally polymorphic use without cost.","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d); # hide\ny = rand(3); # hide\n@btime @FastGTPSA begin\n        out = @. $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;\n       end;\nout = zeros(ComplexTPS64, 3); # pre-allocate\n@btime @FastGTPSA! begin\n        @. $out = $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;\n       end;","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"If errors are thrown during usage of @FastGTPSA/@FastGTPSA!, temporaries in use may not have been properly popped from the stack. Therefore, if the Julia session is not terminated, the helper functions GTPSA.checktemps and `GTPSA.cleartemps! should be used to evaluate and correct the state of the buffer.","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"Without using the macro, each time an operation is performed using a TPS, a new TPS is dynamically-allocated containing the result. For example in the above expression, the calculation of sin(Δx[2]) creates a new TPS, and the calculation of Δx[1]^3 also creates a new TPS. The multiplication of these two resulting TPSs creates a new TPS, and so on until a TPS containing the full result of the evaluated expression is obtained. The intermediate TPSs that must be created to evaluate the expression are referred to as temporaries, because they only exist temporarily. Julia's garbage collector notices when the dynamically-allocated temporaries are no longer in scope, and cleans up that memory when it decides it's a good time to. This process can cause slowdowns in performance critical code however, especially in more complicated expressions where a lot of temporaries are created.","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"Both @FastGTPSA and @FastGTPSA! basically tell the code to instead use a permanent, pre-allocated thread-safe buffer of TPSs for the temporaries during evaluation of the expression, so there is no dynamic memory allocation; for @FastGTPSA, the number of allocations is reduced to two (which is one single TPS), and for @FastGTPSA! the number of allocations is zero. Furthermore, these temporaries are accessed and deleted in a stack-like manner from the buffer by each thread, so that temporaries involved in operations are right next to each other in memory. This ensures minimal cache misses throughout the evaluation of the expression.","category":"page"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"The speedup of using the macro can be quite significant. See our example, where we observe a x2 speedup at 2nd order. ","category":"page"},{"location":"man/j_fastgtpsa/#Note-on-Julia-Versions-v1.10","page":"@FastGTPSA/@FastGTPSA! Macros","title":"Note on Julia Versions < v1.10","text":"","category":"section"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"In order to support vectorized/broadcasted operations using @FastGTPSA! with zero allocations, setindex! was overloaded for Array{<:TPS} types. This can lead to massive speedups in calculating Taylor maps in simulations using a structure-of-arrays layout of memory. However, it turns out that on Julia versions < v1.10, merely overloading this function causes allocations when using the macro. It currently is not understood why (possibly a bug in older Julia versions), however we therefore strongly recommend using Julia version >= v1.10 with this package. If you are stuck with Julia v1.9, then you can use GTPSA v1.1.1, which is the latest version that does not have this particular overload. With this, you cannot do broadcasted operators using the macros, but you will have zero allocations for non-vector TPS operations.","category":"page"},{"location":"man/j_fastgtpsa/#Documentation","page":"@FastGTPSA/@FastGTPSA! Macros","title":"Documentation","text":"","category":"section"},{"location":"man/j_fastgtpsa/","page":"@FastGTPSA/@FastGTPSA! Macros","title":"@FastGTPSA/@FastGTPSA! Macros","text":"@FastGTPSA\n@FastGTPSA!\nGTPSA.cleartemps!\nGTPSA.checktemps","category":"page"},{"location":"man/j_fastgtpsa/#GTPSA.@FastGTPSA","page":"@FastGTPSA/@FastGTPSA! Macros","title":"GTPSA.@FastGTPSA","text":"@FastGTPSA(expr_or_block)\n\nMacro to speed up evaluation of mathematical expressions containing TPSs. The temporaries generated during evaluation of the expression are drawn  from a thread-safe buffer, reducing the number of heap allocations to  2 (which is for a single TPS) for the result. @FastGTPSA is completely  transparent to all other types, so it can be prepended to expressions  while still maintaining type-generic code.\n\njulia> using GTPSA, BenchmarkTools\n\njulia> d = Descriptor(3,7); Δx = @vars(d);\n\njulia> t = @btime $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n  3.458 μs (20 allocations: 11.88 KiB)\n\njulia> t = @btime @FastGTPSA $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n  3.172 μs (2 allocations: 1.94 KiB)\n\n@FastGTPSA can also be prepended to a block of code, in which case it  is applied after every = sign in the block: \n\njulia> @btime @FastGTPSA begin\n       t1 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n       t2 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n       a = t1+t2\n       L = 5+3*exp(7)\n       end\n  6.317 μs (6 allocations: 5.81 KiB)\n\nBroadcasting is also compatible with @FastGTPSA (note two allocations  per TPS and one allocation per Array):\n\njulia> using GTPSA, BenchmarkTools\n\njulia> d = Descriptor(3, 7); Δx = @vars(d); y = rand(3);\n\njulia> @btime @FastGTPSA begin\n        out = @. $Δx^3*sin($y)/log(2+$x)-exp($x*$y)*im;\n       end;\n  7.573 μs (7 allocations: 5.89 KiB)\n\n\n\n\n\n","category":"macro"},{"location":"man/j_fastgtpsa/#GTPSA.@FastGTPSA!","page":"@FastGTPSA/@FastGTPSA! Macros","title":"GTPSA.@FastGTPSA!","text":"@FastGTPSA!(expr_or_block)\n\nMacro to speed up evaluation of mathematical expressions that may contain assignment to pre-allocated TPSs. The temporaries generated during  evaluation of the expression are drawn from a thread-safe buffer. With this  macro, the number of heap allocations during evaluation of expressions  containing TPSs is 0, and it is fully transparent to non-TPS types.\n\nThis macro supports assignment using =, +=, -=, *=, /=, and ^=.\n\nImportant: The symbols must be defined prior to calling the macro  regardless of whether or not the type is a TPS:\n\njulia> using GTPSA, BenchmarkTools\n\njulia> d = Descriptor(3,7); Δx = @vars(d); \n\njulia> t = ComplexTPS64(); # Pre-allocate\n\njulia> @btime @FastGTPSA! $t = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n  2.972 μs (0 allocations: 0 bytes)\n\njulia> @btime @FastGTPSA! $t ^= $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n  6.550 μs (0 allocations: 0 bytes)\n\njulia> y = rand(3); z = 2; # transparent to non-TPS types \n\njulia>  @btime @FastGTPSA! $z = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n  11.344 ns (0 allocations: 0 bytes)\n\nLike @FastGTPSA, @FastGTPSA! can prepended to a block of code, in  which case it is applied before every line in the block containing assignment:\n\njulia> t1 = zero(ComplexTPS64); t2 = zero(ComplexTPS64); z = 0; \n\njulia> @btime @FastGTPSA! begin\n       $t1 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n       $t2 -= $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n       $z += 7\n       end\n  5.965 μs (0 allocations: 0 bytes)\n\nBroadcasting is also compatible with @FastGTPSA!:\n\njulia> using GTPSA, BenchmarkTools\n\njulia> d = Descriptor(3, 7); Δx = @vars(d); y = rand(3);\n\njulia> out = zeros(ComplexTPS64, 3) # pre-allocate\n\njulia> @btime @FastGTPSA! begin\n        @. $out = $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;\n       end;\n  7.312 μs (0 allocations: 0 bytes)\n\n\n\n\n\n","category":"macro"},{"location":"man/j_fastgtpsa/#GTPSA.cleartemps!","page":"@FastGTPSA/@FastGTPSA! Macros","title":"GTPSA.cleartemps!","text":"GTPSA.cleartemps!(d::Descriptor=GTPSA.desc_current)\n\nClears the \"stack\" of temporaries currently in use by the Descriptor. This is  necessary to run if GTPSA.checktemps(d::Descriptor=GTPSA.desc_current) returns  false; this occurs if an error is thrown during evaluation of an expression  using @FastGTPSA or @FastGTPSA!, and the Julia session is not terminated.\n\n\n\n\n\n","category":"function"},{"location":"man/j_fastgtpsa/#GTPSA.checktemps","page":"@FastGTPSA/@FastGTPSA! Macros","title":"GTPSA.checktemps","text":"GTPSA.checktemps(d::Descriptor=GTPSA.desc_current)\n\nSanity check of the temporary buffer in the Descriptor used by @FastGTPSA.  Returns true if everything is OK, else false in which case  GTPSA.cleartemps!(d::Descriptor=GTPSA.desc_current) should be run. This may  occur if an error is thrown during evaluation of an expression using @FastGTPSA  or @FastGTPSA!.\n\n\n\n\n\n","category":"function"},{"location":"man/b_descriptor/#descriptor","page":"Descriptor","title":"Descriptor","text":"","category":"section"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"Defines the number of variables, number of parameters, and order(s) for each in the GTPSA","category":"page"},{"location":"man/b_descriptor/#Syntax","page":"Descriptor","title":"Syntax","text":"","category":"section"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order)     \nd = Descriptor(vars_orders, max_order)\nd = Descriptor(num_vars, max_order, num_params, param_order)   \nd = Descriptor(vars_orders, max_order, params_orders, param_order)\n\nGTPSA.desc_current = d # Used in dynamic Descriptor resolution","category":"page"},{"location":"man/b_descriptor/#Description","page":"Descriptor","title":"Description","text":"","category":"section"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order) defines a GTPSA Descriptor with num_vars variables and a maximum truncation order max_order","category":"page"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(vars_orders, max_order) defines a GTPSA Descriptor with length(var_orders) variables each having individual truncation orders specified in the var_orders vector, and a maximum truncation order max_order for the entire monomial","category":"page"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order, num_params, param_order) defines a GTPSA Descriptor with num_vars variables and num_params parameters. The parameters part of a monomial is truncated at param_order, and the entire monomial is truncated at max_order (so param_order <= max_order)","category":"page"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(vars_orders, max_order, params_orders, param_order) defines a GTPSA Descriptor with length(var_orders) variables each having individual truncation orders specified in the vars_orders vector, and length(param_orders) parameters each having individual truncation orders specified in the params_orders vector. The parameters part of the monomial is truncated at param_order,  and the entire monomial is truncated at max_order (so param_order <= max_order)","category":"page"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"","category":"page"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"GTPSA.desc_current is a global variable that is set each time a user creates a new Descriptor, and can also be set manually by a user. GTPSA.desc_current defines the Descriptor to use when dynamic Descriptor resolution is used and a Descriptor cannot be inferred, e.g. when calling TPS(a) where a is not a TPS. ","category":"page"},{"location":"man/b_descriptor/#Examples","page":"Descriptor","title":"Examples","text":"","category":"section"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"using GTPSA #hide\nd1 = Descriptor(2, 10)         \nd2 = Descriptor([1, 2, 3], 5)     \nd3 = Descriptor(3, 4, 1, 2)    \nd4 = Descriptor([6, 5], 8, [4, 3], 7)   \nGTPSA.desc_current = d1","category":"page"},{"location":"man/b_descriptor/#Documentation","page":"Descriptor","title":"Documentation","text":"","category":"section"},{"location":"man/b_descriptor/","page":"Descriptor","title":"Descriptor","text":"Descriptor","category":"page"},{"location":"man/b_descriptor/#GTPSA.Descriptor","page":"Descriptor","title":"GTPSA.Descriptor","text":"Descriptor(nv::Integer, mo::Integer)::Descriptor\n\nCreates a TPSA Descriptor with nv variables, and a maximum truncation order mo.\n\nInput\n\nnv – Number of variables in the TPSA\nmo – Maximum truncation order of the TPSA\n\n\n\n\n\nDescriptor(vos::Vector{<:Integer}, mo::Integer)::Descriptor\n\nCreates a TPSA Descriptor with length(vos) variables with individual truncation  orders specified in the Vector vos, and a maximum truncation order mo for the TPSA.\n\nInput\n\nvos – Vector of the individual truncation orders of each variable\nmo  – Maximum truncation order of the TPSA, <= sum(vos)\n\n\n\n\n\nDescriptor(nv::Integer, mo::Integer, np::Integer, po::Integer)::Descriptor\n\nCreates a TPSA Descriptor with nv variables and np parameters. The maximum  truncation order is mo (including the parameters), and the truncation order for  the parameters part of a monomial is po.\n\nInput\n\nnv – Number of variables in the TPSA\nmo – Maximum truncation order of the TPSA including variables and parameters\nnp – Number of parameters in the TPSA\npo – Truncation order of the parameters part of a monomial\n\n\n\n\n\nDescriptor(vos::Vector{<:Integer}, mo::Integer, pos::Vector{<:Integer}, po::Integer)::Descriptor\n\nCreates a TPSA Descriptor with length(vos) variables with individual truncation  orders specified in vos, and length(pos) parameters with individual truncation  orders specified in pos. The maximum truncation order including both variables and  parameters is mo, and the truncation order for just the parameters part of the is po.\n\nInput\n\nvos – Vector of the individual truncation orders of each variable\nmo  – Maximum truncation order of the TPSA including variables and parameters\npos – Vector of the individual truncation orders of each parameter\npo – Truncation order of the parameters part of a monomial\n\n\n\n\n\n","category":"type"},{"location":"man/l_global/#global","page":"Global Variables","title":"Global Variables","text":"","category":"section"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"The following non-constant global variables can be set:","category":"page"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"desc_current::Descriptor     # Descriptor to use when dynamic Descriptor resolution cannot infer\nshow_eps::Float64 =  0.0     # Print epsilon\nshow_sparse::Bool = false    # Use sparse monomial print","category":"page"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"desc_current defines the Descriptor to use when that information is not explicitly (or implicitly in a TPS copy constructor) available with dynamic Descriptor resolution, e.g. when calling TPS(a) where a is not a TPS","category":"page"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"show_eps defines the value below which the absolute value of a monomial coefficient is NOT printed","category":"page"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"show_sparse specifies whether the sparse monomial format is used for printing. This is useful for GTPSAs containing a large number of variables and parameters","category":"page"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"","category":"page"},{"location":"man/l_global/#Examples","page":"Global Variables","title":"Examples","text":"","category":"section"},{"location":"man/l_global/","page":"Global Variables","title":"Global Variables","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nGTPSA.desc_current\nd1 = Descriptor(1, 6);\nGTPSA.desc_current\nx = @vars()\nGTPSA.show_sparse = true;\nx\nGTPSA.show_sparse = false;\nGTPSA.show_sparse\nx","category":"page"},{"location":"man/m_all/#all","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"","category":"section"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"The following functions from Base have been overloaded for operations with TPS:","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"+, -, *, /, ^, ∘, inv, atan, hypot, abs, sqrt, exp, log, sin, cos, \ntan, csc, sec, cot, sinc, sinh, cosh, tanh, csch, sech, coth, asin, \nacos, atan, acsc, asec, acot, asinh, acosh, atanh, acsch, asech, \nacoth, zero, zeros, one, ones, real, imag, conj, angle, complex, \npromote_rule, getindex, setindex!, ==, <, >, <=, >=, !=, isequal, \nisless, isinf, isnan, show, copy, copy!, lastindex, firstindex, \nrand, unsafe_convert, eps, floatmin, floatmax, signbit","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"zeros and ones are overloaded from Base so that allocated TPSs are placed in each element. Because of the mutability of TPS, if we didn't explicity overload these functions every element would correspond to the exact same heap-allocated TPS.","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"GTPSA.jl overloads (and exports) the following functions from the corresponding packages:  LinearAlgebra: norm SpecialFunctions: erf, erfc, erfcx, erfi","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"GTPSA.jl also provides the following math functions NOT included in Base or any of the above packages (and not already documented in TPS-Specific Functions):","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"unit, sincu, sinhc, sinhcu, asinc, asincu, asinhc, asinhcu, wf, polar, rect","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"If there is a mathematical function in Base which you'd like and is not included in the above list, feel free to submit an issue.","category":"page"},{"location":"man/m_all/#Mutable-Mathematics-Interface","page":"All Overloaded Functions","title":"Mutable Mathematics Interface","text":"","category":"section"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"For every math function, GTPSA.jl provides mutating functions to set an allocated TPS in-place. For non-arithmetic operators, this is denoted with a bang (!) symbol. E.g. for sin(a), there also exists GTPSA.sin!(b, a) where b is set equal to sin(a). Aliasing (b === a) for all operators is allowed in GTPSA.","category":"page"},{"location":"man/m_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"For the arithmetic operators +, -, *, /, ^, there are the corresponding in-place functions GTPSA.add!(c, a, b), GTPSA.sub!(c, a, b), GTPSA.mul!(c, a, b), GTPSA.div!(c, a, b), and GTPSA.pow!(c, a, b). While c must be an allocated TPS, a and b could be a TPS or any Number type, so long as they can be appropriately converted to the destination TPS parametric number type. Aliasing for all arithmetic operators (a === b === c) is allowed in GTPSA.","category":"page"},{"location":"quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"quickstart/#Defining-the-GTPSA","page":"Quickstart Guide","title":"Defining the GTPSA","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We first must define a Descriptor which includes all information about a GTPSA, including the number of variables and truncation order. The constructors for a Descriptor including only variables are:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA #hide\n# 2 variables with max truncation order 10\nd1 = Descriptor(2, 10)     ","category":"page"},{"location":"quickstart/#Calculating-a-Truncated-Power-Series","page":"Quickstart Guide","title":"Calculating a Truncated Power Series","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"GTPSA.jl centers around the TPS (truncated power series) type, which represents a multivariable Taylor series truncated at the chosen order in the Descriptor. Using Einstein notation for the variable indices, and letting n specify the order up to a maximum truncation order MO, we can express a function f expanded around veca as a TPS:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"f(vecx) = f(veca) + sum_n=1^MO leftfracpartial fpartial x_i_1 partial x_i_2ldots partial x_i_nrightrvert_veca Delta x_i_1 Delta x_i_2 ldotsDelta x_i_n","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The TPS type stores all of the monomial coefficients in this Taylor series up to the chosen order (e.g. f(veca), partial f partial x_i _veca, etc.). You can manipulate and propagate a TPS through some functions like any other number type, and the result will be a TPS containing the Taylor expansion representing all preceding operations. If you have some familiarity with automatic differentiation, then you can view a TPS as basically a Dual number which has been highly optimized for high order automatic differentiation with high numbers of variables/parameters.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"In the context of GTPSA.jl, we refer to \"variables\" as each Delta x_i in the TPS. The reason for this is that one can always choose a coordinate system where veca=vec0, and such a choice greatly simplifies the terminology and analysis. This brings up an important point: the TPS type itself does NOT explicitly store any expansion point. It just stores the monomial coefficients of each term in the Taylor series, truncated at the chosen order of the (tiny) variables. The setup of the problem, done by you our dear user, will decide the expansion point. In the parlance of Dual numbers, the quantity Delta x_i is equivalent to 0+1epsilon_i.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Let's dive into some examples, which will make these above points clearer. After defining the Descriptor, we can obtain the variables, which themselves are represented as TPSs (with each variable's first order monomial coefficient set to 1) using @vars:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false;#hide\nd6 = Descriptor(2, 6); # 2 variables to 6th order\n\n# Returns a Vector of each variable as a TPS\nΔx = @vars(d6) ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The result is a TPS vector function beginbmatrix Delta x_1  Delta x_2 endbmatrix corresponding directly to each variable. TPS64 is an alias for TPS{Float64}, which are TPSs that represent 64-bit floats. Likewise, ComplexTPS64 is an alias for TPS{ComplexF64}. Currently, GTPSA only supports TPSs which represent Float64 and ComplexF64 numbers. ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Now let's use this to compute the Maclaurin series of the function f(vecx) = cos(x_1) + textrmisin(x_2):","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"f(x) = cos(x[1]) + im*sin(x[2]); # Define the function\n\nf(Δx) # Maclaurin series","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Another way to view \"variables\" in the context of GTPSA.jl are as tiny \"wiggles\". Specifically, if you wiggle the input, how does the output depend on those input wiggles?. The vector of variables Δx are thus just unit wiggles.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"To instead compute the Taylor series of f expanded around (-pi2pi2), we simply \"wiggle\" around (-pi2pi2):","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"x0 = [-pi/2, pi/2];\n\nft = f(x0 + Δx)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"ft is a TPS containing the expansion of f around (-pi2pi2) up to 6th order, with the variables specifying deviations from (-pi2pi2). Note how some of the monomial coefficients are small but nonzero due to floating point roundoff error. To hide the display of small monomial coefficients below a certain absolute value, we can set the global variable GTPSA.show_eps:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"GTPSA.show_eps = 1e-15\nprintln(ft)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"note: Note\nSetting GTPSA.show_eps does not actually reset any monomial coefficients in the TPSs equal to zero, rather just suppresses their output when showing any TPS.","category":"page"},{"location":"quickstart/#TPS-Evaluation,-Composition,-Translation,-and-Inversion","page":"Quickstart Guide","title":"TPS Evaluation, Composition, Translation, and Inversion","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We can evaluate TPSs just like any other function. Continuing with our example above, let's evaluate ft, which is an expansion around (-pi2pi2) at, say, (Delta x_1Delta x_2)=(pi-pi), and see how well it agrees with the exact calculation using f:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"abs(ft([-pi, pi]) - f(x0 + [-pi, pi]))","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The disagreement is quite large! This is due to the truncation error of the TPS. If we increase the maximum order of the GTPSA, we can obtain a better approximation of the function f for such large variables. Let's test that now, setting the truncation order to 20 for both variables:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"d20 = Descriptor(2, 20); # two variables to 20th order\nΔx = @vars(d20);\nft = f(x0 + Δx);\nabs(ft([-pi, pi]) - f(x0 + [-pi, pi]))","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"ft now approximates f much better for such large variables!","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"We also can compose TPSs. For this example, let's define a new GTPSA with only 1 variable to 1st order, and define the functions f(x) = x^2+2x and g(x)=3+4x:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false;#hide\nd = Descriptor(1, 1);\nΔx = first(@vars(d));\nf(x) = x^2 + 2*x;\ng(x) = 3 + 4*x;","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Of course, we can compute a TPS representing the expansion of fcirc g around x=0 by:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"fg_exact = f(g(Δx))","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"However, we can also separately compute TPSs for f and g around x=0, and then compose them:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"ft = f(Δx);\ngt = g(Δx);\nfg_composed = ft ∘ gt # Or equivalently ft(gt)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Wait a minute, what happened here? fg_composed certainly is not equal to fg_exact.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This example presents the important concept of TPS feed-down error. The explanation is simple; for fg_composed, we separately obtained TPSs expanded around x=0, and then tried to compose them. However, after passing through g, a nonzero 0th order term (also called the scalar part of the TPS) was picked up. Thus, we should have expanded f around the scalar part of gt, instead of x=0. Then, to keep the same coordinates as initially inputted into gt, we'll also need to translate this TPS expansion point back to the original expansion point:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# First find the expansion of `f` around the 0th order (scalar part) of `g`\nft1 = f(scalar(gt) + Δx); # We can use `scalar` to get the scalar part of a `TPS`\n\n# Then `translate` the expansion point back to the original expansion point\nft = translate(ft1, -scalar(gt));\n\nfg_composed = ft ∘ gt","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The two now fully agree. ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"This example shows the care that must be taken when composing two separate truncated power series. Another, perhaps simpler, way of dealing with this problem is to always chose a coordinate system such that the scalar part of a TPS is equal to zero.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"GTPSA also includes a routine to invert a TPS map. The inversion routine ignores any scalar part of the TPS, so it is the responsibility of the user to ensure the coordinate system is consistent by either translating the TPSs or using a coordinate system where the scalar part is zero. ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"As an example, let's invert the following TPS map, which has no scalar part:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false;#hide\nd = Descriptor(2, 2);\nΔx = @vars(d);\nM = [  Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2], \n     3*Δx[1] + 4*Δx[2] + Δx[1]^2 + Δx[2]^2]\nM_inv = inv(M)\n\nM_inv ∘ M ","category":"page"},{"location":"quickstart/#Other-TPS-Constructors","page":"Quickstart Guide","title":"Other TPS Constructors","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"After defining a Descriptor, we can construct a TPS using any of the following:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false; # hide\nd = Descriptor(3, 5); # 3 variables to 5th order\nt = TPS64{d}() # Constructs a blank `TPS`, equivalent to `TPS{Float64,d}()`\nt1 = TPS64{d}(1.0) # Constructs a `TPS` with scalar part set to 1.0\nt1c = ComplexTPS64{d}(1.0) # Equivalent to `TPS{ComplexF64,d}(1.0)`\nt1im = TPS{d}(1.0im) # If the number type is not specified, then it is inferred","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"When constructing TPSs in this manner, it is important to include the Descriptor in the type parameter of the constructor, to ensure the Descriptor of the TPS is resolved statically (at compile time). If it is not included, then the Descriptor of the TPS will be resolved dynamically instead, at runtime. GTPSA.jl provides both static and dynamic Descriptor resolution modes, each of which have certain advantages in different use cases. See the advanced topics section of the documentation for more details.","category":"page"},{"location":"quickstart/#Partial-Derivative-Getting/Setting","page":"Quickstart Guide","title":"Partial Derivative Getting/Setting","text":"","category":"section"},{"location":"quickstart/#Individual-Monomial-Coefficient","page":"Quickstart Guide","title":"Individual Monomial Coefficient","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"note: Note\nThe value of a partial derivative is equal to the monomial coefficient in the Taylor series multiplied by a constant factor. E.g. for an expansion around zero f(x)approx f(0) + fracpartial fpartial xrvert_0x + frac12fracpartial^2 fpartial x^2rvert_0 x^2 + , the 2nd order monomial coefficient is frac12fracpartial^2 fpartial x^2rvert_0. ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Individual monomial coefficients in a TPS t can be get/set with three methods of indexing:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"By Monomial Index: t[idx::Integer]. Indexes the TPS with all monomials sorted by order. For example, for a TPS with two variables Δx_1 and Δx_2, the Δx_1 monomial is indexed with t[1] and the Δx_1^2 monomial is indexed with t[3]. The zeroth order part, or the scalar part of the TPS, can be indexed with t[0].\nBy Order: t[[<Δx_1 order>, ..., <Δx_NV order>]]. For example, for a TPS with three variables Δx_1, Δx_2, and Δx_3, the Δx_1^3Δx_2^1 monomial coefficient is accessed with t[[3,1,0]] or equivalently t[[3,1]], as leaving out trailing zeros for unincluded variables is allowed. A tuple is also allowed instead of a vector for the list of orders.\nBy Sparse Monomial: t[[<ix_var> => <order>, ...]]. This method of indexing is convenient when a TPS contains many variables and parameters. For example, for a TPS with variables Δx_1Δx_2Δx_100, the Δx_1^3Δx_99^1 monomial coefficient is accessed with t[[1=>3, 99=>1]]. A tuple is also allowed instead of a vector for the list of pairs.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"These three methods of indexing are best shown with an example:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse = false; #hide\n# Example of indexing by monomial index -----------\nd = Descriptor(3, 10);\nt = TPS{d}(); # or equivalently TPS{Float64,d}()\n\nt[0] = 0;\nt[1] = 1;\nt[2] = 2;\nt[3] = 3;\nt[4] = 4;\nt[5] = 5; \nt[6] = 6;\nt[7] = 7;\nt[8] = 8;\nt[9] = 9;\nt[10] = 10;\n\nt","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false;#hide\n# Example of indexing by order -----------\nd = Descriptor(3, 10);\nt = TPS{d}();\n\nt[[0]] = 1;\nt[[1]] = 2;\nt[[0,1]] = 3;\nt[(0,0,1)] = 4;  # Tuples also allowed\nt[(2,1,3)] = 5;\n\nt","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false; #hide\n# Example of indexing by sparse monomial -----------\nd = Descriptor(3, 10);\nt = TPS{d}();\n\nt[[1=>1]] = 2;\nt[[2=>1]] = 3;\nt[[3=>1]] = 4;\nt[(1=>2,2=>1,3=>3)] = 5;  # Tuples also allowed\n\nt","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The GTPSA.cycle! function can also be used to cycle through all nonzero monomials in a TPS.","category":"page"},{"location":"quickstart/#Gradients,-Jacobians,-Hessians","page":"Quickstart Guide","title":"Gradients, Jacobians, Hessians","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The convenience getters gradient, jacobian, and hessian (as well as their corresponding in-place methods gradient!, jacobian!, and hessian!) are also provided for extracting partial derivatives from a TPS/array of TPSs. Note that these functions are not actually calculating anything - at this point the TPS should already have been propagated through, and these functions are just extracting the corresponding partial derivatives.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false; #hide\n# 2nd Order TPSA with 100 variables\nd = Descriptor(100, 2);\nΔx = @vars(d);\n\nout = cumsum(Δx);\n\n# Convenience getters for partial derivative extracting:\ngrad1 = GTPSA.gradient(out[1]);\nJ = GTPSA.jacobian(out);\nh1 = GTPSA.hessian(out[1]);\n\n# Also in-place getters\nGTPSA.gradient!(grad1, out[1]);\nGTPSA.jacobian!(J, out);\nGTPSA.hessian!(h1, out[1]);","category":"page"},{"location":"quickstart/#Slicing-a-TPS","page":"Quickstart Guide","title":"Slicing a TPS","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Parts of a TPS with certain variable orders can be extracted by slicing the TPS. When indexing by order, a colon (:) can be used in place for a variable order to include all orders of that variable. If the last specified index is a colon, then the rest of the variable indices are assumed to be colons:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse=false; #hide\nd = Descriptor(5, 10);\nΔx = @vars(d);\n\nf = 2*Δx[1]^2*Δx[3] + 3*Δx[1]^2*Δx[2]*Δx[3]*Δx[4]^2*Δx[5] + 6*Δx[3] + 5;\ng = f[[2,:,1]];\nh = f[[2,:,1,:]];\n\nprint(f)\nprint(g)\nprint(h)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"A TPS can also be sliced with indexing by sparse monomial. In this case, if a colon is included anywhere in the sparse monomial index, then all orders of all variables not explicity specified will be included:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":" # Colon position does not matter in sparse-monomial indexing\ng = f[[1=>2, :, 3=>1, 4=>0, 5=>0]];\nh = f[[1=>2, 3=>1, :]];\n\nprint(g)\nprint(h)","category":"page"},{"location":"quickstart/#@FastGTPSA/@FastGTPSA!-Macros","page":"Quickstart Guide","title":"@FastGTPSA/@FastGTPSA! Macros","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The macros @FastGTPSA/@FastGTPSA! can be used to speed up evaluation of expressions that may contain TPSs. Both macros are completely transparent to all other types, so they can be prepended to any existing expressions while still maintaining type-generic code. Any functions in the expression that are not overloaded by GTPSA will be ignored. Both macros do NOT use any -ffast-math business (so still IEEE compliant), but instead will use a thread-safe pre-allocated buffer in the Descriptor for any temporaries that may be generated during evaluation of the expression.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The first macro, @FastGTPSA can be prepended to an expression following assignment (=, +=, etc) to only construct one TPS (which requires two allocations), instead of a TPS for every temporary:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA, BenchmarkTools\n\nd = Descriptor(3, 7);  Δx = @vars(d);\n\n@btime $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n\n@btime @FastGTPSA $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n\ny = rand(3); # transparent to non-TPS types\n\n@btime $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n\n@btime @FastGTPSA $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The second macro, @FastGTPSA! can be prepended to the left-hand side of an assignment, and will fill a preallocated TPS with the result of an expression. @FastGTPSA! will calculate a TPS expression with zero allocations, and will still have no impact if a non-TPS type (even if immutable) is used. The only requirement is that all symbols in the expression are defined:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d); # hide\n\nt = ComplexTPS64(); # pre-allocate\n\n@btime @FastGTPSA! $t = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im; \n\ny = rand(3); @gensym z; # transparent to non-TPS types\n\n@btime @FastGTPSA! $z = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Both @FastGTPSA and @FastGTPSA! can also be prepended to a block of code, in which case they are applied to each assignment in the block:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d);\n\ny = rand(3);\n\n@btime @FastGTPSA begin\n        t1 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        t2 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        z  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n       end;\n\nt3 = ComplexTPS64(); t4 = ComplexTPS64(); @gensym w;\n\n@btime @FastGTPSA! begin\n        $t3 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        $t4 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;\n        $w  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;\n       end;\n","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Both macros are also compatible with broadcasted, vectorized operators:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA, BenchmarkTools # hide\nd = Descriptor(3, 7); Δx = @vars(d); y = rand(3);\n@btime @FastGTPSA begin\n        out = @. $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;\n       end;\nout = zeros(ComplexTPS64, 3); # pre-allocate\n@btime @FastGTPSA! begin\n        @. $out = $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;\n       end;","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The advantages of using the macros become especially apparent in more complicated systems. See our example where we observed a significant speedup.","category":"page"},{"location":"quickstart/#Automatic-Differentiation-using-GTPSA.jl","page":"Quickstart Guide","title":"Automatic Differentiation using GTPSA.jl","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"At the time of writing this documentation, a pull request is ready for merge with Julia's DifferentiationInterface.jl package, which provides a generic interface for computing pushforwards (Jacobian vector products), derivatives, gradients, Jacobians, Hessians, and Hessian vector products using any automatic differentiation (AD) backend. If you are only interested in using GTPSA for these computations, then we strongly recommend using DifferentiationInterface.jl with the AutoGTPSA AD type.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"note: Note\nGTPSA has been highly optimized for high order AD with large numbers of variables and parameters. If you are only interested in first order AD, then other AD backends will likely be faster. GTPSA, however, may likely be faster in cases where the entire Hessian must be materialized.","category":"page"},{"location":"quickstart/#Compatibility-with-DifferentialEquations.jl","page":"Quickstart Guide","title":"Compatibility with DifferentialEquations.jl","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"GTPSA.jl bindings have been added to DiffEqBase.jl so that TPSs can be integrated using any of the solvers provided by SciML's extensive Differential Equations ecosystem. Simply specify your initial conditions as TPS types. This allows, for example, for computation of high-order Hamiltonian maps that can then be analyzed using canonical perturbation theory.","category":"page"},{"location":"man/h_slice/#slice","page":"Slicing and par","title":"Slicing and par","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"Indexing a specific polynomial within the TPS","category":"page"},{"location":"man/h_slice/#Slicing-a-TPS","page":"Slicing and par","title":"Slicing a TPS","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"A polynomial within the TPS with certain variable orders can be extracted by slicing the TPS. When indexing by order, a colon (:) can be used in place for a variable order to include all orders of that variable. If the last specified index is a colon, then the rest of the variable indices are assumed to be colons (else, they are assumed to be zero, following the convention of monomial coefficient indexing).","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header = false; #hide\nd = Descriptor(5, 10, 2, 10);\nΔx = @vars(d);\nΔk = @params(d);\nf = 2*Δx[1]^2*Δx[3] + 3*Δx[1]^2*Δx[2]*Δx[3]*Δx[4]^2*Δx[5]*Δk[1] + 6*Δx[3] + 5\ng = f[[2,:,1]]\nh = f[[2,:,1,:]]","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"A TPS can also be sliced with indexing by sparse monomial. In this case, if a colon is included anywhere in the sparse monomial variable index, then all orders of all variables and parameters not explicity specified will be included (colon position does not matter in sparse monomial indexing):","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"g = f[[1=>2, :, 3=>1, 4=>0, 5=>0], params=[1=>0, 2=>0]]\nh = f[(1=>2, 3=>1, :)]  # Colon position is irrelevant in slicing with sparse monomial indexing","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"When indexing by monomial index, a colon simply needs to be included after the variable index, or just a colon if a parameter is specified:","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"fΔx3 = f[3,:]\nfΔk1 = f[:,param=1]","category":"page"},{"location":"man/h_slice/#par","page":"Slicing and par","title":"par","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"par is very similar to slicing a TPS, with two differences:","category":"page"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"The specified variables and parameters are removed from the resulting slice\nWhen indexing by order, a colon is always presumed for unincluded variables/parameters","category":"page"},{"location":"man/h_slice/#Syntax","page":"Slicing and par","title":"Syntax","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, monomialindex)","category":"page"},{"location":"man/h_slice/#Description","page":"Slicing and par","title":"Description","text":"","category":"section"},{"location":"man/h_slice/#Description-2","page":"Slicing and par","title":"Description","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"monomialindex can be any of kind monomial indexing: by index, by order, and by sparse monomial. See the monomial indexing for more details on each.","category":"page"},{"location":"man/h_slice/#Examples","page":"Slicing and par","title":"Examples","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header=false; #hide\nd = Descriptor(5, 10, 2, 10);\nΔx = @vars(d);\nΔk = @params(d);\nf = 2*Δx[1]^2*Δx[3] + 3*Δx[1]^2*Δx[2]*Δx[3]*Δx[4]^2*Δx[5]*Δk[1] + 6*Δx[3] + 5\npar(f, 3)\npar(f, param=1)\npar(f, [2,:,1])\npar(f, [2,0,1])\npar(f, [1=>2, 3=>1])\npar(f, params=[1=>1])","category":"page"},{"location":"man/h_slice/#Documentation","page":"Slicing and par","title":"Documentation","text":"","category":"section"},{"location":"man/h_slice/","page":"Slicing and par","title":"Slicing and par","text":"par","category":"page"},{"location":"man/h_slice/#GTPSA.par","page":"Slicing and par","title":"GTPSA.par","text":"par(t::TPS, monomialindex)\n\nExtracts a polynomial from the TPS containing the specified monomial, and removes the monomial.  Any of the three monomial indexing schemes (by order, sparse monomial, or monomial index –  see the Monomial Indexing section of the GTPSA manual for more details) may be used to specify  the monomial.\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(5, 10, 2, 10); Δx = @vars(d); Δk = @params(d);\n\njulia> f = 2*Δx[1]^2*Δx[3] + 3*Δx[1]^2*Δx[2]*Δx[3]*Δx[4]^2*Δx[5]*Δk[1] + 6*Δx[3] + 5\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  5.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  6.0000000000000000e+00      1      0   0   1   0   0   |   0   0\n  2.0000000000000000e+00      3      2   0   1   0   0   |   0   0\n  3.0000000000000000e+00      8      2   1   1   2   1   |   1   0\n\n\njulia> par(f, 3)\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  6.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  2.0000000000000000e+00      2      2   0   0   0   0   |   0   0\n  3.0000000000000000e+00      7      2   1   0   2   1   |   1   0\n\n\njulia> par(f, param=1)\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  3.0000000000000000e+00      7      2   1   1   2   1   |   0   0\n\nExamples: Monomial Index-by-Order\n\njulia> par(f, [2,:,1])\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  3.0000000000000000e+00      5      0   1   0   2   1   |   1   0\n\n\njulia> par(f, [2,0,1])\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n\nExamples: Monomial Index-by-Sparse Monomial\n\njulia> par(f, [1=>2, 3=>1])\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  3.0000000000000000e+00      5      0   1   0   2   1   |   1   0\n\n\njulia> par(f, params=[1=>1])\nTPS64{Descriptor(NV=5, MO=10, NP=2, PO=10)}:\n Coefficient                Order   Exponent\n  3.0000000000000000e+00      7      2   1   1   2   1   |   0   0\n\n\n\n\n\n","category":"function"},{"location":"man/f_mono/#mono","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"section"},{"location":"man/f_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"Creates a TPS corresponding to a specific monomial","category":"page"},{"location":"man/f_mono/#Syntax","page":"mono/complexmono","title":"Syntax","text":"","category":"section"},{"location":"man/f_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono([tpstype, ] monomialindex [, use=(descriptor|tps)])\n\n# Static Descriptor resolution:\nm = mono(TPS{Float64|ComplexF64, descriptor}, monomialindex)\n\n# Dynamic Descriptor\nm = mono(monomialindex [, use=(descriptor|tps)])\nm = mono(TPS{Float64|ComplexF64 [, GTPSA.Dynamic]} monomialindex [, use=(descriptor|tps)])","category":"page"},{"location":"man/f_mono/#Description","page":"mono/complexmono","title":"Description","text":"","category":"section"},{"location":"man/f_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"monomialindex can be any of kind monomial indexing: by index, by order, and by sparse monomial. See the monomial indexing for more details on each.","category":"page"},{"location":"man/f_mono/#Examples","page":"mono/complexmono","title":"Examples","text":"","category":"section"},{"location":"man/f_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"using GTPSA; GTPSA.show_sparse = false; # hide\nd1 = Descriptor(3, 15, 2, 15); # 3 vars, 2 params, all to order 15\nmono(1)\nmono(TPS64{d}, 1)\nmono(ComplexTPS64{d}, param=1)\nmono(TPS64, [3,1,2], use=d1)\nmono(TPS64{d}, (3,1,2,2,1))\nmono([1=>3, 2=>1, 3=>3])\nmono((1=>3, 2=>1, 3=>2), params=(1=>2, 2=>1), use=d1)","category":"page"},{"location":"man/f_mono/#Documentation","page":"mono/complexmono","title":"Documentation","text":"","category":"section"},{"location":"man/f_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"mono","category":"page"},{"location":"man/f_mono/#GTPSA.mono","page":"mono/complexmono","title":"GTPSA.mono","text":"mono([tpstype, ] monomialindex [, use=(descriptor|tps)])\n\nReturns a TPS of type tpstype (which defaults to TPS{Float64,GTPSA.Dynamic}) with  the specified monomial set to 1. Any of the three monomial indexing schemes (by order, sparse  monomial, or monomial index – see the Monomial Indexing section of the GTPSA manual for more  details) may be used to specify the monomial to set to one. E.g. a call to this function is  equivalent to doing t = (tpstype)(use=use); t[monomialindex] = 1\n\nuse may only be specified if tpstype <: TPS{T where {T},<:GTPSA.Dynamic}.\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(3,10,2,10);\n\njulia> mono(1)\nTPS64{GTPSA.Dynamic}:\n Coefficient                Order   Exponent\n  1.0000000000000000e+00      1      1   0   0   |   0   0\n\n\njulia> mono(ComplexTPS64, 1)\nComplexTPS64{GTPSA.Dynamic}:\n Real                     Imag                       Order   Exponent\n  1.0000000000000000e+00   0.0000000000000000e+00      1      1   0   0   |   0   0\n\n\njulia> mono(ComplexTPS64{d}, param=2)\nComplexTPS64{Descriptor(NV=3, MO=10, NP=2, PO=10)}:\n Real                     Imag                       Order   Exponent\n  1.0000000000000000e+00   0.0000000000000000e+00      1      0   0   0   |   0   1\n\n\n# Examples: Monomial Index-by-Order\n\njulia-repl julia> mono([1,2,3]) TPS64{GTPSA.Dynamic}:  Coefficient                Order   Exponent   1.0000000000000000e+00      6      1   2   3   |   0   0\n\njulia> mono([0,0,3,2,1], use=d) TPS64{GTPSA.Dynamic}:  Coefficient                Order   Exponent   1.0000000000000000e+00      6      0   0   3   |   2   1\n\njulia> mono(TPS64{d}, [1,0,0,0,1]) TPS64{Descriptor(NV=3, MO=10, NP=2, PO=10)}:  Coefficient                Order   Exponent   1.0000000000000000e+00      2      1   0   0   |   0   1\n\n\n# Examples: Monomial Index-by-Sparse Monomial\n\njulia-repl julia> mono([1=>1]) TPS64{GTPSA.Dynamic}:  Coefficient                Order   Exponent   1.0000000000000000e+00      1      1   0   0   |   0   0\n\njulia> mono([2=>1]) TPS64{GTPSA.Dynamic}:  Coefficient                Order   Exponent   1.0000000000000000e+00      1      0   1   0   |   0   0\n\njulia> mono([1=>1], params=[2=>1], use=d) TPS64{GTPSA.Dynamic}:  Coefficient                Order   Exponent   1.0000000000000000e+00      2      1   0   0   |   0   1 ```\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#gjh","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"Extracts specific partial derivatives from a TPS","category":"page"},{"location":"man/g_gjh/#Syntax","page":"gradient, jacobian, hessian","title":"Syntax","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"grad = GTPSA.gradient(f [, include_params=bool])\nGTPSA.gradient!(grad, f [, include_params=bool])\n\nJ = GTPSA.jacobian(F [, include_params=bool])\nGTPSA.jacobian!(J, F [, include_params=bool])\n\nJt = GTPSA.jacobiant(F [, include_params=bool])\njacobiant!(Jt, F [, include_params=bool])\n\nH = GTPSA.hessian(f [, include_params=bool])\nGTPSA.hessian!(H, f [, include_params=bool])","category":"page"},{"location":"man/g_gjh/#Description","page":"gradient, jacobian, hessian","title":"Description","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"grad = GTPSA.gradient(f) extracts the gradient from the TPS f, defined as nabla f","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"GTPSA.gradient!(grad, f) fills grad vector in-place with the gradient extracted from the TPS f","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"J = GTPSA.jacobian(F) extracts the Jacobian matrix from the array of TPSs F, defined as J_ij = fracpartial F_ipartial x_j","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"GTPSA.jacobian!(J, F) fills the J matrix in-place with the Jacobian extracted from the array of TPSs F","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"Jt = GTPSA.jacobiant(F) extracts the transpose of the Jacobian matrix from the vector of TPSs F, with the Jacobian defined as J_ij = fracpartial F_ipartial x_j","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"GTPSA.jacobiant!(Jt, F) fills the Jt matrix in-place with the transpose of the Jacobian extracted from the vector of TPSs F","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"H = GTPSA.hessian(f) extracts the Hessian matrix from the TPS f, defined as H_ij = fracpartial^2 fpartial x_ipartial x_j","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"GTPSA.hessian!(H, f) fills the H matrix in-place with the Hessian extracted from the TPS f","category":"page"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/g_gjh/#Optional-Argument","page":"gradient, jacobian, hessian","title":"Optional Argument","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"include_params can be set to true (default is false) to include the partial derivatives with respect to the parameters in any of the extraction functions above.","category":"page"},{"location":"man/g_gjh/#Examples","page":"gradient, jacobian, hessian","title":"Examples","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"using GTPSA; #hide\nd = Descriptor(2,10);\nΔx = @vars(d);\nf = Δx[1] + 2*Δx[2] + 3*Δx[1]^2 + 4*Δx[1]*Δx[2] + 5*Δx[2]^2;\ng = 5*Δx[1] + 4*Δx[2] + 3*Δx[1]^2 + 2*Δx[1]*Δx[2] + Δx[2]^2;\ngrad = GTPSA.gradient(f)\nJ = GTPSA.jacobian([f, g])\nH = GTPSA.hessian(f)","category":"page"},{"location":"man/g_gjh/#Documentation","page":"gradient, jacobian, hessian","title":"Documentation","text":"","category":"section"},{"location":"man/g_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"GTPSA.gradient\nGTPSA.gradient!\nGTPSA.jacobian\nGTPSA.jacobian!\nGTPSA.jacobiant\nGTPSA.jacobiant!\nGTPSA.hessian\nGTPSA.hessian!","category":"page"},{"location":"man/g_gjh/#GTPSA.gradient","page":"gradient, jacobian, hessian","title":"GTPSA.gradient","text":"GTPSA.gradient(t::TPS; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the TPS. The partial  derivatives wrt the parameters will also be extracted when the include_params flag is  set to true. Note that this function is not calculating anything - just extracting the  first-order monomial coefficients already in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS64 to extract the gradient from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\ngrad           – Gradient of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.gradient!","page":"gradient, jacobian, hessian","title":"GTPSA.gradient!","text":"GTPSA.gradient!(result, t::TPS; include_params=false, unsafe_inbounds=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the TPS and fills the result  vector in-place. The partial derivatives wrt the parameters will also be extracted  when the include_params flag is set to true. Note that this function is not  calculating anything - just extracting the first-order monomial coefficients already  in the TPS.\n\nInput\n\nt               – TPS/ComplexTPS64 to extract the gradient from\ninclude_params  – (Optional) Extract partial derivatives wrt parameters. Default is false\nunsafe_inbounds – (Optional) Flag which, if false, ignores checking the size of result. The size of result is used to index the TPS. Default is false\n\nOutput\n\nresult         – Vector to fill with the gradient of the TPS, must be 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.jacobian","page":"gradient, jacobian, hessian","title":"GTPSA.jacobian","text":"GTPSA.jacobian(m::AbstractArray{<:TPS}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the array of TPSs.  The partial derivatives wrt the parameters will also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting  the first-order monomial coefficients already in the TPSs.\n\nInput\n\nm              – Array of TPSs to extract the Jacobian from, must be 1-based indexing\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nJ              – Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.jacobian!","page":"gradient, jacobian, hessian","title":"GTPSA.jacobian!","text":"GTPSA.jacobian!(result, m::AbstractArray{<:TPS}; include_params=false, unsafe_inbounds=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the array of TPSs.  and fills the result matrix in-place. The partial derivatives wrt the parameters will  also be extracted when the include_params flag is set to true. Note that this function  is not calculating anything - just extracting the first-order monomial coefficients already  in the TPSs.\n\nInput\n\nm               – Array of TPSs to extract the Jacobian from, must be 1-based indexing\ninclude_params  – (Optional) Extract partial derivatives wrt parameters. Default is false\nunsafe_inbounds – (Optional) Flag which, if false, ignores checking the size of result. The size of result is used to index the TPS. Default is false\n\nOutput\n\nresult         – Matrix to fill with the Jacobian of m, must be 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.jacobiant","page":"gradient, jacobian, hessian","title":"GTPSA.jacobiant","text":"GTPSA.jacobiant(m::AbstractArray{<:TPS}; include_params=false) where {N,P,I}\n\nExtracts the first-order partial derivatives (evaluated at 0) from the array of TPSs,  as the transpose of the Jacobian. The partial derivatives wrt the parameters will also  be extracted when the include_params flag is set to true. Note that this function is  not calculating anything - just extracting the first-order monomial coefficients already  in the TPSs.\n\nInput\n\nm              – Array of TPSs to extract the Jacobian from, must be 1-based indexing\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nJt             – Transpose of the Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.jacobiant!","page":"gradient, jacobian, hessian","title":"GTPSA.jacobiant!","text":"GTPSA.jacobiant!(result, m::AbstractArray{<:TPS}; include_params=false, unsafe_inbounds=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the array of TPSs,  as the transpose of the Jacobian. The partial derivatives wrt the parameters will also  be extracted when the include_params flag is set to true. Note that this function is  not calculating anything - just extracting the first-order monomial coefficients already  in the TPSs and filling result.\n\nInput\n\nm               – Vector of TPSs to extract the Jacobian from, must be 1-based indexing\ninclude_params  – (Optional) Extract partial derivatives wrt parameters. Default is false\nunsafe_inbounds – (Optional) Flag which, if false, ignores checking the size of result. The size of result is used to index the TPS. Default is false\n\nOutput\n\nresult         – Matrix to fill with the transpose of the Jacobian of m, must be 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.hessian","page":"gradient, jacobian, hessian","title":"GTPSA.hessian","text":"GTPSA.hessian(t::TPS; include_params=false)\n\nExtracts the second-order partial derivatives (evaluated at 0) from the TPS. The partial derivatives wrt the parameters will also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting  the second-order monomial coefficients already in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS64 to extract the Hessian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nH              – Hessian of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/g_gjh/#GTPSA.hessian!","page":"gradient, jacobian, hessian","title":"GTPSA.hessian!","text":"GTPSA.hessian!(result, t::TPS; include_params=false, tmp_mono::Union{Nothing,Vector{UInt8}}=nothing, unsafe_fast=false, unsafe_inbounds=false)\n\nExtracts the second-order partial derivatives (evaluated at 0) from the TPS  and fills the result matrix in-place. The partial derivatives wrt the parameters will  also be extracted when the include_params flag is set to true. Note that this function  is not calculating anything - just extracting the second-order monomial coefficients already  in the TPS.\n\nInput\n\nt               – TPS/ComplexTPS64 to extract the Hessian from\ninclude_params  – (Optional) Extract partial derivatives wrt parameters. Default is false\ntmp_mono        – (Optional) Vector{UInt8} to store the monomial, when different orders of truncation are used\nunsafe_fast     – (Optional) Flag to specify that \"fast\" indexing should be used without checking. This will give incorrect results if any variable has a TO < 2. Default is false.\nunsafe_inbounds – (Optional) Flag which, if false, ignores checking the size of result. The size of result is used to index the TPS. Default is false\n\nOutput\n\nresult         – Matrix to fill with the Hessian of the TPS, must be 1-based indexing\n\n\n\n\n\n","category":"function"},{"location":"#GTPSA.jl","page":"Home","title":"GTPSA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A full-featured Julia interface to the Generalised Truncated Power Series Algebra library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GTPSA.jl is a full-featured Julia interface to the Generalised Truncated Power Series Algebra (GTPSA) library, which computes Taylor expansions, or Truncated Power Series (TPSs), of real and complex multivariable functions to high orders.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Truncated Power Series Algebra (TPSA) performs forward-mode automatic differentation (AD) similar to the typical dual-number implementation, as in ForwardDiff.jl. However, instead of nesting derivatives for higher orders, TPSA naturally extends to arbitary orders by directly using the power series expansions. Furthermore, because TPSA is designed for high order AD, the storage, indexing, and propagation of all nonzero partial derivatives has been highly optimized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GTPSA.jl provides several unique features and functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"High Order AD Speed: GTPSA.jl is significantly faster than ForwardDiff.jl for 2nd-order calculations and above, and has very similar performance at 1st-order. See our example where GTPSA was x3.5 faster than ForwardDiff to 2nd order, and x19.8 faster to 3rd order.\nEasy Monomial Indexing: Beyond 2nd order, accessing/manipulating the partial derivatives in an organized way can be a significant challenge. GTPSA provides three simple indexing schemes for getting/setting monomial coefficients in a truncated power series, as well as a cycle! function for cycling through all nonzero monomials.\nEasy TPS slicing: Suppose you would like to get all terms in a multivariable truncated power series proportional to a specific variable; GTPSA.jl provides a simple syntax similar to array slicing to extract parts of a TPS.\nComplex Numbers: GTPSA.jl natively supports complex numbers and allows for mixing of complex and real truncated power series.\nDistinction Between State Variables and Parameters: Distinguishing between dependent variables and parameters in the solution of a differential equation expressed as a power series in the dependent variables/parameters can be advantageous in analysis.\nDifferent Orders in Variables/Parameters: The truncation order can be set differently for the variables and parameters. For example, computing the expansion of a function f(x_1k_1) to 6th order in Delta x_1, but ignoring terms O(Delta k_1^2), is possible in GTPSA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GTPSA.jl also includes useful truncated power series operations such as evaluation, composition, translation, and inversion.","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use GTPSA.jl, in the Julia REPL run","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"GTPSA\")","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using GTPSA\n\njulia> d = Descriptor(2, 6); # 2 variables to 6th order\n\njulia> Δx = @vars(d)  # Get truncated power series (TPSs) corresponding to the variables\n\njulia> f = cos(Δx[1]) + im*sin(Δx[2]) # Manipulate TPSs as you would any other number\nComplexTPS64{Descriptor(NV=2, MO=6)}:\n Real                     Imag                       Order   Exponent\n  1.0000000000000000e+00   0.0000000000000000e+00      0      0   0\n  0.0000000000000000e+00   1.0000000000000000e+00      1      0   1\n -5.0000000000000000e-01   0.0000000000000000e+00      2      2   0\n  0.0000000000000000e+00  -1.6666666666666666e-01      3      0   3\n  4.1666666666666664e-02   0.0000000000000000e+00      4      4   0\n  0.0000000000000000e+00   8.3333333333333332e-03      5      0   5\n -1.3888888888888887e-03   0.0000000000000000e+00      6      6   0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The GTPSA library currently only supports truncated power series representing Float64 and ComplexF64 number types.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much thanks must be given to Laurent Deniau, the creator of the C GTPSA library, for his time and great patience in explaining his code. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Advanced users are referred to this paper discussing the inner workings of the C GTPSA library.","category":"page"}]
}
