var documenterSearchIndex = {"docs":
[{"location":"man/f_varsparams/#varsparams","page":"vars, params","title":"vars, params","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"Creates a vector of TPSs corresponding to each variable/parameter in the GTPSA","category":"page"},{"location":"man/f_varsparams/#Syntax","page":"vars, params","title":"Syntax","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"x  = vars([(descriptor|tps|complextps)])\nxc = complexvars([(descriptor|tps|complextps)])\n\nk  = params([(descriptor|tps|complextps)])\nkc = complexparams([(descriptor|tps|complextps)])","category":"page"},{"location":"man/f_varsparams/#Description","page":"vars, params","title":"Description","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"x = vars() creates a vector of TPSs corresponding to each of the variables in the GTPSA defined by the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"x = complexvars() creates a vector of ComplexTPSs corresponding to each of the variables in the GTPSA defined by the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"","category":"page"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"k = params() creates a vector of TPSs corresponding to each of the parameters in the GTPSA defined by the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"k = complexparams() creates a vector of ComplexTPSs corresponding to each of the parameters in the GTPSA defined by the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/f_varsparams/#Optional-Argument","page":"vars, params","title":"Optional Argument","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"descriptor creates a vector of TPS/ComplexTPSs corresponding to each of the variables/parameters in the GTPSA defined by the passed Descriptor","category":"page"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"(tps|complextps) creates a vector of TPS/ComplexTPSs corresponding to each of the variables/parameters in the GTPSA defined by the Descriptor of the passed TPS or ComplexTPS","category":"page"},{"location":"man/f_varsparams/#Examples","page":"vars, params","title":"Examples","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nGTPSA.show_header=true\nd1 = Descriptor(3, 5, 2, 5); # 3 vars, 2 params, all to order 5\nx1 = vars()\nk1 = params()\nd2 = Descriptor(2, 5, 1, 5); # 2 vars, 1 param, all to order 5\nx2 = vars()\nk2 = params()\nk1 = params(d1)","category":"page"},{"location":"man/f_varsparams/#Documentation","page":"vars, params","title":"Documentation","text":"","category":"section"},{"location":"man/f_varsparams/","page":"vars, params","title":"vars, params","text":"vars\ncomplexvars\nparams\ncomplexparams","category":"page"},{"location":"man/f_varsparams/#GTPSA.vars","page":"vars, params","title":"GTPSA.vars","text":"vars(use::Union{Descriptor,TPS,ComplexTPS}=GTPSA.desc_current)::Vector{TPS}\n\nReturns TPSs corresponding to the variables for the Descriptor specified by use. Default value is GTPSA.desc_current.\n\nInput\n\nuse – (Optional) Specify which TPSA Descriptor to use, default is GTPSA.desc_current\n\nOutput\n\nx   – Vector containing unit TPSs corresponding to each variable\n\n\n\n\n\n","category":"function"},{"location":"man/f_varsparams/#GTPSA.complexvars","page":"vars, params","title":"GTPSA.complexvars","text":"complexvars(use::Union{Descriptor,TPS,ComplexTPS}=GTPSA.desc_current)::Vector{ComplexTPS}\n\nReturns ComplexTPSs corresponding to the variables for the Descriptor specified by use. Default value is GTPSA.desc_current.\n\nInput\n\nuse – (Optional) Specify which TPSA Descriptor to use, default is GTPSA.desc_current\n\nOutput\n\nx   – Vector containing unit ComplexTPSs corresponding to each variable\n\n\n\n\n\n","category":"function"},{"location":"man/f_varsparams/#GTPSA.params","page":"vars, params","title":"GTPSA.params","text":"params(use::Union{Descriptor,TPS,ComplexTPS}=GTPSA.desc_current)::Vector{TPS}\n\nReturns TPSs corresponding to the parameters for the Descriptor specified by use. Default value is GTPSA.desc_current.\n\nInput\n\nuse – (Optional) Specify which TPSA Descriptor to use, default is GTPSA.desc_current\n\nOutput\n\nk   – Vector containing unit TPSs corresponding to each parameter\n\n\n\n\n\n","category":"function"},{"location":"man/f_varsparams/#GTPSA.complexparams","page":"vars, params","title":"GTPSA.complexparams","text":"complexparams(d::Descriptor=GTPSA.desc_current)::Vector{ComplexTPS}\n\nReturns ComplexTPSs corresponding to the parameters for the Descriptor specified by use. Default value is GTPSA.desc_current.\n\nInput\n\nuse – (Optional) Specify which TPSA Descriptor to use, default is GTPSA.desc_current\n\nOutput\n\nk   – Vector containing unit ComplexTPSs corresponding to each parameter\n\n\n\n\n\n","category":"function"},{"location":"devel/#For-Developers","page":"For Developers","title":"For Developers","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"Developers may fork the GTPSA.jl repo and then dev their forked repo in the REPL. For example, if my Github username is githubuser, then after forking GTPSA.jl I would run in the REPL:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"import Pkg\nPkg.develop(url=\"https://github.com/githubuser/GTPSA.jl\")","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The package consists of two layers: a low-level layer written in Julia that is 1-to-1 with the GTPSA C code, and a high-level, user-friendly layer that cleans up the notation for manipulating TPSAs, manages temporaries generated during evaluation, and properly manages the memory in C when variables go out of scope in Julia. The low-level functions, which are exported for developer usage at the moment, are listed below.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The C code consists of three C structs: desc, tpsa, and ctpsa. The low-level Julia-equivalent, 1-to-1 structs are respectively Desc, RTPSA, and CTPSA. C pointers Ptr to these structs are wrapped by the high-level structs Descriptor, TPSA, and ComplexTPSA respectively.","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"The low-level structs Desc, RTPSA, and CTPSA contain fields with Ptr{Cvoid}; these are pointers to any of the other structs, specified in the documentation. For example, the d field in RTPSA is a Ptr{Desc}. We could not explicitly define Ptr{Desc}, because Desc likewise has a Ptr{RTPSA}, and Julia does not allow for cyclic implicit struct definitions. Therefore, the Ptr must be converted to the appropriate low-level Julia struct before safe accessing (documented next to each of the fields).","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"For example, to access the t array of RTPSAs in Desc defined by a high-level struct Descriptor:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"using GTPSA\nimport GTPSA: RTPSA, CTPSA, Desc\n\nd = Descriptor(5,8)\n\n# To access the low-level C struct:\ndesc = unsafe_load(d.desc)\n\n# To access the array of 8 temporaries t:\nt_jl = unsafe_wrap(Vector{Ptr{RTPSA}}, Base.unsafe_convert(Ptr{Ptr{RTPSA}}, desc.t), 8)","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"First the Ptr{Ptr{Cvoid}} is converted to a Ptr{Ptr{RTPSA}}, which can then be wrapped in a Vector{Ptr{RTPSA}}. Note that calling unsafe_wrap uses memory allocation, so it is preferred to use unsafe_load for speed-critical applications.To get the first temporary in the array without using unsafe_wrap, use:","category":"page"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"t1_jl = unsafe_load(Base.unsafe_convert(Ptr{Ptr{RTPSA}}, desc.t), 1)","category":"page"},{"location":"devel/#Monomial","page":"For Developers","title":"Monomial","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.mad_mono_str!\nGTPSA.mad_mono_prt!\nGTPSA.mad_mono_fill!\nGTPSA.mad_mono_copy!\nGTPSA.mad_mono_min\nGTPSA.mad_mono_max\nGTPSA.mad_mono_ord\nGTPSA.mad_mono_ordp\nGTPSA.mad_mono_ordpf\nGTPSA.mad_mono_eq\nGTPSA.mad_mono_lt\nGTPSA.mad_mono_le\nGTPSA.mad_mono_cmp\nGTPSA.mad_mono_rcmp\nGTPSA.mad_mono_add!\nGTPSA.mad_mono_sub!\nGTPSA.mad_mono_cat!\nGTPSA.mad_mono_rev!\nGTPSA.mad_mono_print","category":"page"},{"location":"devel/#GTPSA.mad_mono_str!","page":"For Developers","title":"GTPSA.mad_mono_str!","text":"mad_mono_str!(n::Cint, a::Vector{Cuchar}, s::Cstring)::Cint\n\nWrites the monomial defined in the string s, which stores the orders in a human-readable format  (e.g. 10 is 10, not 0xa), into the byte array a with the orders specified in hexadecimal.\n\nInput\n\nn – Monomial and string length\ns – Monomial as string \"[0-9]*\"\n\nOutput\n\na – Monomial as a byte array converted from the input string\ni – Adjusted size n of byte array if '\u0000' found\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_prt!","page":"For Developers","title":"GTPSA.mad_mono_prt!","text":"mad_mono_prt(n::Cint, a::Vector{Cuchar}, s::Ptr{Cuchar})::Cstring\n\nWrites the monomial defined by the byte array a (with orders stored as hexadecimal) into  a null terminated string s.\n\nInput\n\nn – Monomial and string length\na – Monomial as byte array\n\nOutput\n\nret – Monomial as string\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_fill!","page":"For Developers","title":"GTPSA.mad_mono_fill!","text":"mad_mono_fill!(n::Cint, a::Vector{Cuchar}, v::Cuchar)\n\nFills the monomial a with the value v.\n\nInput\n\nn – Monomial length\na – Monomial\nv – Value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_copy!","page":"For Developers","title":"GTPSA.mad_mono_copy!","text":"mad_mono_copy!(n::Cint, a::Vector{Cuchar}, r::Vector{Cuchar})\n\nCopies monomial a to monomial r.  \n\nInput\n\nn – Length of monomials\na – Source monomial\nr – Destination monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_min","page":"For Developers","title":"GTPSA.mad_mono_min","text":"mad_mono_min(n::Cint, a::Vector{Cuchar})::Cuchar\n\nReturns the minimum order of the monomial.\n\nInput\n\nn  – Length of monomial\na  – Monomial\n\nOutput\n\nmo – Mininum order of monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_max","page":"For Developers","title":"GTPSA.mad_mono_max","text":"mad_mono_max(n::Cint, a::Vector{Cuchar})::Cuchar\n\nReturns the maximum order of the monomial.\n\nInput\n\nn  – Length of monomial\na  – Monomial\n\nOutput\n\nmo – Maximum order of monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ord","page":"For Developers","title":"GTPSA.mad_mono_ord","text":"mad_mono_ord(n::Cint, a::Vector{Cuchar})::Cint\n\nReturns the sum of the orders of the monomial a.\n\nInput\n\nn – Monomial length\na – Monomial\n\nOutput\n\ns – Sum of orders of monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ordp","page":"For Developers","title":"GTPSA.mad_mono_ordp","text":"mad_mono_ordp(n::Cint, a::Vector{Cuchar}, stp::Cint)::Cdouble\n\nReturns the product of each stp-th order in monomial a. For example, stp = 2 collects every order in the monomial with a step of 2 between each. As a is a pointer, the product can be started at any  element in the monomial.\n\nInput\n\nn   – Monomial length\na   – Monomial as byte array\nstp – Step over which orders to include in the product\n\nOutput\n\np   – Product of orders of monomial separated by stp.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_ordpf","page":"For Developers","title":"GTPSA.mad_mono_ordpf","text":"mad_mono_ordpf(n::Cint, a::Vector{Cuchar}, stp::Cint)::Cdouble\n\nReturns the product of factorials each stp-th order in monomial a. For example, stp = 2 collects  every order in the monomial with a step of 2 between each. As a is a pointer, the product can be started  at any element in the monomial.\n\nInput\n\nn   – Monomial length\na   – Monomial as byte array\nstp – Step over which orders to include in the product of factorials\n\nOutput\n\np   – Product of factorials of orders of monomial separated by stp\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_eq","page":"For Developers","title":"GTPSA.mad_mono_eq","text":"mad_mono_eq(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar})::Cuchar\n\nChecks if the monomial a is equal to the monomial b.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – True if the monomials are equal, false if otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_lt","page":"For Developers","title":"GTPSA.mad_mono_lt","text":"mad_mono_lt(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar})::Cuchar\n\nChecks if monomial a is less than monomial b.\n\nInput\n\nn  – Length of monomials\na  – Monomial a\nb  – Monomial b\n\nOutput\n\nret – True if a < b, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_le","page":"For Developers","title":"GTPSA.mad_mono_le","text":"mad_mono_le(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar})::Cuchar\n\nChecks if monomial a is less than or equal to monomial b.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – True if a <= mono_b, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_cmp","page":"For Developers","title":"GTPSA.mad_mono_cmp","text":"mad_mono_cmp(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar})::Cint\n\nCompares monomial a to monomial b, and returns the first difference in the lowest order variables.\n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – First a[i]-b[i] != 0\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_rcmp","page":"For Developers","title":"GTPSA.mad_mono_rcmp","text":"mad_mono_rcmp(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar})::Cint\n\nCompares monomial a to monomial b starting from the right (when the monomials are ordered by variable,  which is almost never the case) and returns the first difference in the lowest order variables. \n\nInput\n\nn   – Length of monomials\na   – Monomial a\nb   – Monomial b\n\nOutput\n\nret – First a[i]-b[i] != 0 where i starts from the end.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_add!","page":"For Developers","title":"GTPSA.mad_mono_add!","text":"mad_mono_add!(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar}, r::Vector{Cuchar})\n\nSets monomial r = a + b.\n\nInput\n\nn – Length of monomials\na – Source monomial a\nb – Source monomial b\n\nOutput\n\nr – Destination monomial, r = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_sub!","page":"For Developers","title":"GTPSA.mad_mono_sub!","text":"mad_mono_sub!(n::Cint, a::Vector{Cuchar}, b::Vector{Cuchar}, r::Vector{Cuchar})\n\nSets monomial r = a - b.\n\nInput\n\nn – Length of monomials\na – Source monomial a\nb – Source monomial b\n\nOutput\n\nr – Destination monomial, r = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_cat!","page":"For Developers","title":"GTPSA.mad_mono_cat!","text":"mad_mono_cat!(n::Cint, a::Vector{Cuchar}, m::Cint, b::Vector{Cuchar}, r::Vector{Cuchar})\n\nSets monomial r equal to the concatenation of the monomials a and b\n\nInput\n\nn – Length of monomonial a\na – Source monomial a\nm – Length of monomial b\nb – Source monomial b\n\nOutput\n\nr – Destination monomial of concatenation of a and b (length n+m)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_rev!","page":"For Developers","title":"GTPSA.mad_mono_rev!","text":"mad_mono_rev!(n::Cint, a::Vector{Cuchar}, r::Vector{Cuchar})\n\nSets destination monomial r equal to the reverse of source monomial a.\n\nInput\n\nn – Lengths of monomials\na – Source monomial a\n\nOutput\n\nr – Destination monomial of reverse monomial a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_mono_print","page":"For Developers","title":"GTPSA.mad_mono_print","text":"mad_mono_print(n::Cint, a::Vector{Cuchar}, fp_::Ptr{Cvoid})\n\nPrints the monomial to stdout.\n\nInput\n\nn  – Length of monomial\na  – Source monomial to print to stdout\nfp_ – C FILE pointer, if null will print to stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#Desc","page":"For Developers","title":"Desc","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.Desc\nGTPSA.mad_desc_newv\nGTPSA.mad_desc_newvp\nGTPSA.mad_desc_newvpo\nGTPSA.mad_desc_del!\nGTPSA.mad_desc_getnv!\nGTPSA.mad_desc_maxord\nGTPSA.mad_desc_maxlen\nGTPSA.mad_desc_gtrunc!\nGTPSA.mad_desc_isvalids\nGTPSA.mad_desc_isvalidm\nGTPSA.mad_desc_isvalidsm\nGTPSA.mad_desc_idxs\nGTPSA.mad_desc_idxm\nGTPSA.mad_desc_idxsm\nGTPSA.mad_desc_nxtbyvar\nGTPSA.mad_desc_nxtbyord\nGTPSA.mad_desc_mono!\nGTPSA.mad_desc_info","category":"page"},{"location":"devel/#GTPSA.Desc","page":"For Developers","title":"GTPSA.Desc","text":"`Desc`\n\nThis is a 1-to-1 struct for the C definition desc (descriptor) in GTPSA. Descriptors include all  information about the TPSA, including the number of variables/parameters and their orders, lookup tables for  the monomials, monomial indexing function, and pre-allocated permanent temporaries for fast evaluation.\n\nFields\n\nid::Cint                   – Index in list of registered descriptors\nnn::Cint                   – Number of variables + number of parameters, nn = nv+np <= 100000\nnv::Cint                   – Number of variables\nnp::Cint                   – Number of parameters\nmo::Cuchar                 – Max order of both variables AND parameters\npo::Cuchar                 – Max order of parameterss\nto::Cuchar                 – Global order of truncation. Note: ord_t in gtpsa is typedef for unsigned char (Cuchar)\nno::Ptr{Cuchar}            – Array of orders of each variable (first nv entries) and parameters (last np entries), length nn. Note: In C this is const\nuno::Cint                  – User provided array of orders of each variable/parameter (with mad_desc_newvpo)\nnth::Cint                  – Max number of threads or 1\nnc::Cuint                  – Number of coefficients (max length of TPSA)\nmonos::Ptr{Cuchar}         – 'Matrix' storing the monomials (sorted by variable)\nords::Ptr{Cuchar}          – Order of each monomial of To\nprms::Ptr{Cuchar}          – Order of parameters in each monomial of To (zero = no parameters)\nTo::Ptr{Ptr{Cuchar}}       – Table by orders - pointers to monomials, sorted by order\nTv::Ptr{Ptr{Cuchar}}       – Table by vars - pointers to monomials, sorted by variable\nocs::Ptr{Ptr{Cuchar}}      – ocs[t,i] -> o in mul, compute o on thread t 3 <= o <= mo aterminated with 0\nord2idx::Ptr{Cint}         – Order to polynomial start index in To (i.e. in TPSA coef)\ntv2to::Ptr{Cint}           – Lookup tv->to\nto2tv::Ptr{Cint}           – Lookup to->tv\nH::Ptr{Cint}               – Indexing matrix in Tv\nL::Ptr{Ptr{Cint}}          – Multiplication indexes L[oa,ob]->L_ord L_ord[ia,ib]->ic\nL_idx::Ptr{Ptr{Ptr{Cint}}} – L_idx[oa,ob]->[start] [split] [end] idxs in L\nsize::Culonglong           – Bytes used by desc. Unsigned Long Int: In 32 bit system is Int32 but 64 bit is Int64. Using Culonglong assuming 64 bit\nt::Ptr{Ptr{Cvoid}}         – Temporary array contains 8 pointers to RTPSAs already initialized\nct::Ptr{Ptr{Cvoid}}        – Temporary array contains 8 pointers to CTPSAs already initialized\nti::Ptr{Cint}              – idx of tmp used by each thread (length = # threads)\ncti::Ptr{Cint}             – idx of tmp used by each thread (length = # threads)                                                                                              \n\n\n\n\n\n","category":"type"},{"location":"devel/#GTPSA.mad_desc_newv","page":"For Developers","title":"GTPSA.mad_desc_newv","text":"mad_desc_newv(nv::Cint, mo::Cuchar)::Ptr{Desc}\n\nCreates a TPSA descriptor with the specified number of variables and maximum order.  The number of parameters is set to 0.\n\nInput\n\nnv  – Number of variables in the TPSA\nmo  – Maximum order of TPSA, mo = max(1, mo)\n\nOutput\n\nret – Descriptor with the specified number of variables and maximum order\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_newvp","page":"For Developers","title":"GTPSA.mad_desc_newvp","text":"mad_desc_newvp(nv::Cint, mo::Cuchar, np_::Cint, po_::Cuchar)::Ptr{Desc}\n\nCreates a TPSA descriptor with the specifed number of variables, maximum order, number of  parameters, and parameter order.\n\nInput\n\nnv  – Number of variables\nmo  – Maximum order of TPSA INCLUDING PARAMETERS, mo = max(1, mo)\nnp_ – (Optional) Number of parameters, default is 0\npo_ – (Optional) Order of parameters, po = max(1, po_)\n\nOutput\n\nret – Descriptor with the specified nv, mo, np, and po\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_newvpo","page":"For Developers","title":"GTPSA.mad_desc_newvpo","text":"mad_desc_newvpo(nv::Cint, mo::Cuchar, np_::Cint, po_::Cuchar, no_::Vector{Cuchar})::Ptr{Desc}\n\nCreates a TPSA descriptor with the specifed number of variables, maximum order for both variables and parameters, number of parameters,  parameter order, and individual variable/parameter orders specified in no. The first nv entries in no  correspond to the variables' orders and the next np entries correspond the parameters' orders.\n\nInput\n\nnv   – Number of variables\nmo   – Maximum order of TPSA (mo = max(mo , no[0 :nn-1]), nn = nv+np)\nnp_  – (Optional) Number of parameters, default is 0\npo_  – (Optional) Order of parameters (po = max(po_, no[nv:nn-1]), po <= mo)\nno_  – (Optional) Array of orders of variables and parameters\n\nOutput\n\nret – Descriptor with the specified nv, mo, np, po, no.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_del!","page":"For Developers","title":"GTPSA.mad_desc_del!","text":"mad_desc_del!(d_::Ptr{Desc})\n\nCalls the destructor for the passed descriptor.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_getnv!","page":"For Developers","title":"GTPSA.mad_desc_getnv!","text":"mad_desc_getnv!(d::Ptr{Desc}, mo_::Ref{Cuchar}, np_::Ref{Cint}, po_::Ref{Cuchar}::Cint\n\nReturns the number of variables in the descriptor, and sets the passed mo_, np_, and po_ to the maximum  order, number of parameters, and parameter order respectively.\n\nInput\n\nd – Descriptor\n\nOutput\n\nmo_ – (Optional) Maximum order of the descriptor\nnp_ – (Optional) Number of parameters of the descriptor\npo_ – (Optional) Parameter order of the descriptor\nret – Number of variables in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_maxord","page":"For Developers","title":"GTPSA.mad_desc_maxord","text":"mad_desc_maxord(d::Ptr{Desc}, nn::Cint, no_::Vector{Cuchar})::Cuchar\n\nSets the order of the variables and parameters of the TPSA to those specified in no_ and  returns the maximum order of the TPSA.\n\nInput\n\nd   – Descriptor\nnn  – Number of variables + number of parameters, no_[1..nn]\nno_ – (Optional) Orders of parameters to be filled if provided\n\nOutput\n\nret  – Maximum order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_maxlen","page":"For Developers","title":"GTPSA.mad_desc_maxlen","text":"mad_desc_maxlen(d::Ptr{Desc}, mo::Cuchar)::Cint\n\nGets the maximum length of the TPSA given an order. \n\nInput\n\nd   – Descriptor\nmo  – Order (ordlen(maxord) == maxlen)\n\nOutput\n\nret – monomials in 0..order\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_gtrunc!","page":"For Developers","title":"GTPSA.mad_desc_gtrunc!","text":"mad_desc_gtrunc!(d::Ptr{Desc}, to::Cuchar)::Cuchar\n\nSets the global truncation order to of the TPSA, and returns the old global truncation order.\n\nInput\n\nd     – Descriptor\nto    – New global truncation order\n\nOutput\n\noldto – Old global truncation order\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalids","page":"For Developers","title":"GTPSA.mad_desc_isvalids","text":"mad_desc_isvalids(d::Ptr{Desc}, n::Cint, s::Cstring)::Cuchar\n\nChecks if monomial as string s is valid given maximum order of descriptor.\n\nInput\n\nd  – Descriptor\nn  – Monomial string length\ns  – Monomial as string \"[0-9]*\"\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalidm","page":"For Developers","title":"GTPSA.mad_desc_isvalidm","text":"mad_desc_isvalidm(d::Ptr{Desc}, n::Cint, m::Vector{Cuchar})::Cuchar\n\nChecks if monomial as byte array m is valid given maximum order of descriptor.\n\nInput\n\nd  – Descriptor\nn  – Length of monomial\nm  – Monomial as byte array\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_isvalidsm","page":"For Developers","title":"GTPSA.mad_desc_isvalidsm","text":"mad_desc_isvalidsm(d::Ptr{Desc}, n::Cint, m::Vector{Cint})::Cuchar\n\nChecks the monomial as sparse monomial m (monomial stored as sequence of integers with each pair  [(i,o)] such that i = index, o = order) is valid given the maximum order of the descriptor.\n\nInput\n\nd   – Descriptor\nn   – Length of monomial\nm   – Sparse monomial [(idx, ord)]\n\nOutput\n\nret – True if valid, false if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxs","page":"For Developers","title":"GTPSA.mad_desc_idxs","text":"mad_desc_idxs(d::Ptr{Desc}, n::Cint, s::Cstring)::Cint\n\nReturns the index of the monomial as string s in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd   – Descriptor\nn   – String length or 0 if unknown\ns   – Monomial as string \"[0-9]*\"\n\nOutput\n\nret – Monomial index or -1 if invalid monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxm","page":"For Developers","title":"GTPSA.mad_desc_idxm","text":"mad_desc_idxm(d::Ptr{Desc}, n::Cint, m::Vector{Cuchar})::Cint\n\nReturns the index of the monomial as byte array m in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd – Descriptor\nn    – Monomial length\nm    – Monomial as byte array\n\nOutput\n\nret  – Monomial index or -1 if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_idxsm","page":"For Developers","title":"GTPSA.mad_desc_idxsm","text":"mad_desc_idxsm(d::Ptr{Desc}, n::Cint, m::Vector{Cint})::Cint\n\nReturns the index of the monomial as sparse monomial m, indexed as [(i,o)], in the descriptor, or -1 if the monomial is invalid.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Sparse monomial [(idx,ord)]\n\nOutput\n\nret – Monomial index or -1 if invalid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_nxtbyvar","page":"For Developers","title":"GTPSA.mad_desc_nxtbyvar","text":"mad_desc_nxtbyvar(d::Ptr{Desc}, n::Cint, m::Vector{Cuchar})::Cint\n\nReturns the next monomial after monomial m in the TPSA when sorted by variable.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Monomial as byte array\n\nOutput\n\nidx – Monomial index or -1 if no valid next monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_nxtbyord","page":"For Developers","title":"GTPSA.mad_desc_nxtbyord","text":"mad_desc_nxtbyord(d::Ptr{Desc}, n::Cint, m::Vector{Cuchar})::Cint\n\nReturns the next monomial after monomial m in the TPSA when sorted by order.\n\nInput\n\nd   – Descriptor\nn   – Monomial length\nm   – Monomial as byte array\n\nOutput\n\nidx – Monomial index or -1 if no valid next monomial\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_mono!","page":"For Developers","title":"GTPSA.mad_desc_mono!","text":"mad_desc_mono!(d::Ptr{Desc}, i::Cint, n::Cint, m_::Vector{Cuchar}, p_::Vector{Cuchar})::Cuchar\n\nReturns the order of the monomial at index i, and if n and m_ are provided, then will also fill m_  with the monomial at this index. Also will optionally return the order of the parameters in the monomial  if p_ is provided\n\nInput\n\nd   – Descriptor\ni   – Slot index (must be valid)\nn   – Monomial length (must be provided if m_ is to be filled)\n\nOutput\n\nret – Monomial order at slot index\nm_  – (Optional) Monomial to fill if provided\np_  – (Optional) Order of parameters in monomial if provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_desc_info","page":"For Developers","title":"GTPSA.mad_desc_info","text":"mad_desc_info(d::Ptr{Desc}, fp::Ptr{Cvoid})\n\nFor debugging.\n\nInput\n\nd  – Descriptor to debug\nfp – File to write to. If null, will write to stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#RTPSA","page":"For Developers","title":"RTPSA","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.RTPSA\nGTPSA.mad_tpsa_newd\nGTPSA.mad_tpsa_new\nGTPSA.mad_tpsa_del!\nGTPSA.mad_tpsa_desc\nGTPSA.mad_tpsa_uid!\nGTPSA.mad_tpsa_len\nGTPSA.mad_tpsa_nam\nGTPSA.mad_tpsa_ord\nGTPSA.mad_tpsa_ordv\nGTPSA.mad_tpsa_ordn\nGTPSA.mad_tpsa_copy!\nGTPSA.mad_tpsa_sclord!\nGTPSA.mad_tpsa_getord!\nGTPSA.mad_tpsa_cutord!\nGTPSA.mad_tpsa_maxord!\nGTPSA.mad_tpsa_convert!\nGTPSA.mad_tpsa_setvar!\nGTPSA.mad_tpsa_setval!\nGTPSA.mad_tpsa_setnam!\nGTPSA.mad_tpsa_clear!\nGTPSA.mad_tpsa_isnul\nGTPSA.mad_tpsa_mono!\nGTPSA.mad_tpsa_idxs\nGTPSA.mad_tpsa_idxm\nGTPSA.mad_tpsa_idxsm\nGTPSA.mad_tpsa_cycle!\nGTPSA.mad_tpsa_get0\nGTPSA.mad_tpsa_geti\nGTPSA.mad_tpsa_gets\nGTPSA.mad_tpsa_getm\nGTPSA.mad_tpsa_getsm\nGTPSA.mad_tpsa_set0!\nGTPSA.mad_tpsa_seti!\nGTPSA.mad_tpsa_sets!\nGTPSA.mad_tpsa_setm!\nGTPSA.mad_tpsa_setsm!\nGTPSA.mad_tpsa_getv!\nGTPSA.mad_tpsa_setv!\nGTPSA.mad_tpsa_equ\nGTPSA.mad_tpsa_dif!\nGTPSA.mad_tpsa_add!\nGTPSA.mad_tpsa_sub!\nGTPSA.mad_tpsa_mul!\nGTPSA.mad_tpsa_div!\nGTPSA.mad_tpsa_pow!\nGTPSA.mad_tpsa_powi!\nGTPSA.mad_tpsa_pown!\nGTPSA.mad_tpsa_nrm\nGTPSA.mad_tpsa_abs!\nGTPSA.mad_tpsa_sqrt!\nGTPSA.mad_tpsa_exp!\nGTPSA.mad_tpsa_log!\nGTPSA.mad_tpsa_sincos!\nGTPSA.mad_tpsa_sin!\nGTPSA.mad_tpsa_cos!\nGTPSA.mad_tpsa_tan!\nGTPSA.mad_tpsa_cot!\nGTPSA.mad_tpsa_sinc!\nGTPSA.mad_tpsa_sincosh!\nGTPSA.mad_tpsa_sinh!\nGTPSA.mad_tpsa_cosh!\nGTPSA.mad_tpsa_tanh!\nGTPSA.mad_tpsa_coth!\nGTPSA.mad_tpsa_sinhc!\nGTPSA.mad_tpsa_asin!\nGTPSA.mad_tpsa_acos!\nGTPSA.mad_tpsa_atan!\nGTPSA.mad_tpsa_acot!\nGTPSA.mad_tpsa_asinc!\nGTPSA.mad_tpsa_asinh!\nGTPSA.mad_tpsa_acosh!\nGTPSA.mad_tpsa_atanh!\nGTPSA.mad_tpsa_acoth!\nGTPSA.mad_tpsa_asinhc!\nGTPSA.mad_tpsa_erf!\nGTPSA.mad_tpsa_erfc!\nGTPSA.mad_tpsa_acc!\nGTPSA.mad_tpsa_scl!\nGTPSA.mad_tpsa_inv!\nGTPSA.mad_tpsa_invsqrt!\nGTPSA.mad_tpsa_unit!\nGTPSA.mad_tpsa_atan2!\nGTPSA.mad_tpsa_hypot!\nGTPSA.mad_tpsa_hypot3!\nGTPSA.mad_tpsa_integ!\nGTPSA.mad_tpsa_deriv!\nGTPSA.mad_tpsa_derivm!\nGTPSA.mad_tpsa_poisbra!\nGTPSA.mad_tpsa_taylor!\nGTPSA.mad_tpsa_axpb!\nGTPSA.mad_tpsa_axpbypc!\nGTPSA.mad_tpsa_axypb!\nGTPSA.mad_tpsa_axypbzpc!\nGTPSA.mad_tpsa_axypbvwpc!\nGTPSA.mad_tpsa_ax2pby2pcz2!\nGTPSA.mad_tpsa_axpsqrtbpcx2!\nGTPSA.mad_tpsa_logaxpsqrtbpcx2!\nGTPSA.mad_tpsa_logxdy!\nGTPSA.mad_tpsa_vec2fld!\nGTPSA.mad_tpsa_fld2vec!\nGTPSA.mad_tpsa_fgrad!\nGTPSA.mad_tpsa_liebra!\nGTPSA.mad_tpsa_exppb!\nGTPSA.mad_tpsa_logpb!\nGTPSA.mad_tpsa_mnrm\nGTPSA.mad_tpsa_minv!\nGTPSA.mad_tpsa_pminv!\nGTPSA.mad_tpsa_compose!\nGTPSA.mad_tpsa_translate!\nGTPSA.mad_tpsa_eval!\nGTPSA.mad_tpsa_mconv!\nGTPSA.mad_tpsa_print\nGTPSA.mad_tpsa_scan\nGTPSA.mad_tpsa_scan_hdr\nGTPSA.mad_tpsa_scan_coef!\nGTPSA.mad_tpsa_debug\nGTPSA.mad_tpsa_isvalid\nGTPSA.mad_tpsa_init!","category":"page"},{"location":"devel/#GTPSA.RTPSA","page":"For Developers","title":"GTPSA.RTPSA","text":"`RTPSA`\n\nThis is a 1-to-1 struct for the C definition tpsa (real TPSA) in GTPSA.\n\nFields\n\nd::Ptr{Cvoid}             – Ptr to tpsa descriptor\nuid::Cint                 – Special user field for external use (and padding)\nmo::Cuchar                – max ord (allocated)\nlo::Cuchar                – lowest used ord\nhi::Cuchar                – highest used ord\nnz::Culonglong            – zero/nonzero homogenous polynomials. Note: Int64 if 64 bit compiled C code, else 32 bit\nnam::NTuple{NAMSZ,Cuchar} – tpsa name max string length 16 NAMSZ\ncoef::Ptr{Cdouble}        – warning: must be identical to ctpsa up to coef excluded                                                                                                  \n\n\n\n\n\n","category":"type"},{"location":"devel/#GTPSA.mad_tpsa_newd","page":"For Developers","title":"GTPSA.mad_tpsa_newd","text":"mad_tpsa_newd(d::Ptr{Desc}, mo::Cuchar)::Ptr{RTPSA}\n\nCreates a TPSA defined by the specified descriptor and maximum order. If MAD_TPSA_DEFAULT  is passed for mo, the mo defined in the descriptor is used. If mo > d_mo, then mo = d_mo.\n\nInput\n\nd  – Descriptor\nmo – Maximum order\n\nOutput\n\nt  – New TPSA defined by the descriptor\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_new","page":"For Developers","title":"GTPSA.mad_tpsa_new","text":"mad_tpsa_new(t::Ptr{RTPSA}, mo::Cuchar)::Ptr{RTPSA}\n\nCreates a blank TPSA with same number of variables/parameters of the inputted TPSA,  with maximum order specified by mo. If MAD_TPSA_SAME is passed for mo, the mo  currently in t is used for the created TPSA. Ok with t=(tpsa_t*)ctpsa\n\nInput\n\nt   – TPSA\nmo  – Maximum order of new TPSA\n\nOutput\n\nret – New blank TPSA with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_del!","page":"For Developers","title":"GTPSA.mad_tpsa_del!","text":"mad_tpsa_del!(t::Ptr{RTPSA})\n\nCalls the destructor for the TPSA.\n\nInput\n\nt – TPSA to destruct\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_desc","page":"For Developers","title":"GTPSA.mad_tpsa_desc","text":"mad_tpsa_desc(t::Ptr{RTPSA})::Ptr{Desc}\n\nGets the descriptor for the TPSA.\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Descriptor for the RTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_uid!","page":"For Developers","title":"GTPSA.mad_tpsa_uid!","text":"mad_tpsa_uid!(t::Ptr{RTPSA}, uid_::Cint)::Cint\n\nSets the TPSA uid if uid_ != 0, and returns the current (previous if set) TPSA uid. \n\nInput\n\nt    – TPSA\nuid_ – uid to set in the TPSA if uid_ != 0\n\nOutput\n\nret  – Current (previous if set) TPSA uid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_len","page":"For Developers","title":"GTPSA.mad_tpsa_len","text":"mad_tpsa_len(t::Ptr{RTPSA})::Cint\n\nGets the length of the TPSA itself (e.g. the descriptor may be order 10 but TPSA may only be order 2)\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Length of RTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_nam","page":"For Developers","title":"GTPSA.mad_tpsa_nam","text":"mad_tpsa_nam(t::Ptr{RTPSA})::Cstring\n\nGet the name of the TPSA.\n\nInput\n\nt    – TPSA\n\nOutput\n\nret  – Name of RTPSA (null terminated in C)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ord","page":"For Developers","title":"GTPSA.mad_tpsa_ord","text":"mad_tpsa_ord(t::Ptr{RTPSA})::Cuchar\n\nGets the TPSA order.\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ordv","page":"For Developers","title":"GTPSA.mad_tpsa_ordv","text":"mad_tpsa_ordv(t::Ptr{RTPSA}, ts::Ptr{RTPSA}...)::Cuchar\n\nReturns maximum order of all TPSAs provided.\n\nInput\n\nt  – TPSA\nts – Variable number of TPSAs passed as parameters\n\nOutput\n\nmo – Maximum order of all TPSAs provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ordn","page":"For Developers","title":"GTPSA.mad_tpsa_ordn","text":"mad_tpsa_ordn(n::Cint, t::Vector{Ptr{RTPSA}})::Cuchar\n\nReturns the max order of all TPSAs in t.\n\nInput\n\nn  – Number of TPSAs\nt  – Array of TPSAs \n\nOutput\n\nmo – Maximum order of all TPSAs\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_copy!","page":"For Developers","title":"GTPSA.mad_tpsa_copy!","text":"mad_tpsa_copy!(t::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nMakes a copy of the TPSA t to r.\n\nInput\n\nt – Source TPSA\n\nOutput\n\nr – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sclord!","page":"For Developers","title":"GTPSA.mad_tpsa_sclord!","text":"mad_tpsa_sclord!(t::Ptr{RTPSA}, r::Ptr{RTPSA}, inv::Cuchar, prm::Cuchar)\n\nScales all coefficients by order. If inv == 0, scales coefficients by order (derivation), else  scales coefficients by 1/order (integration).\n\nInput\n\nt   – Source TPSA\ninv – Put order up, divide, scale by inv of value of order\nprm – Parameters flag. If set to 0x0, the scaling excludes the order of the parameters in the monomials. Else, scaling is with total order of monomial\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getord!","page":"For Developers","title":"GTPSA.mad_tpsa_getord!","text":"mad_tpsa_getord!(t::Ptr{RTPSA}, r::Ptr{RTPSA}, ord::Cuchar)\n\nExtract one homogeneous polynomial of the given order\n\nInput\n\nt  – Source TPSA\nord – Order to retrieve\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cutord!","page":"For Developers","title":"GTPSA.mad_tpsa_cutord!","text":"mad_tpsa_cutord!(t::Ptr{RTPSA}, r::Ptr{RTPSA}, ord::Cint)\n\nCuts the TPSA off at the given order and above, or if ord is negative, will cut orders below  abs(ord) (e.g. if ord = -3, then orders 0-3 are cut off).\n\nInput\n\nt   – Source TPSA\nord – Cut order: 0..-ord or ord..mo\n\nOutput\n\nr   – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_maxord!","page":"For Developers","title":"GTPSA.mad_tpsa_maxord!","text":"mad_tpsa_maxord!(t::Ptr{RTPSA}, n::Cint, idx_::Vector{Cint})::Cint\n\nReturns the index to the monomial with maximum abs(coefficient) in the TPSA for all orders 0 to n. If idx_  is provided, it is filled with the indices for the maximum abs(coefficient) monomial for each order up to n. \n\nInput\n\nt    – TPSA\nn    – Highest order to include in finding the maximum abs(coefficient) in the TPSA, length of idx_ if provided\n\nOutput\n\nidx_ – (Optional) If provided, is filled with indices to the monomial for each order up to n with maximum abs(coefficient)\nmi   – Index to the monomial in the TPSA with maximum abs(coefficient)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_convert!","page":"For Developers","title":"GTPSA.mad_tpsa_convert!","text":"mad_tpsa_convert!(t::Ptr{RTPSA}, r::Ptr{RTPSA}, n::Cint, t2r_::Vector{Cint}, pb::Cint)\n\nGeneral function to convert TPSAs to different orders and reshuffle canonical coordinates. The destination TPSA will  be of order n, and optionally have the variable reshuffling defined by t2r_ and poisson bracket sign. e.g. if  t2r_ = {1,2,3,4,6,5} and pb = -1, canonical coordinates 6 and 5 are swapped and the new 5th canonical coordinate  will be negated. Useful for comparing with different differential algebra packages.\n\nInput\n\nt    – Source TPSA\nn    – Length of vector\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nr    – Destination TPSA with specified order and canonical coordinate reshuffling.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setvar!","page":"For Developers","title":"GTPSA.mad_tpsa_setvar!","text":"mad_tpsa_setvar!(t::Ptr{RTPSA}, v::Cdouble, iv::Cint, scl_::Cdouble)\n\nSets the 0th and 1st order values for the specified variable, and sets the rest of the variables/parameters to 0\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\niv   – Variable index\nscl_ – 1st order variable value (typically will be 1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setval!","page":"For Developers","title":"GTPSA.mad_tpsa_setval!","text":"mad_tpsa_setval!(t::Ptr{RTPSA}, v::Cdouble)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0).\n\nInput\n\nt – TPSA to set to scalar\nv – Scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setnam!","page":"For Developers","title":"GTPSA.mad_tpsa_setnam!","text":"mad_tpsa_setnam!(t::Ptr{RTPSA}, nam::Cstring)\n\nSets the name of the RTPSA.\n\nInput\n\nt   – TPSA\nnam – Name to set for RTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_clear!","page":"For Developers","title":"GTPSA.mad_tpsa_clear!","text":"mad_tpsa_clear!(t::Ptr{RTPSA})\n\nClears the TPSA (reset to 0)\n\nInput\n\nt – TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_isnul","page":"For Developers","title":"GTPSA.mad_tpsa_isnul","text":"mad_tpsa_isnul(t::Ptr{RTPSA})::Cuchar\n\nChecks if TPSA is 0 or not\n\nInput\n\nt    – TPSA to check\n\nOutput\n\nret  – True or false\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mono!","page":"For Developers","title":"GTPSA.mad_tpsa_mono!","text":"mad_tpsa_mono!(t::Ptr{RTPSA}, i::Cint, n::Cint, m_::Vector{Cuchar}, p_::Vector{Cuchar})::Cuchar\n\nReturns the order of the monomial at index i in the TPSA and optionally the monomial at that index is returned in m_  and the order of parameters in the monomial in p_\n\nInput\n\nt   – TPSA\ni   – Index valid in TPSA\nn   – Length of monomial\n\nOutput\n\nm_  – (Optional) Monomial at index i in TPSA\np_  – (Optional) Order of parameters in monomial\nret – Order of monomial in TPSA at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxs","page":"For Developers","title":"GTPSA.mad_tpsa_idxs","text":"mad_tpsa_idxs(t::Ptr{RTPSA}, n::Cint, s::Cstring)::Cint\n\nReturns index of monomial in the TPSA given the monomial as string. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxm","page":"For Developers","title":"GTPSA.mad_tpsa_idxm","text":"mad_tpsa_idxm(t::Ptr{RTPSA}, n::Cint, m::Vector{Cuchar})::Cint\n\nReturns index of monomial in the TPSA given the monomial as a byte array\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as byte array\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_idxsm","page":"For Developers","title":"GTPSA.mad_tpsa_idxsm","text":"mad_tpsa_idxsm(t::Ptr{RTPSA}, n::Cint, m::Vector{Cint})::Cint\n\nReturns index of monomial in the TPSA given the monomial as a sparse monomial. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as sparse monomial\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cycle!","page":"For Developers","title":"GTPSA.mad_tpsa_cycle!","text":"mad_tpsa_cycle!(t::Ptr{RTPSA}, i::Cint, n::Cint, m_::Vector{Cuchar}, v_::Ref{Cdouble})::Cint\n\nUsed for scanning through each nonzero monomial in the TPSA. Given a starting index (-1 if starting at 0), will  optionally fill monomial m_ with the monomial at index i and the value at v_ with the monomials coefficient, and  return the next NONZERO monomial index in the TPSA. This is useful for building an iterator through the TPSA.\n\nInput\n\nt  – TPSA to scan\ni  – Index to start from (-1 to start at 0)\nn  – Length of monomial\nm_ – (Optional) Monomial to be filled if provided\nv_ – (Optional) Pointer to value of coefficient\n\nOutput\n\ni  – Index of next nonzero monomial in the TPSA, or -1 if reached the end\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_get0","page":"For Developers","title":"GTPSA.mad_tpsa_get0","text":"mad_tpsa_get0(t::Ptr{RTPSA})::Cdouble\n\nGets the 0th order (scalar) value of the TPSA\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Scalar value of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_geti","page":"For Developers","title":"GTPSA.mad_tpsa_geti","text":"mad_tpsa_geti(t::Ptr{RTPSA}, i::Cint)::Cdouble\n\nGets the coefficient of the monomial at index i. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\ni   – Monomial index\n\nOutput\n\nret – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_gets","page":"For Developers","title":"GTPSA.mad_tpsa_gets","text":"mad_tpsa_gets(t::Ptr{RTPSA}, n::Cint, s::Cstring)::Cdouble\n\nGets the coefficient of the monomial s defined as a string. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Coefficient of monomial s in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getm","page":"For Developers","title":"GTPSA.mad_tpsa_getm","text":"mad_tpsa_getm(t::Ptr{RTPSA}, n::Cint, m::Vector{Cuchar})::Cdouble\n\nGets the coefficient of the monomial m defined as a byte array. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as byte array\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getsm","page":"For Developers","title":"GTPSA.mad_tpsa_getsm","text":"mad_tpsa_getsm(t::Ptr{RTPSA}, n::Cint, m::Vector{Cint})::Cdouble\n\nGets the coefficient of the monomial m defined as a sparse monomial. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as sparse monomial\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_set0!","page":"For Developers","title":"GTPSA.mad_tpsa_set0!","text":"mad_tpsa_set0!(t::Ptr{RTPSA}, a::Cdouble, b::Cdouble)\n\nSets the 0th order coefficient (scalar part of TPSA) according to coef[0] = a*coef[0] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\na – Scaling of current 0th order value\nb – Constant added to current 0th order value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_seti!","page":"For Developers","title":"GTPSA.mad_tpsa_seti!","text":"mad_tpsa_seti!(t::Ptr{RTPSA}, i::Cint, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\ni – Index of monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sets!","page":"For Developers","title":"GTPSA.mad_tpsa_sets!","text":"mad_tpsa_sets!(t::Ptr{RTPSA}, n::Cint, s::Cstring, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setm!","page":"For Developers","title":"GTPSA.mad_tpsa_setm!","text":"mad_tpsa_setm!(t::Ptr{RTPSA}, n::Cint, m::Vector{Cuchar}, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setsm!","page":"For Developers","title":"GTPSA.mad_tpsa_setsm!","text":"mad_tpsa_setsm!(t::Ptr{RTPSA}, n::Cint, m::Vector{Cint}, a::Cdouble, b::Cdouble)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_getv!","page":"For Developers","title":"GTPSA.mad_tpsa_getv!","text":"mad_tpsa_getv!(t::Ptr{RTPSA}, i::Cint, n::Cint, v::Vector{Cdouble})\n\nVectorized getter of the coefficients for monomials with indices i..i+n. Useful for extracting the 1st order parts of  a TPSA to construct a matrix (i = 1, n = nv+np = nn). \n\nInput\n\nt – TPSA\ni – Starting index of monomials to get coefficients\nn – Number of monomials to get coefficients of starting at i\n\nOutput\n\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_setv!","page":"For Developers","title":"GTPSA.mad_tpsa_setv!","text":"mad_tpsa_setv!(t::Ptr{RTPSA}, i::Cint, n::Cint, v::Vector{Cdouble})\n\nVectorized setter of the coefficients for monomials with indices i..i+n. Useful for putting a matrix into a map.\n\nInput\n\nt – TPSA\ni – Starting index of monomials to set coefficients\nn – Number of monomials to set coefficients of starting at i\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_equ","page":"For Developers","title":"GTPSA.mad_tpsa_equ","text":"mad_tpsa_equ(a::Ptr{RTPSA}, b::Ptr{RTPSA}, tol_::Cdouble)::Cuchar\n\nChecks if the TPSAs a and b are equal within the specified tolerance tol_. If tol_ is not specified, DBL_GTPSA.show_epsILON is used.\n\nInput\n\na    – TPSA a\nb    – TPSA b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_dif!","page":"For Developers","title":"GTPSA.mad_tpsa_dif!","text":"mad_tpsa_dif!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nFor each homogeneous polynomial in TPSAs a and b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_add!","page":"For Developers","title":"GTPSA.mad_tpsa_add!","text":"mad_tpsa_add!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a + b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sub!","page":"For Developers","title":"GTPSA.mad_tpsa_sub!","text":"mad_tpsa_sub!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a - b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mul!","page":"For Developers","title":"GTPSA.mad_tpsa_mul!","text":"mad_tpsa_mul!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a * b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_div!","page":"For Developers","title":"GTPSA.mad_tpsa_div!","text":"mad_tpsa_div!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a / b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pow!","page":"For Developers","title":"GTPSA.mad_tpsa_pow!","text":"mad_tpsa_pow!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a ^ b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_powi!","page":"For Developers","title":"GTPSA.mad_tpsa_powi!","text":"mad_tpsa_powi!(a::Ptr{RTPSA}, n::Cint, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a ^ n where n is an integer.\n\nInput\n\na – Source TPSA a\nn – Integer power\n\nOutput\n\nc – Destination TPSA c = a ^ n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pown!","page":"For Developers","title":"GTPSA.mad_tpsa_pown!","text":"mad_tpsa_pown!(a::Ptr{RTPSA}, v::Cdouble, c::Ptr{RTPSA})\n\nSets the destination TPSA c = a ^ v where v is of double precision.\n\nInput\n\na – Source TPSA a\nv – \"double\" precision power\n\nOutput\n\nc – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_nrm","page":"For Developers","title":"GTPSA.mad_tpsa_nrm","text":"mad_tpsa_nrm(a::Ptr{RTPSA})::Cdouble\n\nCalculates the 1-norm of TPSA a (sum of abs of all coefficients)\n\nInput\n\na   – TPSA\n\nOutput\n\nnrm – 1-Norm of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_abs!","page":"For Developers","title":"GTPSA.mad_tpsa_abs!","text":"mad_tpsa_abs!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the absolute value of TPSA a. Specifically, the  result contains a TPSA with the abs of all coefficients.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = |a|\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sqrt!","page":"For Developers","title":"GTPSA.mad_tpsa_sqrt!","text":"mad_tpsa_sqrt!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the sqrt of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_exp!","page":"For Developers","title":"GTPSA.mad_tpsa_exp!","text":"mad_tpsa_exp!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the exponential of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = exp(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_log!","page":"For Developers","title":"GTPSA.mad_tpsa_log!","text":"mad_tpsa_log!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the log of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = log(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sincos!","page":"For Developers","title":"GTPSA.mad_tpsa_sincos!","text":"mad_tpsa_sincos!(a::Ptr{RTPSA}, s::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA s = sin(a) and TPSA c = cos(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sin(a)\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sin!","page":"For Developers","title":"GTPSA.mad_tpsa_sin!","text":"mad_tpsa_sin!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the sin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cos!","page":"For Developers","title":"GTPSA.mad_tpsa_cos!","text":"mad_tpsa_cos!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the cos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_tan!","page":"For Developers","title":"GTPSA.mad_tpsa_tan!","text":"mad_tpsa_tan!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the tan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cot!","page":"For Developers","title":"GTPSA.mad_tpsa_cot!","text":"mad_tpsa_cot!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the cot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinc!","page":"For Developers","title":"GTPSA.mad_tpsa_sinc!","text":"mad_tpsa_sinc!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the sinc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sincosh!","page":"For Developers","title":"GTPSA.mad_tpsa_sincosh!","text":"mad_tpsa_sincosh!(a::Ptr{RTPSA}, s::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA s = sinh(a) and TPSA c = cosh(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sinh(a)\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinh!","page":"For Developers","title":"GTPSA.mad_tpsa_sinh!","text":"mad_tpsa_sinh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the sinh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_cosh!","page":"For Developers","title":"GTPSA.mad_tpsa_cosh!","text":"mad_tpsa_cosh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the cosh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_tanh!","page":"For Developers","title":"GTPSA.mad_tpsa_tanh!","text":"mad_tpsa_tanh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the tanh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_coth!","page":"For Developers","title":"GTPSA.mad_tpsa_coth!","text":"mad_tpsa_coth!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the coth of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = coth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_sinhc!","page":"For Developers","title":"GTPSA.mad_tpsa_sinhc!","text":"mad_tpsa_sinhc!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the sinhc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asin!","page":"For Developers","title":"GTPSA.mad_tpsa_asin!","text":"mad_tpsa_asin!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the asin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acos!","page":"For Developers","title":"GTPSA.mad_tpsa_acos!","text":"mad_tpsa_acos!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the acos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atan!","page":"For Developers","title":"GTPSA.mad_tpsa_atan!","text":"mad_tpsa_atan!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the atan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acot!","page":"For Developers","title":"GTPSA.mad_tpsa_acot!","text":"mad_tpsa_acot!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the acot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinc!","page":"For Developers","title":"GTPSA.mad_tpsa_asinc!","text":"mad_tpsa_asinc!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the asinc(a) = asin(a)/a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinc(a) = asin(a)/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinh!","page":"For Developers","title":"GTPSA.mad_tpsa_asinh!","text":"mad_tpsa_asinh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the asinh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = asinh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acosh!","page":"For Developers","title":"GTPSA.mad_tpsa_acosh!","text":"mad_tpsa_acosh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the acosh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = acosh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atanh!","page":"For Developers","title":"GTPSA.mad_tpsa_atanh!","text":"mad_tpsa_atanh!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the atanh of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = atanh(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acoth!","page":"For Developers","title":"GTPSA.mad_tpsa_acoth!","text":"mad_tpsa_acoth!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the acoth of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = acoth(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_asinhc!","page":"For Developers","title":"GTPSA.mad_tpsa_asinhc!","text":"mad_tpsa_asinhc!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the asinhc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = asinhc(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_erf!","page":"For Developers","title":"GTPSA.mad_tpsa_erf!","text":"mad_tpsa_erf!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the erf of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = erf(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_erfc!","page":"For Developers","title":"GTPSA.mad_tpsa_erfc!","text":"mad_tpsa_erfc!(a::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nSets TPSA c to the erfc of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA `c = erfc(a)'\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_acc!","page":"For Developers","title":"GTPSA.mad_tpsa_acc!","text":"mad_tpsa_acc!(a::Ptr{RTPSA}, v::Cdouble, c::Ptr{RTPSA})\n\nAdds a*v to TPSA c. Aliasing OK.\n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scl!","page":"For Developers","title":"GTPSA.mad_tpsa_scl!","text":"mad_tpsa_scl!(a::Ptr{RTPSA}, v::Cdouble, c::Ptr{RTPSA})\n\nSets TPSA c to v*a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_inv!","page":"For Developers","title":"GTPSA.mad_tpsa_inv!","text":"mad_tpsa_inv!(a::Ptr{RTPSA},  v::Cdouble, c::Ptr{RTPSA})\n\nSets TPSA c to v/a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_invsqrt!","page":"For Developers","title":"GTPSA.mad_tpsa_invsqrt!","text":"mad_tpsa_invsqrt!(a::Ptr{RTPSA}, v::Cdouble, c::Ptr{RTPSA})\n\nSets TPSA c to v/sqrt(a). \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_unit!","page":"For Developers","title":"GTPSA.mad_tpsa_unit!","text":"mad_tpsa_unit!(x::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nInterpreting TPSA as a vector, gets the \"unit vector\", e.g. r = x/norm(x).  May be useful for checking for convergence.\n\nInput\n\nx – Source TPSA x\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_atan2!","page":"For Developers","title":"GTPSA.mad_tpsa_atan2!","text":"mad_tpsa_atan2!(y::Ptr{RTPSA}, x::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nSets TPSA r to atan2(y,x)\n\nInput\n\ny – Source TPSA y\nx – Source TPSA x\n\nOutput\n\nr – Destination TPSA r = atan2(y,x)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_hypot!","page":"For Developers","title":"GTPSA.mad_tpsa_hypot!","text":"mad_tpsa_hypot!(x::Ptr{RTPSA}, y::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nSets TPSA r to sqrt(x^2+y^2). Used to oversimplify polymorphism in code but not optimized\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_hypot3!","page":"For Developers","title":"GTPSA.mad_tpsa_hypot3!","text":"mad_tpsa_hypot3!(x::Ptr{RTPSA}, y::Ptr{RTPSA}, z::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nSets TPSA r to sqrt(x^2+y^2+z^2). Does NOT allow for r = x, y, z !!!\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\nz – Source TPSA z\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2+z^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_integ!","page":"For Developers","title":"GTPSA.mad_tpsa_integ!","text":"mad_tpsa_integ!(a::Ptr{RTPSA}, c::Ptr{RTPSA}, iv::Cint)\n\nIntegrates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to integrate\niv – Index of variable to integrate over (e.g. integrate over x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_deriv!","page":"For Developers","title":"GTPSA.mad_tpsa_deriv!","text":"mad_tpsa_deriv!(a::Ptr{RTPSA}, c::Ptr{RTPSA}, iv::Cint)\n\nDifferentiates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to differentiate\niv – Index of variable to take derivative wrt to (e.g. derivative wrt x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_derivm!","page":"For Developers","title":"GTPSA.mad_tpsa_derivm!","text":"mad_tpsa_derivm!(a::Ptr{RTPSA}, c::Ptr{RTPSA}, n::Cint, m::Vector{Cuchar})\n\nDifferentiates TPSA with respect to the monomial defined by byte array m.\n\nInput\n\na – Source TPSA to differentiate\nn – Length of monomial to differentiate wrt\nm – Monomial to take derivative wrt\n\nOutput\n\nc – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_poisbra!","page":"For Developers","title":"GTPSA.mad_tpsa_poisbra!","text":"mad_tpsa_poisbra!(a::Ptr{RTPSA}, b::Ptr{RTPSA}, c::Ptr{RTPSA}, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPSAs a and b.\n\nInput\n\na  – Source TPSA a\nb  – Source TPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_taylor!","page":"For Developers","title":"GTPSA.mad_tpsa_taylor!","text":"mad_tpsa_taylor!(a::Ptr{RTPSA}, n::Cint, coef::Vector{Cdouble}, c::Ptr{RTPSA})\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0 is the scalar part of TPSA a.\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpb!","page":"For Developers","title":"GTPSA.mad_tpsa_axpb!","text":"mad_tpsa_axpb!(a::Cdouble, x::Ptr{RTPSA}, b::Cdouble, r::Ptr{RTPSA})\n\nr = a*x + b\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpbypc!","page":"For Developers","title":"GTPSA.mad_tpsa_axpbypc!","text":"mad_tpsa_axpbypc!(a::Cdouble, x::Ptr{RTPSA}, b::Cdouble, y::Ptr{RTPSA}, c::Cdouble, r::Ptr{RTPSA})\n\nr = a*x + b*y + c\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypb!","page":"For Developers","title":"GTPSA.mad_tpsa_axypb!","text":"mad_tpsa_axypb!(a::Cdouble, x::Ptr{RTPSA}, y::Ptr{RTPSA}, b::Cdouble, r::Ptr{RTPSA})\n\nr = a*x*y + b\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypbzpc!","page":"For Developers","title":"GTPSA.mad_tpsa_axypbzpc!","text":"mad_tpsa_axypbzpc!(a::Cdouble, x::Ptr{RTPSA}, y::Ptr{RTPSA}, b::Cdouble, z::Ptr{RTPSA}, c::Cdouble, r::Ptr{RTPSA})\n\nr = a*x*y + b*z + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nz – TPSA z\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axypbvwpc!","page":"For Developers","title":"GTPSA.mad_tpsa_axypbvwpc!","text":"mad_tpsa_axypbvwpc!(a::Cdouble, x::Ptr{RTPSA}, y::Ptr{RTPSA}, b::Cdouble, v::Ptr{RTPSA}, w::Ptr{RTPSA}, c::Cdouble, r::Ptr{RTPSA})\n\nr = a*x*y + b*v*w + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nv – TPSA v\nw – TPSA w\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_ax2pby2pcz2!","page":"For Developers","title":"GTPSA.mad_tpsa_ax2pby2pcz2!","text":"mad_tpsa_ax2pby2pcz2!(a::Cdouble, x::Ptr{RTPSA}, b::Cdouble, y::Ptr{RTPSA}, c::Cdouble, z::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nr = a*x^2 + b*y^2 + c*z^2\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\nz – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_axpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_tpsa_axpsqrtbpcx2!","text":"mad_tpsa_axpsqrtbpcx2!(x::Ptr{RTPSA}, a::Cdouble, b::Cdouble, c::Cdouble, r::Ptr{RTPSA})\n\nr = a*x + sqrt(b + c*x^2)\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logaxpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_tpsa_logaxpsqrtbpcx2!","text":"mad_tpsa_logaxpsqrtbpcx2!(x::Ptr{RTPSA}, a::Cdouble, b::Cdouble, c::Cdouble, r::Ptr{RTPSA})\n\nr = log(a*x + sqrt(b + c*x^2))\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logxdy!","page":"For Developers","title":"GTPSA.mad_tpsa_logxdy!","text":"mad_tpsa_logxdy!(x::Ptr{RTPSA}, y::Ptr{RTPSA}, r::Ptr{RTPSA})\n\nr = log(x / y)\n\nInput\n\nx – TPSA x\ny – TPSA y\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_vec2fld!","page":"For Developers","title":"GTPSA.mad_tpsa_vec2fld!","text":"mad_tpsa_vec2fld!(na::Cint, a::Ptr{RTPSA}, mc::Vector{Ptr{RTPSA}})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [da/dp1, -da/dq1, ...]\n\nInput\n\nna  – Number of TPSA in mc consistent with number of variables in a\na   – Hamiltonian as a TPSA\n\nOutput\n\nmc  – Vector field derived from a using Hamilton's equations \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_fld2vec!","page":"For Developers","title":"GTPSA.mad_tpsa_fld2vec!","text":"mad_tpsa_fld2vec!(na::Cint, ma::Vector{Ptr{RTPSA}}, c::Ptr{RTPSA})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the Hamiltonian one obtains  from ther vector field (in the form [da/dp1, -da/dq1, ...])\n\nInput\n\nna  – Number of TPSA in ma consistent with number of variables in c\nma  – Vector field \n\nOutput\n\nc   – Hamiltonian as a TPSA derived from the vector field ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_fgrad!","page":"For Developers","title":"GTPSA.mad_tpsa_fgrad!","text":"mad_tpsa_fgrad!(na::Cint, ma::Vector{Ptr{RTPSA}}, b::Ptr{RTPSA}, c::Ptr{RTPSA})\n\nCalculates dot(ma, grad(b))\n\nInput\n\nna – Length of ma consistent with number of variables in b\nma – Vector of TPSA\nb  – TPSA\n\nOutput\n\nc  – dot(ma, grad(b))\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_liebra!","page":"For Developers","title":"GTPSA.mad_tpsa_liebra!","text":"mad_tpsa_liebra!(na::Cint, ma::Vector{Ptr{RTPSA}}, mb::Vector{Ptr{RTPSA}}, mc::Vector{Ptr{RTPSA}})\n\nComputes the Lie bracket of the vector fields ma and mb, defined as  sumi mai (dmb/dxi) - mbi (dma/dx_i).\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_exppb!","page":"For Developers","title":"GTPSA.mad_tpsa_exppb!","text":"mad_tpsa_exppb!(na::Cint, ma::Vector{Ptr{RTPSA}}, mb::Vector{Ptr{RTPSA}}, mc::Vector{Ptr{RTPSA}})\n\nComputes the exponential of fgrad of the vector fields ma and mb, literally exppb(ma, mb) = mb + fgrad(ma, mb) + fgrad(ma, fgrad(ma, mb))/2! + ...\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_logpb!","page":"For Developers","title":"GTPSA.mad_tpsa_logpb!","text":"mad_tpsa_logpb!(na::Cint, ma::Vector{Ptr{RTPSA}}, mb::Vector{Ptr{RTPSA}}, mc::Vector{Ptr{RTPSA}})\n\nComputes the log of the Poisson bracket of the vector of TPSA ma and mb; the result  is the vector field F used to evolve to ma from mb.\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mnrm","page":"For Developers","title":"GTPSA.mad_tpsa_mnrm","text":"mad_tpsa_mnrm(na::Cint, ma::Vector{Ptr{RTPSA}})::Cdouble\n\nComputes the norm of the map (sum of absolute value of coefficients of all TPSAs in the map).\n\nInput\n\nna  – Number of TPSAs in the map\nma  – map ma\n\nOutput\n\nnrm – Norm of map (sum of absolute value of coefficients of all TPSAs in the map)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_minv!","page":"For Developers","title":"GTPSA.mad_tpsa_minv!","text":"mad_tpsa_minv!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, mc::Vector{Ptr{RTPSA}})\n\nInverts the map. To include the parameters in the inversion, na = nn and the output map  length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\n\nOutput\n\nmc – Inversion of map ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_pminv!","page":"For Developers","title":"GTPSA.mad_tpsa_pminv!","text":"mad_tpsa_pminv!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, mc::Vector{Ptr{RTPSA}}, select::Vector{Cint})\n\nComputes the partial inverse of the map with only the selected variables, specified by 0s or 1s in select. To include the parameters in the inversion, na = nn and the output map length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\nselect – Array of 0s or 1s defining which variables to do inverse on (atleast same size as na)'\n\nOutput\n\nmc     – Partially inverted map using variables specified as 1 in the select array\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_compose!","page":"For Developers","title":"GTPSA.mad_tpsa_compose!","text":"mad_tpsa_compose!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, mb::Vector{Ptr{RTPSA}}, mc::Vector{Ptr{RTPSA}})\n\nComposes two maps.\n\nInput\n\nna – Number of TPSAs in map ma\nma – map ma\nnb – Number of TPSAs in map mb\nmb – map mb\n\nOutput\n\nmc – Composition of maps ma and mb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_translate!","page":"For Developers","title":"GTPSA.mad_tpsa_translate!","text":"mad_tpsa_translate!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, tb::Vector{Cdouble}, mc::Vector{Ptr{RTPSA}})\n\nTranslates the expansion point of the map by the amount tb.\n\nInput\n\nna – Number of TPSAS in the map\nma – map ma\nnb – Length of tb\ntb – Vector of amount to translate for each variable\n\nOutput\n\nmc – Map evaluated at the new point translated tb from the original evaluation point\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_eval!","page":"For Developers","title":"GTPSA.mad_tpsa_eval!","text":"mad_tpsa_eval!(na::Cint, ma::Vector{Ptr{RTPSA}}, nb::Cint, tb::Vector{Cdouble}, tc::Vector{Cdouble})\n\nEvaluates the map at the point tb\n\nInput\n\nna – Number of TPSAs in the map\nma – map ma\nnb – Length of tb\ntb – Point at which to evaluate the map\n\nOutput\n\ntc – Values for each TPSA in the map evaluated at the point tb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_mconv!","page":"For Developers","title":"GTPSA.mad_tpsa_mconv!","text":"mad_tpsa_mconv!(na::Cint, ma::Vector{Ptr{RTPSA}}, nc::Cint, mc::Vector{Ptr{RTPSA}}, n::Cint, t2r_::Vector{Cint}, pb::Cint)\n\nEquivalent to mad_tpsa_convert, but applies the conversion to all TPSAs in the map ma.\n\nInput\n\nna   – Number of TPSAs in the map\nma   – map ma\nnc   – Number of TPSAs in the output map mc\nn    – Length of vector (size of t2r_)\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nmc   – map mc with specified conversions \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_print","page":"For Developers","title":"GTPSA.mad_tpsa_print","text":"mad_tpsa_print(t::Ptr{RTPSA}, name_::Cstring, eps_::Cdouble, nohdr_::Cint, stream_::Ptr{Cvoid})\n\nPrints the TPSA coefficients with precision eps_. If nohdr_ is not zero,  the header is not printed. \n\nInput\n\nt       – TPSA to print\nname_   – (Optional) Name of TPSA\neps_    – (Optional) Precision to output\nnohdr_  – (Optional) If True, no header is printed\nstream_ – (Optional) FILE pointer of output stream. Default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan","page":"For Developers","title":"GTPSA.mad_tpsa_scan","text":"mad_tpsa_scan(stream_::Ptr{Cvoid})::Ptr{RTPSA}\n\nScans in a TPSA from the stream_.\n\nInput\n\nstream_ – (Optional) I/O stream from which to read the TPSA, default is stdin\n\nOutput\n\nt       – TPSA scanned from I/O stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan_hdr","page":"For Developers","title":"GTPSA.mad_tpsa_scan_hdr","text":"mad_tpsa_scan_hdr(kind_::Ref{Cint}, name_::Ptr{Cuchar}, stream_::Ptr{Cvoid})::Ptr{Desc}\n\nRead TPSA header. Returns descriptor for TPSA given the header. This is useful for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nkind_   – (Optional) Real or complex TPSA, or detect automatically if not provided.\nname_   – (Optional) Name of TPSA\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nret     – Descriptor for the TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_scan_coef!","page":"For Developers","title":"GTPSA.mad_tpsa_scan_coef!","text":"mad_tpsa_scan_coef!(t::Ptr{RTPSA}, stream_::Ptr{Cvoid})\n\nRead TPSA coefficients into TPSA t. This should be used with mad_tpsa_scan_hdr for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nt       – TPSA with coefficients scanned from stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_debug","page":"For Developers","title":"GTPSA.mad_tpsa_debug","text":"mad_tpsa_debug(t::Ptr{RTPSA}, name_::Cstring, fnam_::Cstring, line_::Cint, stream_::Ptr{Cvoid})\n\nPrints TPSA with all information of data structure.\n\nInput\n\nt       – TPSA\nname_   – (Optional) Name of TPSA\nfnam_   – (Optional) File name to print to\nline_   – (Optional) Line number in file to start at\nstream_ – (Optional) I/O stream to print to, default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_isvalid","page":"For Developers","title":"GTPSA.mad_tpsa_isvalid","text":"mad_tpsa_isvalid(t::Ptr{RTPSA})::Cuchar\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_tpsa_init!","page":"For Developers","title":"GTPSA.mad_tpsa_init!","text":"mad_tpsa_init(t::Ptr{RTPSA}, d::Ptr{Desc}, mo::Cuchar)::Ptr{RTPSA}\n\nUnsafe initialization of an already existing TPSA t with maximum order mo to the descriptor d. mo must be less than  the maximum order of the descriptor. t is modified in place and also returned.\n\nInput\n\nt  – TPSA to initialize to descriptor d\nd  – Descriptor\nmo – Maximum order of the TPSA (must be less than maximum order of the descriptor)\n\nOutput\n\nt  – TPSA initialized to descriptor d with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#CTPSA","page":"For Developers","title":"CTPSA","text":"","category":"section"},{"location":"devel/","page":"For Developers","title":"For Developers","text":"GTPSA.CTPSA\nGTPSA.mad_ctpsa_newd\nGTPSA.mad_ctpsa_new\nGTPSA.mad_ctpsa_del!\nGTPSA.mad_ctpsa_desc\nGTPSA.mad_ctpsa_uid!\nGTPSA.mad_ctpsa_len\nGTPSA.mad_ctpsa_nam\nGTPSA.mad_ctpsa_ord\nGTPSA.mad_ctpsa_ordv\nGTPSA.mad_ctpsa_ordn\nGTPSA.mad_ctpsa_copy!\nGTPSA.mad_ctpsa_sclord!\nGTPSA.mad_ctpsa_getord!\nGTPSA.mad_ctpsa_cutord!\nGTPSA.mad_ctpsa_maxord\nGTPSA.mad_ctpsa_convert!\nGTPSA.mad_ctpsa_setvar!\nGTPSA.mad_ctpsa_setvar_r!\nGTPSA.mad_ctpsa_setval!\nGTPSA.mad_ctpsa_setval_r!\nGTPSA.mad_ctpsa_setnam!\nGTPSA.mad_ctpsa_clear!\nGTPSA.mad_ctpsa_isnul\nGTPSA.mad_ctpsa_cplx!\nGTPSA.mad_ctpsa_real!\nGTPSA.mad_ctpsa_imag!\nGTPSA.mad_ctpsa_cabs!\nGTPSA.mad_ctpsa_carg!\nGTPSA.mad_ctpsa_unit!\nGTPSA.mad_ctpsa_rect!\nGTPSA.mad_ctpsa_polar!\nGTPSA.mad_ctpsa_mono!\nGTPSA.mad_ctpsa_idxs\nGTPSA.mad_ctpsa_idxm\nGTPSA.mad_ctpsa_idxsm\nGTPSA.mad_ctpsa_cycle!\nGTPSA.mad_ctpsa_get0\nGTPSA.mad_ctpsa_geti\nGTPSA.mad_ctpsa_gets\nGTPSA.mad_ctpsa_getm\nGTPSA.mad_ctpsa_getsm\nGTPSA.mad_ctpsa_set0!\nGTPSA.mad_ctpsa_seti!\nGTPSA.mad_ctpsa_sets!\nGTPSA.mad_ctpsa_setm!\nGTPSA.mad_ctpsa_setsm!\nGTPSA.mad_ctpsa_get0_r!\nGTPSA.mad_ctpsa_geti_r!\nGTPSA.mad_ctpsa_gets_r!\nGTPSA.mad_ctpsa_getm_r!\nGTPSA.mad_ctpsa_getsm_r!\nGTPSA.mad_ctpsa_set0_r!\nGTPSA.mad_ctpsa_seti_r!\nGTPSA.mad_ctpsa_sets_r!\nGTPSA.mad_ctpsa_setm_r!\nGTPSA.mad_ctpsa_setsm_r!\nGTPSA.mad_ctpsa_getv!\nGTPSA.mad_ctpsa_setv!\nGTPSA.mad_ctpsa_equ\nGTPSA.mad_ctpsa_dif!\nGTPSA.mad_ctpsa_add!\nGTPSA.mad_ctpsa_sub!\nGTPSA.mad_ctpsa_mul!\nGTPSA.mad_ctpsa_div!\nGTPSA.mad_ctpsa_pow!\nGTPSA.mad_ctpsa_powi!\nGTPSA.mad_ctpsa_pown!\nGTPSA.mad_ctpsa_pown_r!\nGTPSA.mad_ctpsa_equt\nGTPSA.mad_ctpsa_dift!\nGTPSA.mad_ctpsa_tdif!\nGTPSA.mad_ctpsa_addt!\nGTPSA.mad_ctpsa_subt!\nGTPSA.mad_ctpsa_tsub!\nGTPSA.mad_ctpsa_mult!\nGTPSA.mad_ctpsa_divt!\nGTPSA.mad_ctpsa_tdiv!\nGTPSA.mad_ctpsa_powt!\nGTPSA.mad_ctpsa_tpow!\nGTPSA.mad_ctpsa_nrm\nGTPSA.mad_ctpsa_conj!\nGTPSA.mad_ctpsa_sqrt!\nGTPSA.mad_ctpsa_exp!\nGTPSA.mad_ctpsa_log!\nGTPSA.mad_ctpsa_sincos!\nGTPSA.mad_ctpsa_sin!\nGTPSA.mad_ctpsa_cos!\nGTPSA.mad_ctpsa_tan!\nGTPSA.mad_ctpsa_cot!\nGTPSA.mad_ctpsa_sinc!\nGTPSA.mad_ctpsa_sincosh!\nGTPSA.mad_ctpsa_sinh!\nGTPSA.mad_ctpsa_cosh!\nGTPSA.mad_ctpsa_tanh!\nGTPSA.mad_ctpsa_coth!\nGTPSA.mad_ctpsa_sinhc!\nGTPSA.mad_ctpsa_asin!\nGTPSA.mad_ctpsa_acos!\nGTPSA.mad_ctpsa_atan!\nGTPSA.mad_ctpsa_acot!\nGTPSA.mad_ctpsa_asinc!\nGTPSA.mad_ctpsa_asinh!\nGTPSA.mad_ctpsa_acosh!\nGTPSA.mad_ctpsa_atanh!\nGTPSA.mad_ctpsa_acoth!\nGTPSA.mad_ctpsa_asinhc!\nGTPSA.mad_ctpsa_erf!\nGTPSA.mad_ctpsa_erfc!\nGTPSA.mad_ctpsa_acc!\nGTPSA.mad_ctpsa_scl!\nGTPSA.mad_ctpsa_inv!\nGTPSA.mad_ctpsa_invsqrt!\nGTPSA.mad_ctpsa_hypot!\nGTPSA.mad_ctpsa_hypot3!\nGTPSA.mad_ctpsa_integ!\nGTPSA.mad_ctpsa_deriv!\nGTPSA.mad_ctpsa_derivm!\nGTPSA.mad_ctpsa_poisbra!\nGTPSA.mad_ctpsa_taylor!\nGTPSA.mad_ctpsa_poisbrat!\nGTPSA.mad_ctpsa_tpoisbra!\nGTPSA.mad_ctpsa_acc_r!\nGTPSA.mad_ctpsa_scl_r!\nGTPSA.mad_ctpsa_inv_r!\nGTPSA.mad_ctpsa_invsqrt_r!\nGTPSA.mad_ctpsa_axpb!\nGTPSA.mad_ctpsa_axpbypc!\nGTPSA.mad_ctpsa_axypb!\nGTPSA.mad_ctpsa_axypbzpc!\nGTPSA.mad_ctpsa_axypbvwpc!\nGTPSA.mad_ctpsa_ax2pby2pcz2!\nGTPSA.mad_ctpsa_axpsqrtbpcx2!\nGTPSA.mad_ctpsa_logaxpsqrtbpcx2!\nGTPSA.mad_ctpsa_logxdy!\nGTPSA.mad_ctpsa_axpb_r!\nGTPSA.mad_ctpsa_axpbypc_r!\nGTPSA.mad_ctpsa_axypb_r!\nGTPSA.mad_ctpsa_axypbzpc_r!\nGTPSA.mad_ctpsa_axypbvwpc_r!\nGTPSA.mad_ctpsa_ax2pby2pcz2_r!\nGTPSA.mad_ctpsa_axpsqrtbpcx2_r!\nGTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!\nGTPSA.mad_ctpsa_vec2fld!\nGTPSA.mad_ctpsa_fld2vec!\nGTPSA.mad_ctpsa_fgrad!\nGTPSA.mad_ctpsa_liebra!\nGTPSA.mad_ctpsa_exppb!\nGTPSA.mad_ctpsa_logpb!\nGTPSA.mad_ctpsa_mnrm\nGTPSA.mad_ctpsa_minv!\nGTPSA.mad_ctpsa_pminv!\nGTPSA.mad_ctpsa_compose!\nGTPSA.mad_ctpsa_translate!\nGTPSA.mad_ctpsa_eval!\nGTPSA.mad_ctpsa_mconv!\nGTPSA.mad_ctpsa_print\nGTPSA.mad_ctpsa_scan\nGTPSA.mad_ctpsa_scan_hdr\nGTPSA.mad_ctpsa_scan_coef!\nGTPSA.mad_ctpsa_debug\nGTPSA.mad_ctpsa_isvalid\nGTPSA.mad_ctpsa_init!","category":"page"},{"location":"devel/#GTPSA.CTPSA","page":"For Developers","title":"GTPSA.CTPSA","text":"`CTPSA`\n\nThis is a 1-to-1 struct for the C definition ctpsa (complex TPSA) in GTPSA.\n\nFields\n\nd::Ptr{Cvoid}             – Pointer to Desc for this CTPSA\nuid::Cint                 – Special user field for external use (and padding)\nmo::Cuchar                – max ord (allocated)\nlo::Cuchar                – lowest used ord\nhi::Cuchar                – highest used ord\nnz::Culonglong            – zero/nonzero homogenous polynomials. Note: Int64 if 64 bit compiled C code, else 32 bit\nnam::NTuple{NAMSZ,Cuchar} – tpsa name max string length 16 NAMSZ\ncoef::Ptr{ComplexF64}     – warning: must be identical to ctpsa up to coef excluded                                                                                                  \n\n\n\n\n\n","category":"type"},{"location":"devel/#GTPSA.mad_ctpsa_newd","page":"For Developers","title":"GTPSA.mad_ctpsa_newd","text":"mad_ctpsa_newd(d::Ptr{Desc}, mo::Cuchar)::Ptr{CTPSA}\n\nCreates a complex TPSA defined by the specified descriptor and maximum order. If MADCTPSADEFAULT  is passed for mo, the mo defined in the descriptor is used. If mo > d_mo, then mo = d_mo.\n\nInput\n\nd  – Descriptor\nmo – Maximum order\n\nOutput\n\nt  – New complex TPSA defined by the descriptor\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_new","page":"For Developers","title":"GTPSA.mad_ctpsa_new","text":"mad_ctpsa_new(t::Ptr{CTPSA}, mo::Cuchar)::Ptr{CTPSA}\n\nCreates a blank TPSA with same number of variables/parameters of the inputted TPSA,  with maximum order specified by mo. If MAD_TPSA_SAME is passed for mo, the mo  currently in t is used for the created TPSA. Ok with t=(tpsa_t*)ctpsa\n\nInput\n\nt   – TPSA\nmo  – Maximum order of new TPSA\n\nOutput\n\nret – New blank TPSA with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_del!","page":"For Developers","title":"GTPSA.mad_ctpsa_del!","text":"mad_ctpsa_del!(t::Ptr{CTPSA})\n\nCalls the destructor for the complex TPSA.\n\nInput\n\nt – Complex TPSA to destruct\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_desc","page":"For Developers","title":"GTPSA.mad_ctpsa_desc","text":"mad_ctpsa_desc(t::Ptr{CTPSA})::Ptr{Desc}\n\nGets the descriptor for the complex TPSA.\n\nInput\n\nt   – Complex TPSA\n\nOutput\n\nret – Descriptor for the TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_uid!","page":"For Developers","title":"GTPSA.mad_ctpsa_uid!","text":"mad_ctpsa_uid!(t::Ptr{CTPSA}, uid_::Cint)::Cint\n\nSets the TPSA uid if uid_ != 0, and returns the current (previous if set) TPSA uid. \n\nInput\n\nt    – Complex TPSA\nuid_ – uid to set in the TPSA if uid_ != 0\n\nOutput\n\nret  – Current (previous if set) TPSA uid\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_len","page":"For Developers","title":"GTPSA.mad_ctpsa_len","text":"mad_ctpsa_len(t::Ptr{CTPSA})::Cint\n\nGets the length of the TPSA itself (e.g. the descriptor may be order 10 but TPSA may only be order 2)\n\nInput\n\nt   – Complex TPSA\n\nOutput\n\nret – Length of CTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_nam","page":"For Developers","title":"GTPSA.mad_ctpsa_nam","text":"mad_ctpsa_nam(t::Ptr{CTPSA})::Cstring\n\nGet the name of the TPSA.\n\nInput\n\nt    – Complex TPSA\n\nOutput\n\nret  – Name of CTPSA (Null terminated in C)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ord","page":"For Developers","title":"GTPSA.mad_ctpsa_ord","text":"mad_ctpsa_ord(t::Ptr{CTPSA})::Cuchar\n\nGets the TPSA order.\n\nInput\n\nt   – Complex TPSA\n\nOutput\n\nret – Order of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ordv","page":"For Developers","title":"GTPSA.mad_ctpsa_ordv","text":"mad_ctpsa_ordv(t::Ptr{CTPSA}, ts::Ptr{CTPSA}...)::Cuchar\n\nReturns maximum order of all TPSAs provided.\n\nInput\n\nt  – TPSA\nts – Variable number of TPSAs passed as parameters\n\nOutput\n\nmo – Maximum order of all TPSAs provided\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ordn","page":"For Developers","title":"GTPSA.mad_ctpsa_ordn","text":"mad_ctpsa_ordn(n::Cint, t::Vector{Ptr{CTPSA}})::Cuchar\n\nReturns the max order of all TPSAs in t.\n\nInput\n\nn  – Number of TPSAs\nt  – Array of TPSAs \n\nOutput\n\nmo – Maximum order of all TPSAs\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_copy!","page":"For Developers","title":"GTPSA.mad_ctpsa_copy!","text":"mad_ctpsa_copy!(t::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nMakes a copy of the complex TPSA t to r.\n\nInput\n\nt – Source complex TPSA\n\nOutput\n\nr – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sclord!","page":"For Developers","title":"GTPSA.mad_ctpsa_sclord!","text":"mad_ctpsa_sclord!(t::Ptr{CTPSA}, r::Ptr{CTPSA}, inv::Cuchar, prm::Cuchar)\n\nScales all coefficients by order. If inv == 0, scales coefficients by order (derivation), else scales coefficients  by 1/order (integration).\n\nInput\n\nt   – Source complex TPSA\ninv – Put order up, divide, scale by inv of value of order\nprm – Parameters flag. If set to 0x0, the scaling excludes the order of the parameters in the monomials. Else, scaling is with total order of monomial\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getord!","page":"For Developers","title":"GTPSA.mad_ctpsa_getord!","text":"mad_ctpsa_getord!(t::Ptr{CTPSA}, r::Ptr{CTPSA}, ord::Cuchar)\n\nExtract one homogeneous polynomial of the given order\n\nInput\n\nt  – Sourcecomplex TPSA\nord – Order to retrieve\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cutord!","page":"For Developers","title":"GTPSA.mad_ctpsa_cutord!","text":"mad_ctpsa_cutord!(t::Ptr{CTPSA}, r::Ptr{CTPSA}, ord::Cint)\n\nCuts the TPSA off at the given order and above, or if ord is negative, will cut orders below  abs(ord) (e.g. if ord = -3, then orders 0-3 are cut off).\n\nInput\n\nt   – Source complex TPSA\nord – Cut order: 0..-ord or ord..mo\n\nOutput\n\nr   – Destination complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_maxord","page":"For Developers","title":"GTPSA.mad_ctpsa_maxord","text":"mad_ctpsa_maxord(t::Ptr{CTPSA}, n::Cint, idx_::Vector{Cint})::Cint\n\nReturns the index to the monomial with maximum abs(coefficient) in the TPSA for all orders 0 to n. If idx_  is provided, it is filled with the indices for the maximum abs(coefficient) monomial for each order up to n. \n\nInput\n\nt    – Complex TPSA\nn    – Highest order to include in finding the maximum abs(coefficient) in the TPSA, length of idx_ if provided\n\nOutput\n\nidx_ – (Optional) If provided, is filled with indices to the monomial for each order up to n with maximum abs(coefficient)\nmi   – Index to the monomial in the TPSA with maximum abs(coefficient)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_convert!","page":"For Developers","title":"GTPSA.mad_ctpsa_convert!","text":"mad_ctpsa_convert!(t::Ptr{CTPSA}, r::Ptr{CTPSA}, n::Cint, t2r_::Vector{Cint}, pb::Cint)\n\nGeneral function to convert TPSAs to different orders and reshuffle canonical coordinates. The destination TPSA will  be of order n, and optionally have the variable reshuffling defined by t2r_ and poisson bracket sign. e.g. if  t2r_ = {1,2,3,4,6,5} and pb = -1, canonical coordinates 6 and 5 are swapped and the new 5th canonical coordinate  will be negated. Useful for comparing with different differential algebra packages.\n\nInput\n\nt    – Source complex TPSA\nn    – Length of vector\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nr    – Destination complex TPSA with specified order and canonical coordinate reshuffling.\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setvar!","page":"For Developers","title":"GTPSA.mad_ctpsa_setvar!","text":"madctpsasetvar!(t::Ptr{CTPSA}, v::ComplexF64, iv::Cint, scl_::ComplexF64)\n\nSets the 0th and 1st order values for the specified variable, and sets the rest of the variables to 0\n\nInput\n\nt    – TPSA\nv    – 0th order value (coefficient)\niv   – Variable index\nscl_ – 1st order variable value (typically will be 1)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setvar_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setvar_r!","text":"mad_ctpsa_setvar_r!(t::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble, iv::Cint, scl_re_::Cdouble, scl_im_::Cdouble)\n\nSets the 0th and 1st order values for the specified variable. Equivalent to mad_ctpsa_setvar but without complex-by-value arguments.\n\nInput\n\nt       – Complex TPSA\nv_re    – Real part of 0th order value\nv_im    – Imaginary part of 0th order value\niv      – Variable index\nscl_re_ – (Optional) Real part of 1st order variable value\nscl_im_ – (Optional)Imaginary part of 1st order variable value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setval!","page":"For Developers","title":"GTPSA.mad_ctpsa_setval!","text":"mad_ctpsa_setval!(t::Ptr{CTPSA}, v::ComplexF64)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0).\n\nInput\n\nt – TPSA to set to scalar\nv – Scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setval_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setval_r!","text":"mad_ctpsa_setval_r!(t::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble)\n\nSets the scalar part of the TPSA to v and all other values to 0 (sets the TPSA order to 0). Equivalent to mad_ctpsa_setval but without complex-by-value arguments.\n\nInput\n\nt    – TPSA to set to scalar\nv_re – Real part of scalar value to set TPSA\nv_im – Imaginary part of scalar value to set TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setnam!","page":"For Developers","title":"GTPSA.mad_ctpsa_setnam!","text":"mad_ctpsa_setnam!(t::Ptr{CTPSA}, nam::Cstring)\n\nSets the name of the CTPSA.\n\nInput\n\nt   – Complex TPSA\nnam – Name to set for CTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_clear!","page":"For Developers","title":"GTPSA.mad_ctpsa_clear!","text":"mad_ctpsa_clear!(t::Ptr{CTPSA})\n\nClears the TPSA (reset to 0)\n\nInput\n\nt – Complex TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_isnul","page":"For Developers","title":"GTPSA.mad_ctpsa_isnul","text":"mad_ctpsa_isnul(t::Ptr{CTPSA})::Cuchar\n\nChecks if TPSA is 0 or not\n\nInput\n\nt    – Complex TPSA to check\n\nOutput\n\nret  – True or false\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cplx!","page":"For Developers","title":"GTPSA.mad_ctpsa_cplx!","text":"mad_ctpsa_cplx!(re_::Ptr{RTPSA}, im_::Ptr{RTPSA}, r::Ptr{CTPSA})\n\nCreates a CTPSA with real and imaginary parts from the RTPSAs re_ and im_ respectively.\n\nInput\n\nre_ – Real part of CTPSA to make\nim_ – Imaginary part of CTPSA to make\n\nOutput\n\nr   – Destination CTPSA with r = re_ + im*im_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_real!","page":"For Developers","title":"GTPSA.mad_ctpsa_real!","text":"mad_ctpsa_real!(t::Ptr{CTPSA}, r::Ptr{RTPSA})\n\nSets the RTPSA r equal to the real part of CTPSA t.\n\nInput\n\nt – Source CTPSA\n\nOutput\n\nr – Destination RTPSA with r = Re(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_imag!","page":"For Developers","title":"GTPSA.mad_ctpsa_imag!","text":"mad_ctpsa_imag!(t::Ptr{CTPSA}, r::Ptr{RTPSA})\n\nSets the RTPSA r equal to the imaginary part of CTPSA t.\n\nInput\n\nt – Source CTPSA\n\nOutput\n\nr – Destination RTPSA with r = Im(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cabs!","page":"For Developers","title":"GTPSA.mad_ctpsa_cabs!","text":"mad_ctpsa_cabs!(t::Ptr{CTPSA}, r::Ptr{RTPSA})\n\nSets the RTPSA r equal to the aboslute value of CTPSA t. Specifically, the  result contains a TPSA with the abs of all coefficients.\n\nInput\n\nt – Source CTPSA\n\nOutput\n\nr – Destination RTPSA with r = |t|\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_carg!","page":"For Developers","title":"GTPSA.mad_ctpsa_carg!","text":"mad_ctpsa_carg!(t::Ptr{CTPSA}, r::Ptr{RTPSA})\n\nSets the RTPSA r equal to the argument (phase) of CTPSA t\n\nInput\n\nt – Source CTPSA\n\nOutput\n\nr – Destination RTPSA with r = carg(t)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_unit!","page":"For Developers","title":"GTPSA.mad_ctpsa_unit!","text":"mad_ctpsa_unit!(t::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nInterpreting TPSA a vector, gets the \"unit vector\", e.g. r = t/norm(t). May be useful for checking for convergence.\n\nInput\n\nt – Source TPSA x\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_rect!","page":"For Developers","title":"GTPSA.mad_ctpsa_rect!","text":"mad_ctpsa_rect!(t::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nSets r = Re(t)*cos(Im(t)) + im*Re(t)*sin(Im(t))\n\nInput\n\nt – Source CTPSA\nr – Destination CTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_polar!","page":"For Developers","title":"GTPSA.mad_ctpsa_polar!","text":"mad_ctpsa_polar!(t::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nSets r = |t| + im*atan2(Im(t), Re(t))\n\nInput\n\nt – Source CTPSA\nr – Destination CTPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mono!","page":"For Developers","title":"GTPSA.mad_ctpsa_mono!","text":"mad_ctpsa_mono!(t::Ptr{CTPSA}, i::Cint, n::Cint, m_::Vector{Cuchar}, p_::Vector{Cuchar})::Cuchar\n\nReturns the order of the monomial at index i in the TPSA and optionally the monomial at that index is returned in m_ and the order of parameters in the monomial in p_\n\nInput\n\nt   – TPSA\ni   – Index valid in TPSA\nn   – Length of monomial\n\nOutput\n\nm_  – (Optional) Monomial at index i in TPSA\np_  – (Optional) Order of parameters in monomial\nret – Order of monomial in TPSA a index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxs","page":"For Developers","title":"GTPSA.mad_ctpsa_idxs","text":"mad_ctpsa_idxs(t::Ptr{CTPSA}, n::Cint, s::Cstring)::Cint\n\nReturns index of monomial in the TPSA given the monomial as string. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as string\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxm","page":"For Developers","title":"GTPSA.mad_ctpsa_idxm","text":"mad_ctpsa_idxm(t::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar})::Cint\n\nReturns index of monomial in the TPSA given the monomial as a byte array. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as byte array\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_idxsm","page":"For Developers","title":"GTPSA.mad_ctpsa_idxsm","text":"mad_ctpsa_idxsm(t::Ptr{CTPSA}, n::Cint, m::Vector{Cint})::Cint\n\nReturns index of monomial in the TPSA given the monomial as a sparse monomial. This generally should not be used, as there  are no assumptions about which monomial is attached to which index.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\ns   – Monomial as sparse monomial\n\nOutput\n\nret – Index of monomial in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cycle!","page":"For Developers","title":"GTPSA.mad_ctpsa_cycle!","text":"mad_ctpsa_cycle!(t::Ptr{CTPSA}, i::Cint, n::Cint, m_::Vector{Cuchar}, v_::Ref{ComplexF64})::Cint\n\nUsed for scanning through each nonzero monomial in the TPSA. Given a starting index (-1 if starting at 0), will  optionally fill monomial m_ with the monomial at index i and the value at v_ with the monomials coefficient, and  return the next NONZERO monomial index in the TPSA. This is useful for building an iterator through the TPSA.\n\nInput\n\nt  – TPSA to scan\ni  – Index to start from (-1 to start at 0)\nn  – Size of monomial\nm_ – (Optional) Monomial to be filled if provided\nv_ – (Optional) Pointer to value of coefficient\n\nOutput\n\ni  – Index of next nonzero monomial in the TPSA, or -1 if reached the end\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_get0","page":"For Developers","title":"GTPSA.mad_ctpsa_get0","text":"mad_ctpsa_get0(t::Ptr{CTPSA})::ComplexF64\n\nGets the 0th order (scalar) value of the TPSA\n\nInput\n\nt   – TPSA\n\nOutput\n\nret – Scalar value of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_geti","page":"For Developers","title":"GTPSA.mad_ctpsa_geti","text":"mad_ctpsa_geti(t::Ptr{CTPSA}, i::Cint)::ComplexF64\n\nGets the coefficient of the monomial at index i.  Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\ni   – Monomial index\n\nOutput\n\nret – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_gets","page":"For Developers","title":"GTPSA.mad_ctpsa_gets","text":"mad_ctpsa_gets(t::Ptr{CTPSA}, n::Cint, s::Cstring)::ComplexF64\n\nGets the coefficient of the monomial s defined as a string. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Size of monomial\ns   – Monomial as string\n\nOutput\n\nret – Coefficient of monomial s in TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getm","page":"For Developers","title":"GTPSA.mad_ctpsa_getm","text":"mad_ctpsa_getm(t::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar})::ComplexF64\n\nGets the coefficient of the monomial m defined as a byte array. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as byte array\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getsm","page":"For Developers","title":"GTPSA.mad_ctpsa_getsm","text":"mad_ctpsa_getsm(t::Ptr{CTPSA}, n::Cint, m::Vector{Cint})::ComplexF64\n\nGets the coefficient of the monomial m defined as a sparse monomial. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt   – TPSA\nn   – Length of monomial\nm   – Monomial as sparse monomial\n\nOutput\n\nret – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_set0!","page":"For Developers","title":"GTPSA.mad_ctpsa_set0!","text":"mad_ctpsa_set0!(t::Ptr{CTPSA}, a::ComplexF64, b::ComplexF64)\n\nSets the 0th order coefficient (scalar part of TPSA) according to coef[0] = a*coef[0] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\na – Scaling of current 0th order value\nb – Constant added to current 0th order value\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_seti!","page":"For Developers","title":"GTPSA.mad_ctpsa_seti!","text":"mad_ctpsa_seti!(t::Ptr{CTPSA}, i::Cint, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\ni – Index of monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sets!","page":"For Developers","title":"GTPSA.mad_ctpsa_sets!","text":"mad_ctpsa_sets!(t::Ptr{CTPSA}, n::Cint, s::Cstring, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setm!","page":"For Developers","title":"GTPSA.mad_ctpsa_setm!","text":"mad_ctpsa_setm!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar}, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setsm!","page":"For Developers","title":"GTPSA.mad_ctpsa_setsm!","text":"mad_ctpsa_setsm!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cint}, a::ComplexF64, b::ComplexF64)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na – Scaling of current coefficient\nb – Constant added to current coefficient\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_get0_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_get0_r!","text":"mad_ctpsa_get0_r!(t::Ptr{CTPSA}, r::Ref{ComplexF64})\n\nGets the 0th order (scalar) value of the TPSA in place.\n\nInput\n\nt – TPSA\n\nOutput\n\nr – Scalar value of TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_geti_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_geti_r!","text":"mad_ctpsa_geti_r!(t::Ptr{CTPSA}, i::Cint,  r::Ref{ComplexF64})\n\nGets the coefficient of the monomial at index i in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\ni – Monomial index\n\nOutput\n\nr – Coefficient of monomial at index i\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_gets_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_gets_r!","text":"mad_ctpsa_gets_r!(t::Ptr{CTPSA}, n::Cint, s::Cstring, r::Ref{ComplexF64})\n\nGets the coefficient of the monomial s defined as a string in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\n\nOutput\n\nr – Coefficient of monomial s in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_getm_r!","text":"mad_ctpsa_getm_r!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar}, r::Ref{ComplexF64})\n\nGets the coefficient of the monomial m defined as a byte array in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\n\nOutput\n\nr – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getsm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_getsm_r!","text":"mad_ctpsa_getsm_r!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cint}, r::Ref{ComplexF64})\n\nGets the coefficient of the monomial m defined as a sparse monomial in place. Generally should use mad_tpsa_cycle instead of this.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\n\nOutput\n\nr – Coefficient of monomial m in TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_set0_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_set0_r!","text":"mad_ctpsa_set0_r!(t::Ptr{CTPSA}, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the 0th order coefficient (scalar part of TPSA) according to coef[0] = a*coef[0] + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_set0 but without complex-by-value arguments.\n\nInput\n\nt    – TPSA\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_seti_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_seti_r!","text":"mad_ctpsa_seti_r!(t::Ptr{CTPSA}, i::Cint, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial at index i to coef[i] = a*coef[i] + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_seti but without complex-by-value arguments.\n\nInput\n\nt – TPSA\ni – Index of monomial\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sets_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_sets_r!","text":"mad_ctpsa_sets_r!(t::Ptr{CTPSA}, n::Cint, s::Cstring, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by string s to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_set but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\ns – Monomial as string\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setm_r!","text":"mad_ctpsa_setm_r!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar}, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by byte array m to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_setm but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as byte array\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setsm_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_setsm_r!","text":"mad_ctpsa_setsm_r!(t::Ptr{CTPSA}, n::Cint, m::Vector{Cint}, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble)\n\nSets the coefficient of monomial defined by sparse monomial m to coef = a*coef + b. Does not modify other values in TPSA. Equivalent to mad_ctpsa_setsm but without complex-by-value arguments.\n\nInput\n\nt – TPSA\nn – Length of monomial\nm – Monomial as sparse monomial\na_re – Real part of a\na_im – Imaginary part of a\nb_re – Real part of b\nb_im – Imaginary part of b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_getv!","page":"For Developers","title":"GTPSA.mad_ctpsa_getv!","text":"mad_ctpsa_getv!(t::Ptr{CTPSA}, i::Cint, n::Cint, v::Vector{ComplexF64})\n\nVectorized getter of the coefficients for monomials with indices i..i+n. Useful for extracting the 1st order parts of  a TPSA to construct a matrix (i = 1, n = nv+np = nn). \n\nInput\n\nt – TPSA\ni – Starting index of monomials to get coefficients\nn – Number of monomials to get coefficients of starting at i\n\nOutput\n\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_setv!","page":"For Developers","title":"GTPSA.mad_ctpsa_setv!","text":"mad_ctpsa_setv!(t::Ptr{CTPSA}, i::Cint, n::Cint, v::Vector{ComplexF64})\n\nVectorized setter of the coefficients for monomials with indices i..i+n. Useful for putting a matrix into a map.\n\nInput\n\nt – TPSA\ni – Starting index of monomials to set coefficients\nn – Number of monomials to set coefficients of starting at i\nv – Array of coefficients for monomials i..i+n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_equ","page":"For Developers","title":"GTPSA.mad_ctpsa_equ","text":"mad_ctpsa_equ(a::Ptr{CTPSA}, b::Ptr{CTPSA}, tol_::Cdouble)::Cuchar\n\nChecks if the TPSAs a and b are equal within the specified tolerance tol_. If tol_ is not specified, DBL_GTPSA.show_epsILON is used.\n\nInput\n\na    – TPSA a\nb    – TPSA b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_dif!","page":"For Developers","title":"GTPSA.mad_ctpsa_dif!","text":"mad_ctpsa_dif!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nFor each homogeneous polynomial in TPSAs a and b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_add!","page":"For Developers","title":"GTPSA.mad_ctpsa_add!","text":"mad_ctpsa_add!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a + b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sub!","page":"For Developers","title":"GTPSA.mad_ctpsa_sub!","text":"mad_ctpsa_sub!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a - b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mul!","page":"For Developers","title":"GTPSA.mad_ctpsa_mul!","text":"mad_ctpsa_mul!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a * b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_div!","page":"For Developers","title":"GTPSA.mad_ctpsa_div!","text":"mad_ctpsa_div!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a / b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pow!","page":"For Developers","title":"GTPSA.mad_ctpsa_pow!","text":"mad_ctpsa_pow!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a ^ b\n\nInput\n\na – Source TPSA a\nb – Source TPSA b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_powi!","page":"For Developers","title":"GTPSA.mad_ctpsa_powi!","text":"mad_ctpsa_powi!(a::Ptr{CTPSA}, n::Cint, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a ^ n where n is an integer.\n\nInput\n\na – Source TPSA a\nn – Integer power\n\nOutput\n\nc – Destination TPSA c = a ^ n\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pown!","page":"For Developers","title":"GTPSA.mad_ctpsa_pown!","text":"mad_ctpsa_pown!(a::Ptr{CTPSA}, v::ComplexF64, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a ^ v where v is of double precision.\n\nInput\n\na – Source TPSA a\nv – Power, ComplexF64\n\nOutput\n\nc – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pown_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_pown_r!","text":"mad_ctpsa_pown_r!(a::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble, c::Ptr{CTPSA})\n\nSets the destination TPSA c = a ^ v where v is of double precision. Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of power\nv_im – Imaginary part of power\n\nOutput\n\nc    – Destination TPSA c = a ^ v\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_equt","page":"For Developers","title":"GTPSA.mad_ctpsa_equt","text":"mad_ctpsa_equt(a::Ptr{CTPSA}, b::Ptr{RTPSA}, tol_::Cdouble)::Cuchar\n\nChecks if the CTPSA a is equal to the RTPSA b within the specified tolerance tol_  (internal real-to-complex conversion).\n\nInput\n\na    – CTPSA a\nb    – RTPSA b\ntol_ – (Optional) Difference below which the TPSAs are considered equal\n\nOutput\n\nret   - True if a == b within tol_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_dift!","page":"For Developers","title":"GTPSA.mad_ctpsa_dift!","text":"mad_ctpsa_dift!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nFor each homogeneous polynomial in CTPSA a and RTPSA b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tdif!","page":"For Developers","title":"GTPSA.mad_ctpsa_tdif!","text":"mad_ctpsa_tdif!(a::Ptr{RTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nFor each homogeneous polynomial in RTPSA a and CTPSA b, calculates either the relative error or absolute error for each order. If the maximum coefficient for a given order in a is > 1, the relative error is computed for that order. Else, the absolute  error is computed. This is very useful for comparing maps between codes or doing unit tests. In Julia, essentially:\n\nc_i = (a_i.-b_i)/maximum([abs.(a_i)...,1]) where a_i and b_i are vectors of the monomials for an order i\n\nInput\n\na – Source RTPSA a\nb – Source CTPSA b\n\nOutput\n\nc – Destination CTPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_addt!","page":"For Developers","title":"GTPSA.mad_ctpsa_addt!","text":"mad_ctpsa_addt!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a + b (internal real-to-complex conversion).\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c = a + b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_subt!","page":"For Developers","title":"GTPSA.mad_ctpsa_subt!","text":"mad_ctpsa_subt!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a - b (internal real-to-complex conversion).\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tsub!","page":"For Developers","title":"GTPSA.mad_ctpsa_tsub!","text":"mad_ctpsa_tsub!(a::Ptr{RTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a - b (internal real-to-complex conversion).\n\nInput\n\na – Source RTPSA a\nb – Source CTPSA b\n\nOutput\n\nc – Destination CTPSA c = a - b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mult!","page":"For Developers","title":"GTPSA.mad_ctpsa_mult!","text":"mad_ctpsa_mult!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a * b (internal real-to-complex conversion).\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c = a * b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_divt!","page":"For Developers","title":"GTPSA.mad_ctpsa_divt!","text":"mad_ctpsa_divt!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a / b (internal real-to-complex conversion).\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tdiv!","page":"For Developers","title":"GTPSA.mad_ctpsa_tdiv!","text":"mad_ctpsa_tdiv!(a::Ptr{RTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a / b (internal real-to-complex conversion).\n\nInput\n\na – Source RTPSA a\nb – Source CTPSA b\n\nOutput\n\nc – Destination CTPSA c = a / b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_powt!","page":"For Developers","title":"GTPSA.mad_ctpsa_powt!","text":"mad_ctpsa_powt!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a ^ b (internal real-to-complex conversion).\n\nInput\n\na – Source CTPSA a\nb – Source RTPSA b\n\nOutput\n\nc – Destination CTPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tpow!","page":"For Developers","title":"GTPSA.mad_ctpsa_tpow!","text":"mad_ctpsa_tpow!(a::Ptr{RTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets the destination CTPSA c = a ^ b (internal real-to-complex conversion).\n\nInput\n\na – Source RTPSA a\nb – Source CTPSA b\n\nOutput\n\nc – Destination TPSA c = a ^ b\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_nrm","page":"For Developers","title":"GTPSA.mad_ctpsa_nrm","text":"mad_ctpsa_nrm(a::Ptr{CTPSA})::Cdouble\n\nCalculates the 1-norm of TPSA a (sum of abs of all coefficients)\n\nInput\n\na   – TPSA\n\nOutput\n\nnrm – 1-Norm of TPSA a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_conj!","page":"For Developers","title":"GTPSA.mad_ctpsa_conj!","text":"mad_ctpsa_conj(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nCalculates the complex conjugate of of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = conj(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sqrt!","page":"For Developers","title":"GTPSA.mad_ctpsa_sqrt!","text":"mad_ctpsa_sqrt!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the sqrt of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_exp!","page":"For Developers","title":"GTPSA.mad_ctpsa_exp!","text":"mad_ctpsa_exp!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the exp of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = exp(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_log!","page":"For Developers","title":"GTPSA.mad_ctpsa_log!","text":"mad_ctpsa_log!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the log of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = log(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sincos!","page":"For Developers","title":"GTPSA.mad_ctpsa_sincos!","text":"mad_ctpsa_sincos!(a::Ptr{CTPSA}, s::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA s = sin(a) and TPSA c = cos(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sin(a)\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sin!","page":"For Developers","title":"GTPSA.mad_ctpsa_sin!","text":"mad_ctpsa_sin!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the sin of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cos!","page":"For Developers","title":"GTPSA.mad_ctpsa_cos!","text":"mad_ctpsa_cos!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the cos of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tan!","page":"For Developers","title":"GTPSA.mad_ctpsa_tan!","text":"mad_ctpsa_tan!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the tan of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cot!","page":"For Developers","title":"GTPSA.mad_ctpsa_cot!","text":"mad_ctpsa_cot!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the cot of TPSA a.\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinc!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinc!","text":"mad_ctpsa_sinc!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the sinc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sincosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_sincosh!","text":"mad_ctpsa_sincosh!(a::Ptr{CTPSA}, s::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA s = sinh(a) and TPSA c = cosh(a)\n\nInput\n\na – Source TPSA a\n\nOutput\n\ns – Destination TPSA s = sinh(a)\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinh!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinh!","text":"mad_ctpsa_sinh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the sinh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_cosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_cosh!","text":"mad_ctpsa_cosh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the cosh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = cosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tanh!","page":"For Developers","title":"GTPSA.mad_ctpsa_tanh!","text":"mad_ctpsa_tanh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the tanh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = tanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_coth!","page":"For Developers","title":"GTPSA.mad_ctpsa_coth!","text":"mad_ctpsa_coth!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the coth of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = coth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_sinhc!","page":"For Developers","title":"GTPSA.mad_ctpsa_sinhc!","text":"mad_ctpsa_sinhc!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the sinhc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = sinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asin!","page":"For Developers","title":"GTPSA.mad_ctpsa_asin!","text":"mad_ctpsa_asin!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the asin of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asin(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acos!","page":"For Developers","title":"GTPSA.mad_ctpsa_acos!","text":"mad_ctpsa_acos!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the acos of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acos(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_atan!","page":"For Developers","title":"GTPSA.mad_ctpsa_atan!","text":"mad_ctpsa_atan!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the atan of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atan(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acot!","page":"For Developers","title":"GTPSA.mad_ctpsa_acot!","text":"mad_ctpsa_acot!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the acot of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acot(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinc!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinc!","text":"mad_ctpsa_asinc!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the asinc(a) = asin(a)/a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinc(a) = asin(a)/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinh!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinh!","text":"mad_ctpsa_asinh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the asinh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acosh!","page":"For Developers","title":"GTPSA.mad_ctpsa_acosh!","text":"mad_ctpsa_acosh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the acosh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acosh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_atanh!","page":"For Developers","title":"GTPSA.mad_ctpsa_atanh!","text":"mad_ctpsa_atanh!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the atanh of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = atanh(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acoth!","page":"For Developers","title":"GTPSA.mad_ctpsa_acoth!","text":"mad_ctpsa_acoth!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the acoth of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = acoth(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_asinhc!","page":"For Developers","title":"GTPSA.mad_ctpsa_asinhc!","text":"mad_ctpsa_asinhc!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the asinhc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = asinhc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_erf!","page":"For Developers","title":"GTPSA.mad_ctpsa_erf!","text":"mad_ctpsa_erf!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the erf of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = erf(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_erfc!","page":"For Developers","title":"GTPSA.mad_ctpsa_erfc!","text":"mad_ctpsa_erfc!(a::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nSets TPSA c to the erfc of TPSA a\n\nInput\n\na – Source TPSA a\n\nOutput\n\nc – Destination TPSA c = erfc(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acc!","page":"For Developers","title":"GTPSA.mad_ctpsa_acc!","text":"mad_ctpsa_acc!(a::Ptr{CTPSA}, v::ComplexF64, c::Ptr{CTPSA})\n\nAdds a*v to TPSA c. Aliasing OK.\n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scl!","page":"For Developers","title":"GTPSA.mad_ctpsa_scl!","text":"mad_ctpsa_scl!(a::Ptr{CTPSA}, v::ComplexF64, c::Ptr{CTPSA})\n\nSets TPSA c to v*a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_inv!","page":"For Developers","title":"GTPSA.mad_ctpsa_inv!","text":"mad_ctpsa_inv!(a::Ptr{CTPSA},  v::ComplexF64, c::Ptr{CTPSA})\n\nSets TPSA c to v/a. \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_invsqrt!","page":"For Developers","title":"GTPSA.mad_ctpsa_invsqrt!","text":"mad_ctpsa_invsqrt!(a::Ptr{CTPSA}, v::ComplexF64, c::Ptr{CTPSA})\n\nSets TPSA c to v/sqrt(a). \n\nInput\n\na – Source TPSA a\nv – Scalar with double precision\n\nOutput\n\nc – Destination TPSA c = v/sqrt(a)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_hypot!","page":"For Developers","title":"GTPSA.mad_ctpsa_hypot!","text":"mad_ctpsa_hypot!(x::Ptr{CTPSA}, y::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nSets TPSA r to sqrt(real(x)^2+real(y)^2) + im*sqrt(imag(x)^2+imag(y)^2)\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\n\nOutput\n\nr – Destination TPSA sqrt(real(x)^2+real(y)^2) + im*sqrt(imag(x)^2+imag(y)^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_hypot3!","page":"For Developers","title":"GTPSA.mad_ctpsa_hypot3!","text":"mad_ctpsa_hypot3!(x::Ptr{CTPSA}, y::Ptr{CTPSA}, z::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nSets TPSA r to sqrt(x^2+y^2+z^2).  Does NOT allow for r = x, y, z !!!\n\nInput\n\nx – Source TPSA x\ny – Source TPSA y\nz – Source TPSA z\n\nOutput\n\nr – Destination TPSA r = sqrt(x^2+y^2+z^2)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_integ!","page":"For Developers","title":"GTPSA.mad_ctpsa_integ!","text":"mad_ctpsa_integ!(a::Ptr{CTPSA}, c::Ptr{CTPSA}, iv::Cint)\n\nIntegrates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to integrate\niv – Index of variable to integrate over (e.g. integrate over x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_deriv!","page":"For Developers","title":"GTPSA.mad_ctpsa_deriv!","text":"mad_ctpsa_deriv!(a::Ptr{CTPSA}, c::Ptr{CTPSA}, iv::Cint)\n\nDifferentiates TPSA with respect to the variable with index iv.\n\nInput\n\na  – Source TPSA to differentiate\niv – Index of variable to take derivative wrt to (e.g. derivative wrt x, iv = 1). \n\nOutput\n\nc  – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_derivm!","page":"For Developers","title":"GTPSA.mad_ctpsa_derivm!","text":"mad_ctpsa_derivm!(a::Ptr{CTPSA}, c::Ptr{CTPSA}, n::Cint, m::Vector{Cuchar})\n\nDifferentiates TPSA with respect to the monomial defined by byte array m.\n\nInput\n\na – Source TPSA to differentiate\nn – Length of monomial to differentiate wrt\nm – Monomial to take derivative wrt\n\nOutput\n\nc – Destination TPSA\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_poisbra!","page":"For Developers","title":"GTPSA.mad_ctpsa_poisbra!","text":"mad_ctpsa_poisbra!(a::Ptr{CTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA}, nv::Cint)\n\nSets TPSA c to the poisson bracket of TPSAs a and b.\n\nInput\n\na  – Source TPSA a\nb  – Source TPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination TPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_taylor!","page":"For Developers","title":"GTPSA.mad_ctpsa_taylor!","text":"mad_ctpsa_taylor!(a::Ptr{CTPSA}, n::Cint, coef::Vector{ComplexF64}, c::Ptr{CTPSA})\n\nComputes the result of the Taylor series up to order n-1 with Taylor coefficients coef for the scalar value in a. That is, c = coef[0] + coef[1]*a_0 + coef[2]*a_0^2 + ... where a_0 is the scalar part of TPSA a\n\nInput\n\na    – TPSA a\nn    – Order-1 of Taylor expansion, size of coef array\ncoef – Array of coefficients in Taylor s\nc    – Result\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_poisbrat!","page":"For Developers","title":"GTPSA.mad_ctpsa_poisbrat!","text":"mad_ctpsa_poisbrat!(a::Ptr{CTPSA}, b::Ptr{RTPSA}, c::Ptr{CTPSA}, nv::Cint)\n\nSets TPSA c to the poisson bracket of CTPSA aand RTPSA b (internal real-to-complex conversion).\n\nInput\n\na  – Source CTPSA a\nb  – Source RTPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination CTPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_tpoisbra!","page":"For Developers","title":"GTPSA.mad_ctpsa_tpoisbra!","text":"mad_ctpsa_tpoisbra!(a::Ptr{RTPSA}, b::Ptr{CTPSA}, c::Ptr{CTPSA}, nv::Cint)\n\nSets TPSA c to the poisson bracket of RTPSA a and CTPSA b (internal real-to-complex conversion).\n\nInput\n\na  – Source RTPSA a\nb  – Source CTPSA b\nnv – Number of variables in the TPSA\n\nOutput\n\nc  – Destination CTPSA c\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_acc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_acc_r!","text":"mad_ctpsa_acc_r!(a::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble, c::Ptr{CTPSA})\n\nAdds a*v to TPSA c. Aliasing OK. Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c += v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scl_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_scl_r!","text":"mad_ctpsa_scl_r!(a::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble,, c::Ptr{CTPSA})\n\nSets TPSA c to v*a.  Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_inv_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_inv_r!","text":"mad_ctpsa_inv_r!(a::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble, c::Ptr{CTPSA})\n\nSets TPSA c to v/a.  Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_invsqrt_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_invsqrt_r!","text":"mad_ctpsa_invsqrt_r!(a::Ptr{CTPSA}, v_re::Cdouble, v_im::Cdouble, c::Ptr{CTPSA})\n\nSets TPSA c to v/sqrt(a). Without complex-by-value arguments.\n\nInput\n\na    – Source TPSA a\nv_re – Real part of scalar with double precision\nv_im – Imaginary part of scalar with double precision\n\nOutput\n\nc    – Destination TPSA c = v*a\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpb!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpb!","text":"mad_ctpsa_axpb!(a::ComplexF64, x::Ptr{CTPSA}, b::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x + b\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpbypc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpbypc!","text":"mad_ctpsa_axpbypc!(a::ComplexF64, x::Ptr{CTPSA}, b::ComplexF64, y::Ptr{CTPSA}, c::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x+b*y+c\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypb!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypb!","text":"mad_ctpsa_axypb!(a::ComplexF64, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x*y + b\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbzpc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbzpc!","text":"mad_ctpsa_axypbzpc!(a::ComplexF64, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b::ComplexF64, z::Ptr{CTPSA}, c::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x*y + b*z + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nz – TPSA z\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbvwpc!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbvwpc!","text":"mad_ctpsa_axypbvwpc!(a::ComplexF64, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b::ComplexF64, v::Ptr{CTPSA}, w::Ptr{CTPSA}, c::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x*y + b*v*w + c\n\nInput\n\na – Scalar a\nx – TPSA x\ny – TPSA y\nb – Scalar b\nv – TPSA v\nw – TPSA w\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ax2pby2pcz2!","page":"For Developers","title":"GTPSA.mad_ctpsa_ax2pby2pcz2!","text":"mad_ctpsa_ax2pby2pcz2!(a::ComplexF64, x::Ptr{CTPSA}, b::ComplexF64, y::Ptr{CTPSA}, c::ComplexF64, z::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nr = a*x^2 + b*y^2 + c*z^2\n\nInput\n\na – Scalar a\nx – TPSA x\nb – Scalar b\ny – TPSA y\nc – Scalar c\nz – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpsqrtbpcx2!","text":"mad_ctpsa_axpsqrtbpcx2!(x::Ptr{CTPSA}, a::ComplexF64, b::ComplexF64, c::ComplexF64, r::Ptr{CTPSA})\n\nr = a*x + sqrt(b + c*x^2)\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logaxpsqrtbpcx2!","page":"For Developers","title":"GTPSA.mad_ctpsa_logaxpsqrtbpcx2!","text":"mad_ctpsa_logaxpsqrtbpcx2!(x::Ptr{CTPSA}, a::ComplexF64, b::ComplexF64, c::ComplexF64, r::Ptr{CTPSA})\n\nr = log(a*x + sqrt(b + c*x^2))\n\nInput\n\nx – TPSA x\na – Scalar a\nb – Scalar b\nc – Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logxdy!","page":"For Developers","title":"GTPSA.mad_ctpsa_logxdy!","text":"mad_ctpsa_logxdy!(x::Ptr{CTPSA}, y::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nr = log(x / y)\n\nInput\n\nx – TPSA x\ny – TPSA y\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpb_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpb_r!","text":"mad_ctpsa_axpb_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x + b. Same as mad_ctpsa_axpb without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpbypc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpbypc_r!","text":"mad_ctpsa_axpbypc_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, y::Ptr{CTPSA}, c_re::Cdouble, c_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x + b*y + c. Same as mad_ctpsa_axpbypc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\ny    – TPSA y\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypb_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypb_r!","text":"mad_ctpsa_axypb_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x*y + b. Same as mad_ctpsa_axypb without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbzpc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbzpc_r!","text":"mad_ctpsa_axypbzpc_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, z::Ptr{CTPSA}, c_re::Cdouble, c_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x*y + b*z + c. Same as mad_ctpsa_axypbzpc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nz    – TPSA z\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axypbvwpc_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axypbvwpc_r!","text":"mad_ctpsa_axypbvwpc_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, y::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, v::Ptr{CTPSA}, w::Ptr{CTPSA}, c_re::Cdouble, c_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x*y + b*v*w + c. Same as mad_ctpsa_axypbvwpc without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\ny    – TPSA y\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nv    – TPSA v\nw    – TPSA w\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_ax2pby2pcz2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_ax2pby2pcz2_r!","text":"mad_ctpsa_ax2pby2pcz2_r!(a_re::Cdouble, a_im::Cdouble, x::Ptr{CTPSA}, b_re::Cdouble, b_im::Cdouble, y::Ptr{CTPSA}, c_re::Cdouble, c_im::Cdouble, z::Ptr{CTPSA}, r::Ptr{CTPSA})\n\nr = a*x^2 + b*y^2 + c*z^2. Same as mad_ctpsa_ax2pby2pcz2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nx    – TPSA x\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\ny    – TPSA y\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\nz    – TPSA z\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_axpsqrtbpcx2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_axpsqrtbpcx2_r!","text":"mad_ctpsa_axpsqrtbpcx2_r!(x::Ptr{CTPSA}, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble, c_re::Cdouble, c_im::Cdouble, r::Ptr{CTPSA})\n\nr = a*x + sqrt(b + c*x^2). Same as mad_ctpsa_axpsqrtbpcx2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!","page":"For Developers","title":"GTPSA.mad_ctpsa_logaxpsqrtbpcx2_r!","text":"mad_ctpsa_logaxpsqrtbpcx2_r!(x::Ptr{CTPSA}, a_re::Cdouble, a_im::Cdouble, b_re::Cdouble, b_im::Cdouble, c_re::Cdouble, c_im::Cdouble, r::Ptr{CTPSA})\n\nr = log(a*x + sqrt(b + c*x^2)). Same as mad_ctpsa_logaxpsqrtbpcx2 without complex-by-value arguments.\n\nInput\n\na_re – Real part of Scalar a\na_im – Imag part of Scalar a\nb_re – Real part of Scalar b\nb_im – Imag part of Scalar b\nc_re – Real part of Scalar c\nc_im – Imag part of Scalar c\n\nOutput\n\nr – Destination TPSA r\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_vec2fld!","page":"For Developers","title":"GTPSA.mad_ctpsa_vec2fld!","text":"mad_ctpsa_vec2fld!(na::Cint, a::Ptr{CTPSA}, mc::Vector{Ptr{CTPSA}})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the vector field (Hamilton's  equations) from the passed Hamiltonian, defined as [da/dp1, -da/dq1, ...]\n\nInput\n\nna  – Number of TPSA in mc consistent with number of variables in a\na   – Hamiltonian as a TPSA\n\nOutput\n\nmc  – Vector field derived from a using Hamilton's equations \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_fld2vec!","page":"For Developers","title":"GTPSA.mad_ctpsa_fld2vec!","text":"mad_ctpsa_fld2vec!(na::Cint, ma::Vector{Ptr{CTPSA}}, c::Ptr{CTPSA})\n\nAssuming the variables in the TPSA are canonically-conjugate, and ordered so that the canonically- conjugate variables are consecutive (q1, p1, q2, p2, ...), calculates the Hamiltonian one obtains  from ther vector field (in the form [da/dp1, -da/dq1, ...])\n\nInput\n\nna  – Number of TPSA in ma consistent with number of variables in c\nma  – Vector field \n\nOutput\n\nc   – Hamiltonian as a TPSA derived from the vector field ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_fgrad!","page":"For Developers","title":"GTPSA.mad_ctpsa_fgrad!","text":"mad_ctpsa_fgrad!(na::Cint, ma::Vector{Ptr{CTPSA}}, b::Ptr{CTPSA}, c::Ptr{CTPSA})\n\nCalculates dot(ma, grad(b))\n\nInput\n\nna – Length of ma consistent with number of variables in b\nma – Vector of TPSA\nb  – TPSA\n\nOutput\n\nc  – dot(ma, grad(b))\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_liebra!","page":"For Developers","title":"GTPSA.mad_ctpsa_liebra!","text":"mad_ctpsa_liebra!(na::Cint, ma::Vector{Ptr{CTPSA}}, mb::Vector{Ptr{CTPSA}}, mc::Vector{Ptr{CTPSA}})\n\nComputes the Lie bracket of the vector fields ma and mb, defined as  sumi mai (dmb/dxi) - mbi (dma/dx_i).\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_exppb!","page":"For Developers","title":"GTPSA.mad_ctpsa_exppb!","text":"mad_ctpsa_exppb!(na::Cint, ma::Vector{Ptr{CTPSA}}, mb::Vector{Ptr{CTPSA}}, mc::Vector{Ptr{CTPSA}})\n\nComputes the exponential of fgrad of the vector fields ma and mb, literally exppb(ma, mb) = mb + fgrad(ma, mb) + fgrad(ma, fgrad(ma, mb))/2! + ...\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_logpb!","page":"For Developers","title":"GTPSA.mad_ctpsa_logpb!","text":"mad_ctpsa_logpb!(na::Cint, ma::Vector{Ptr{CTPSA}}, mb::Vector{Ptr{CTPSA}}, mc::Vector{Ptr{CTPSA}})\n\nComputes the log of the Poisson bracket of the vector of TPSA ma and mb; the result  is the vector field F used to evolve to ma from mb.\n\nInput\n\nna – Length of ma and mb\nma – Vector of TPSA ma\nmb – Vector of TPSA mb\n\nOutput\n\nmc – Destination vector of TPSA mc\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mnrm","page":"For Developers","title":"GTPSA.mad_ctpsa_mnrm","text":"mad_ctpsa_mnrm(na::Cint, ma::Vector{Ptr{CTPSA}})::Cdouble\n\nComputes the norm of the map (sum of absolute value of coefficients of all TPSAs in the map).\n\nInput\n\nna  – Number of TPSAs in the map\nma  – Map ma\n\nOutput\n\nnrm – Norm of map (sum of absolute value of coefficients of all TPSAs in the map)\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_minv!","page":"For Developers","title":"GTPSA.mad_ctpsa_minv!","text":"mad_ctpsa_minv!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, mc::Vector{Ptr{CTPSA}})\n\nInverts the map. To include the parameters in the inversion, na = nn and the output map  length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\n\nOutput\n\nmc – Inversion of map ma\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_pminv!","page":"For Developers","title":"GTPSA.mad_ctpsa_pminv!","text":"mad_ctpsa_pminv!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, mc::Vector{Ptr{CTPSA}}, select::Vector{Cint})\n\nComputes the partial inverse of the map with only the selected variables, specified by 0s or 1s in select. To include the parameters in the inversion, na = nn and the output map length only need be nb = nv.\n\nInput\n\nna – Input map length (should be nn to include parameters)\nma – Map ma\nnb – Output map length (generally = nv)\nselect – Array of 0s or 1s defining which variables to do inverse on (atleast same size as na)'\n\nOutput\n\nmc     – Partially inverted map using variables specified as 1 in the select array\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_compose!","page":"For Developers","title":"GTPSA.mad_ctpsa_compose!","text":"mad_ctpsa_compose!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, mb::Vector{Ptr{CTPSA}}, mc::Vector{Ptr{CTPSA}})\n\nComposes two maps.\n\nInput\n\nna – Number of TPSAs in Map ma\nma – Map ma\nnb – Number of TPSAs in Map mb\nmb – Map mb\n\nOutput\n\nmc – Composition of maps ma and mb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_translate!","page":"For Developers","title":"GTPSA.mad_ctpsa_translate!","text":"mad_ctpsa_translate!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, tb::Vector{ComplexF64}, mc::Vector{Ptr{CTPSA}})\n\nTranslates the expansion point of the map by the amount tb.\n\nInput\n\nna – Number of TPSAS in the map\nma – Map ma\nnb – Length of tb\ntb – Vector of amount to translate for each variable\n\nOutput\n\nmc – Map evaluated at the new point translated tb from the original evaluation point\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_eval!","page":"For Developers","title":"GTPSA.mad_ctpsa_eval!","text":"mad_ctpsa_eval!(na::Cint, ma::Vector{Ptr{CTPSA}}, nb::Cint, tb::Vector{ComplexF64}, tc::Vector{ComplexF64})\n\nEvaluates the map at the point tb\n\nInput\n\nna – Number of TPSAs in the map\nma – Map ma\nnb – Length of tb\ntb – Point at which to evaluate the map\n\nOutput\n\ntc – Values for each TPSA in the map evaluated at the point tb\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_mconv!","page":"For Developers","title":"GTPSA.mad_ctpsa_mconv!","text":"mad_ctpsa_mconv!(na::Cint, ma::Vector{Ptr{CTPSA}}, nc::Cint, mc::Vector{Ptr{CTPSA}}, n::Cint, t2r_::Vector{Cint}, pb::Cint)\n\nEquivalent to mad_tpsa_convert, but applies the conversion to all TPSAs in the map ma.\n\nInput\n\nna   – Number of TPSAs in the map\nma   – Map ma\nnc   – Number of TPSAs in the output map mc\nn    – Length of vector (size of t2r_)\nt2r_ – (Optional) Vector of index lookup\npb   – Poisson bracket, 0, 1:fwd, -1:bwd\n\nOutput\n\nmc   – Map mc with specified conversions \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_print","page":"For Developers","title":"GTPSA.mad_ctpsa_print","text":"mad_ctpsa_print(t::Ptr{CTPSA}, name_::Cstring, eps_::Cdouble, nohdr_::Cint, stream_::Ptr{Cvoid})\n\nPrints the TPSA coefficients with precision eps_. If nohdr_ is not zero,  the header is not printed. \n\nInput\n\nt       – TPSA to print\nname_   – (Optional) Name of TPSA\neps_    – (Optional) Precision to output\nnohdr_  – (Optional) If True, no header is printed\nstream_ – (Optional) FILE pointer of output stream. Default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan","page":"For Developers","title":"GTPSA.mad_ctpsa_scan","text":"mad_ctpsa_scan(stream_::Ptr{Cvoid})::Ptr{CTPSA}\n\nScans in a TPSA from the stream_.\n\nInput\n\nstream_ – (Optional) I/O stream from which to read the TPSA, default is stdin\n\nOutput\n\nt       – TPSA scanned from I/O stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan_hdr","page":"For Developers","title":"GTPSA.mad_ctpsa_scan_hdr","text":"mad_ctpsa_scan_hdr(kind_::Ref{Cint}, name_::Ptr{Cuchar}, stream_::Ptr{Cvoid})::Ptr{Desc}\n\nRead TPSA header. Returns descriptor for TPSA given the header. This is useful for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nkind_   – (Optional) Real or complex TPSA, or detect automatically if not provided.\nname_   – (Optional) Name of TPSA\nstream_ – (Optional) I/O stream to read TPSA from,  default is stdin\n\nOutput\n\nret     – Descriptor for the TPSA \n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_scan_coef!","page":"For Developers","title":"GTPSA.mad_ctpsa_scan_coef!","text":"mad_ctpsa_scan_coef!(t::Ptr{CTPSA}, stream_::Ptr{Cvoid})\n\nRead TPSA coefficients into TPSA t. This should be used with mad_tpsa_scan_hdr for external languages using  this library where the memory is managed NOT on the C side.\n\nInput\n\nstream_ – (Optional) I/O stream to read TPSA from, default is stdin\n\nOutput\n\nt       – TPSA with coefficients scanned from stream_\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_debug","page":"For Developers","title":"GTPSA.mad_ctpsa_debug","text":"mad_ctpsa_debug(t::Ptr{CTPSA}, name_::Cstring, fnam_::Cstring, line_::Cint, stream_::Ptr{Cvoid})\n\nPrints TPSA with all information of data structure.\n\nInput\n\nt       – TPSA\nname_   – (Optional) Name of TPSA\nfnam_   – (Optional) File name to print to\nline_   – (Optional) Line number in file to start at\nstream_ – (Optional) I/O stream to print to, default is stdout\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_isvalid","page":"For Developers","title":"GTPSA.mad_ctpsa_isvalid","text":"mad_ctpsa_isvalid(t::Ptr{CTPSA})::Cuchar\n\nSanity check of the TPSA integrity.\n\nInput\n\nt – Complex TPSA to check if valid\n\nOutput\n\nret  – True if valid TPSA, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"devel/#GTPSA.mad_ctpsa_init!","page":"For Developers","title":"GTPSA.mad_ctpsa_init!","text":"mad_ctpsa_init(t::Ptr{CTPSA}, d::Ptr{Desc}, mo::Cuchar)::Ptr{CTPSA}\n\nUnsafe initialization of an already existing TPSA t with maximum order mo to the descriptor d. mo must be less than  the maximum order of the descriptor. t is modified in place and also returned.\n\nInput\n\nt  – TPSA to initialize to descriptor d\nd  – Descriptor\nmo – Maximum order of the TPSA (must be less than maximum order of the descriptor)\n\nOutput\n\nt  – TPSA initialized to descriptor d with maximum order mo\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#gjh","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"Extracts specific partial derivatives from a TPS","category":"page"},{"location":"man/i_gjh/#Syntax","page":"gradient, jacobian, hessian","title":"Syntax","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"grad = gradient(f [, include_params=bool])\ngradient!(grad, f [, include_params=bool])\n\nJ = jacobian(F [, include_params=bool])\njacobian!(J, F [, include_params=bool])\n\nJt = jacobiant(F [, include_params=bool])\njacobiant!(Jt, F [, include_params=bool])\n\nH = hessian(f [, include_params=bool])\nhessian!(H, f [, include_params=bool])","category":"page"},{"location":"man/i_gjh/#Description","page":"gradient, jacobian, hessian","title":"Description","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"grad = gradient(f) extracts the gradient from the TPS f, defined as nabla f","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"gradient!(grad, f) fills grad vector in-place with the gradient extracted from the TPS f","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"J = jacobian(F) extracts the Jacobian matrix from the vector of TPSs F, defined as J_ij = fracpartial F_ipartial x_j","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"jacobian!(J, F) fills the J matrix in-place with the Jacobian extracted from the vector of TPSs F","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"Jt = jacobiant(F) extracts the transpose of the Jacobian matrix from the vector of TPSs F, with the Jacobian defined as J_ij = fracpartial F_ipartial x_j","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"jacobiant!(Jt, F) fills the Jt matrix in-place with the transpose of the Jacobian extracted from the vector of TPSs F","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"H = hessian(f) extracts the Hessian matrix from the TPS f, defined as H_ij = fracpartial^2 fpartial x_ipartial x_j","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"hessian!(H, f) fills the H matrix in-place with the Hessian extracted from the TPS f","category":"page"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"","category":"page"},{"location":"man/i_gjh/#Optional-Argument","page":"gradient, jacobian, hessian","title":"Optional Argument","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"include_params can be set to true (default is false) to include the partial derivatives with respect to the parameters in any of the extraction functions above.","category":"page"},{"location":"man/i_gjh/#Examples","page":"gradient, jacobian, hessian","title":"Examples","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"using GTPSA; #hide\nd = Descriptor(2,10);\nx = vars(d);\nf = x[1] + 2*x[2] + 3*x[1]^2 + 4*x[1]*x[2] + 5*x[2]^2;\ng = 5*x[1] + 4*x[2] + 3*x[1]^2 + 2*x[1]*x[2] + x[2]^2;\ngrad = gradient(f)\nJ = jacobian([f, g])\nH = hessian(f)","category":"page"},{"location":"man/i_gjh/#Documentation","page":"gradient, jacobian, hessian","title":"Documentation","text":"","category":"section"},{"location":"man/i_gjh/","page":"gradient, jacobian, hessian","title":"gradient, jacobian, hessian","text":"gradient\ngradient!\njacobian\njacobian!\njacobiant\njacobiant!\nhessian\nhessian!","category":"page"},{"location":"man/i_gjh/#GTPSA.gradient","page":"gradient, jacobian, hessian","title":"GTPSA.gradient","text":"gradient(t::Union{TPS,ComplexTPS}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the TPS. The partial  derivatives wrt the parameters will also be extracted when the include_params flag is  set to true. Note that this function is not calculating anything - just extracting the  first-order monomial coefficients already in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS to extract the gradient from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\ngrad           – Gradient of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.gradient!","page":"gradient, jacobian, hessian","title":"GTPSA.gradient!","text":"gradient!(result::Vector{<:Union{Float64,ComplexF64}}, t::Union{TPS,ComplexTPS}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the TPS and fills the result  vector in-place. The partial derivatives wrt the parameters will also be extracted  when the include_params flag is set to true. Note that this function is not  calculating anything - just extracting the first-order monomial coefficients already  in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS to extract the gradient from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nresult         – Preallocated Vector to fill with the gradient of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.jacobian","page":"gradient, jacobian, hessian","title":"GTPSA.jacobian","text":"jacobian(m::Vector{<:Union{TPS,ComplexTPS}}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the Vector of TPSs.  The partial derivatives wrt the parameters will also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting  the first-order monomial coefficients already in the TPSs.\n\nInput\n\nm              – Vector of TPSs. to extract the Jacobian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nJ              – Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.jacobian!","page":"gradient, jacobian, hessian","title":"GTPSA.jacobian!","text":"jacobian!(result::Matrix{<:Union{Float64,ComplexF64}}, m::Vector{<:Union{TPS,ComplexTPS}}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the Vector of TPSs.  and fills the result matrix in-place. The partial derivatives wrt the parameters will  also be extracted when the include_params flag is set to true. Note that this function  is not calculating anything - just extracting the first-order monomial coefficients already  in the TPSs.\n\nInput\n\nm              – Vector of TPSs. to extract the Jacobian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nresult         – Preallocated matrix to fill with the Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.jacobiant","page":"gradient, jacobian, hessian","title":"GTPSA.jacobiant","text":"jacobiant(m::Vector{<:Union{TPS,ComplexTPS}}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the Vector of TPSs,  as the transpose of the Jacobian. Because of Julia's column-major indexing vs. C's row-major,  this routine will be slightly faster than using jacobian if the transpose of the Jacobian is  needed. The partial derivatives wrt the parameters will  also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting the  first-order monomial coefficients already in the TPSs.\n\nInput\n\nm              – Vector of TPSs. to extract the Jacobian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nJt             – Transpose of the Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.jacobiant!","page":"gradient, jacobian, hessian","title":"GTPSA.jacobiant!","text":"jacobiant!(result::Matrix{<:Union{Float64,ComplexF64}}, m::Vector{<:Union{TPS,ComplexTPS}}; include_params=false)\n\nExtracts the first-order partial derivatives (evaluated at 0) from the Vector of TPSs,  as the transpose of the Jacobian. Because of Julia's column-major indexing vs. C's row-major,  this routine will be slightly faster than using jacobian! if the transpose of the Jacobian is  needed. The partial derivatives wrt the parameters will  also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting the  first-order monomial coefficients already in the TPSs and filling result.\n\nInput\n\nm              – Vector of TPSs. to extract the Jacobian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nresult         – Preallocated matrix to fill with the transpose of the Jacobian of m\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.hessian","page":"gradient, jacobian, hessian","title":"GTPSA.hessian","text":"hessian(t::Union{TPS,ComplexTPS}; include_params=false)\n\nExtracts the second-order partial derivatives (evaluated at 0) from the TPS. The partial derivatives wrt the parameters will also be extracted when the include_params  flag is set to true. Note that this function is not calculating anything - just extracting  the second-order monomial coefficients already in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS to extract the Hessian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nH              – Hessian of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/i_gjh/#GTPSA.hessian!","page":"gradient, jacobian, hessian","title":"GTPSA.hessian!","text":"hessian!(result::Matrix{<:Union{Float64,ComplexF64}},t::Union{TPS,ComplexTPS}; include_params=false)\n\nExtracts the second-order partial derivatives (evaluated at 0) from the TPS  and fills the result matrix in-place. The partial derivatives wrt the parameters will  also be extracted when the include_params flag is set to true. Note that this function  is not calculating anything - just extracting the second-order monomial coefficients already  in the TPS.\n\nInput\n\nt              – TPS/ComplexTPS to extract the Hessian from\ninclude_params – (Optional) Extract partial derivatives wrt parameters. Default is false\n\nOutput\n\nresult         – Preallocated matrix to fill with the Hessian of the TPS\n\n\n\n\n\n","category":"function"},{"location":"man/a_toc/#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"man/a_toc/","page":"Table of Contents","title":"Table of Contents","text":"Definitions\nDescriptor: Defines the number of variables and parameters, and orders for each in the GTPSA\nTPS: Truncated Power Series struct\nComplexTPS: Complex Truncated Power Series struct\nvars, params: Creates a vector of TPSs corresponding to each variable/parameter in the GTPSA\ngradient, jacobian, hessian: Extracts specific partial derivatives from a TPS\nMonomial Indexing: Get/set individual monomial coefficients\nmono: Creates a TPS corresponding to a specific monomial\nSlicing and par: Indexing a specific polynomial within the TPS\nTPS Methods: Integrate, differentiate, composition, evaluation, etc.\n@FastGTPSA: Speed up evaluation of expressions containing TPSs, transparent to other types\nI/O: Reading/writing TPSs\nAll Overloaded Functions: List of all overloaded Base functions and more ","category":"page"},{"location":"man/k_methods/#tpsmethods","page":"TPS Methods","title":"TPS Methods","text":"","category":"section"},{"location":"man/k_methods/","page":"TPS Methods","title":"TPS Methods","text":"clear!\ncomplex!\ncompose!\ncutord\ncutord!\nderiv\nderiv!\nevaluate\nevaluate!\ngetord\ngetord!\ninteg\ninteg!\nscalar\ntranslate\ntranslate!","category":"page"},{"location":"man/k_methods/#GTPSA.clear!","page":"TPS Methods","title":"GTPSA.clear!","text":"clear!(t::Union{TPS,ComplexTPS})\n\nClears the TPS (sets all monomial coefficients to 0).\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.complex!","page":"TPS Methods","title":"GTPSA.complex!","text":"complex!(ct::ComplexTPS, t::TPS)\n\nSets the pre-allocated ComplexTPS ct equal to t.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.compose!","page":"TPS Methods","title":"GTPSA.compose!","text":"compose!(m::Vector{<:Union{TPS,ComplexTPS}}, m2::Vector{<:Union{TPS,ComplexTPS}}, m1::Vector{<:Union{TPS,ComplexTPS}}; work_low::Union{Nothing,Tuple{Vararg{Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}}}}=nothing, work_prom::Union{Nothing,Tuple{Vararg{Vector{<:ComplexTPS}}}}=nothing)\n\nComposes the vector functions m2 ∘ m1 and stores the result in-place in m. Promotion is allowed, provided  the output vector function m has the correct promoted type. \n\nFor all compositions, 3 temporary vectors must be generated that contain Ptr{RTPSA} or Ptr{CTPSA} for each TPS in the map (depending on output type), to pass to the low-level C composition function in GTPSA.  They are correspondingly referred to as outx_low, m2x_low, and m1x_low. These three temporaries containers  can be optionally passed as a tuple in work_low, and must satisfy the following requirements:\n\nwork_low[1] = outx_low   # Length >= length(m) = length(m2)\nwork_low[2] = m2x_low    # Length >= length(m2) = length(m)\nwork_low[3] = m1x_low    # Length >= length(m1)\n\nIf promotion is occuring, then one of the input vectors must be promoted to ComplexTPS. A vector of pre-allocated  ComplexTPSs can optionally provided as the first argument in the work_prom tuple, and has the requirement:\n\nIf eltype(m.x) != eltype(m1.x) (then m1 must be promoted): work_prom[1] = m1x_prom  # Length >= length(m1), Vector{ComplexTPS}\n\nelse if eltype(m.x) != eltype(m2.x) (then m2 must be promoted): work_prom[1] = m2x_prom  # Length >= length(m2) = length(m), Vector{ComplexTPS}\n\nNote that the ComplexTPSs in the vectors must be allocated and have the same Descriptor.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.cutord","page":"TPS Methods","title":"GTPSA.cutord","text":"cutord(t1::Union{TPS, ComplexTPS}, order::Integer)\n\nCuts out the monomials in t1 at the given order and above. Or, if order  is negative, will cut monomials with orders at and below abs(order).\n\nExamples\n\njulia> d = Descriptor(1,10);\n\njulia> x = vars(d);\n\njulia> cutord(sin(x[1]), 5)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1\n  -1.6666666666666666e-01    3        3\n\n\njulia> cutord(sin(x[1]), -5)\nTPS:\n  Coefficient              Order     Exponent\n  -1.9841269841269841e-04    7        7\n   2.7557319223985893e-06    9        9\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.cutord!","page":"TPS Methods","title":"GTPSA.cutord!","text":"cutord!(t::T, t1::T, order::Integer) where {T<:Union{TPS,ComplexTPS}}\n\nCuts out the monomials in t1 at the given order and above. Or, if order  is negative, will cut monomials with orders at and below abs(order). t  is filled in-place with the result. See the documentation for cutord for examples.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.deriv","page":"TPS Methods","title":"GTPSA.deriv","text":"deriv(t1::Union{TPS,ComplexTPS}, v::Union{TPSIndexType, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{SMIndexType, Nothing}=nothing)\n∂(t1::Union{TPS,ComplexTPS}, v::Union{TPSIndexType, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{SMIndexType, Nothing}=nothing)\n\nDifferentiates t1 wrt the variable/parameter specified by the variable/parameter index, or  alternatively any monomial specified by indexing-by-order OR indexing-by-sparse monomial.\n\nInput\n\nv      – An integer (for variable index), vector/tuple of orders for each variable (for indexing-by-order), or vector/tuple of pairs (sparse monomial)\nparam  – (Keyword argument, optional) An integer for the parameter index\nparams – (Keyword argument, optional) Vector/tuple of pairs for sparse-monomial indexing\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(1,5,1,5);\n\njulia> x1 = vars(d)[1]; k1 = params(d)[1];\n\njulia> deriv(x1*k1, 1)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1\n\n\njulia> deriv(x1*k1, param=1)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0\n\nExamples: Monomial Index-by-Order\n\njulia> deriv(x1*k1, [1,0])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1\n\n\njulia> deriv(x1*k1, [0,1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0\n\n\njulia> deriv(x1*k1, [1,1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    0        0    0\n\nExamples: Monomial Index-by-Sparse Monomial\n\njulia> deriv(x1*k1, [1=>1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1\n\n\njulia> deriv(x1*k1, params=[1=>1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0\n\n\njulia> deriv(x1*k1, [1=>1], params=[1=>1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    0        0    0\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.deriv!","page":"TPS Methods","title":"GTPSA.deriv!","text":"deriv!(t::T, t1::T, v::Union{TPSIndexType, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{SMIndexType, Nothing}=nothing) where {T<:Union{TPS,ComplexTPS}}\n∂!(t::T, t1::T, v::Union{TPSIndexType, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{SMIndexType, Nothing}=nothing) where {T<:Union{TPS,ComplexTPS}}\n\nDifferentiates t1 wrt the variable/parameter specified by the variable/parameter index, or  alternatively any monomial specified by indexing-by-order OR indexing-by-sparse monomial, and  sets t equal to the result in-place. See the deriv documentation for examples.\n\nInput\n\nv      – An integer (for variable index), vector/tuple of orders for each variable (for indexing-by-order), or vector/tuple of pairs (sparse monomial)\nparam  – (Keyword argument, optional) An integer for the parameter index\nparams – (Keyword argument, optional) Vector/tuple of pairs for sparse-monomial indexing\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.evaluate","page":"TPS Methods","title":"GTPSA.evaluate","text":"evaluate(m::Vector{T}, tb::Vector{<:Number}) where {T<:Union{TPS,ComplexTPS}}\n\nEvaluates the vector function m at the point tb.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.evaluate!","page":"TPS Methods","title":"GTPSA.evaluate!","text":"evaluate!(tc::Vector{<:Number}, m::Vector{T}, tb::Vector{<:Number}; work_low::Vector{<:Union{Ptr{RTPSA},Ptr{CTPSA}}}=Vector{lowtype(T)}(undef, length(m))) where {T<:Union{TPS,ComplexTPS}}\n\nEvaluates the vector function m at the point tb, and fills tc with the result.  An optional container work_low can be provided for containing the low-level TPS  structs for zero allocations.    \n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.getord","page":"TPS Methods","title":"GTPSA.getord","text":"getord(t1::Union{TPS, ComplexTPS}, order::Integer)\n\nExtracts one homogenous polynomial from t1 of the given order.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.getord!","page":"TPS Methods","title":"GTPSA.getord!","text":"getord!(t::T, t1::T, order::Integer) where {T<:Union{TPS,ComplexTPS}}\n\nExtracts one homogenous polynomial from t1 of the given order and  fills t with the result in-place.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.integ","page":"TPS Methods","title":"GTPSA.integ","text":"integ(t1::Union{TPS, ComplexTPS}, var::Integer=1)\n∫(t1::Union{TPS, ComplexTPS}, var::Integer=1)\n\nIntegrates t1 wrt the variable var. Integration wrt  parameters is not allowed, and integration wrt higher order  monomials is not currently supported.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.integ!","page":"TPS Methods","title":"GTPSA.integ!","text":"integ!(t::T, t1::T, var::Integer=1) where {T<:Union{TPS,ComplexTPS}}\n∫!(t::T, t1::T, var::Integer=1) where {T<:Union{TPS,ComplexTPS}}\n\nIntegrates t1 wrt the variable var and fills t with the result.  Integration wrt parameters is not allowed, and integration wrt higher order  monomials is not currently supported.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.scalar","page":"TPS Methods","title":"GTPSA.scalar","text":"scalar(t::Union{TPS,ComplexTPS})\n\nExtracts the scalar part of the TPS. Equivalent to t[0] but  this can be easily broadcasted.\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.translate","page":"TPS Methods","title":"GTPSA.translate","text":"Returns a vector function equal to ma with its expansion point translated by tb\n\n\n\n\n\n","category":"function"},{"location":"man/k_methods/#GTPSA.translate!","page":"TPS Methods","title":"GTPSA.translate!","text":"translate!(mc::Vector{<:T}, ma::Vector{<:T}, tb::Vector{<:Number}) where {T<:Union{TPS,ComplexTPS}}\n\nFills ma with the vector function equal to ma with its expansion point translated by tb.\n\nTwo temporary vectors of either Ptr{RTPSA} or Ptr{CTPSA} must be created, or they can optionally  be passed as a tuple to the kwarg work_low where\n\nma_low = low corresponding to ma = work_low[1] mb_low = low corresponding to mb = work_low[2]\n\n\n\n\n\n","category":"function"},{"location":"man/o_all/#all","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"","category":"section"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"The following functions from Base have been overloaded for operations with TPS/ComplexTPS, and also maps:","category":"page"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"+, -, *, /, ^, ∘, inv, atan, hypot, abs, sqrt, exp, log, \nsin, cos, tan, csc, sec, cot, sinc, sinh, cosh, tanh, csch, \nsech, coth, asin, acos, atan, acsc, asec, acot, asinh, acosh, \natanh, acsch, asech, acoth, zero, one, real, imag, conj, angle, \ncomplex, promote_rule, getindex, setindex!, ==, <, >, <=, >=, \n!=, isequal, show, copy!","category":"page"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"GTPSA.jl overloads (and exports) the following functions from the corresponding packages:  LinearAlgebra: norm  SpecialFunctions: erf, erfc","category":"page"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"GTPSA.jl also provides the following functions NOT included in Base or any of the above packages:","category":"page"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"unit, sinhc, asinc, asinhc, polar, rect","category":"page"},{"location":"man/o_all/","page":"All Overloaded Functions","title":"All Overloaded Functions","text":"If there is a mathematical function in Base which you'd like and is not included in the above list, feel free to submit an issue.","category":"page"},{"location":"man/l_fastgtpsa/#fastgtpsa","page":"@FastGTPSA","title":"@FastGTPSA","text":"","category":"section"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"Speed up evaluation of expressions containing TPSs, transparent to other types","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"The @FastGTPSA macro can be preprended to any mathematical expressions that may contain operations using TPS/ComplexTPSs. The macro is completely transparent to non-TPS types, and so can be prepended in all functions while still maintaining type-generic code.","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"Here's an example of @FastGTPSA in action:","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"using GTPSA, BenchmarkTools\nGTPSA.show_sparse = false; GTPSA.show_header=false; # hide\n\nd = Descriptor(3, 5);\nx = vars(d);\n\n@btime $x[1]^3*sin($x[2])/log(2+$x[3])-exp($x[1]*$x[2])*im;\n\n@btime @FastGTPSA $x[1]^3*sin($x[2])/log(2+$x[3])-exp($x[1]*$x[2])*im;","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"Without using the macro, each time an operation is performed using a TPS, a new TPS is dynamically-allocated containing the result. For example in the above expression, the calculation of sin(x[2]) creates a new TPS, and the calculation of x[1]^3 also creates a new TPS. The multiplication of these two resulting TPSs creates a new TPS, and so on until a TPS containing the full result of the evaluated expression is obtained. The intermediate TPSs that must be created to evaluate the expression are referred to as temporaries, because they only exist temporarily. In the above example, we have 9 temporaries being created, with the last allocation being the result of the entire expression. Julia's garbage collector notices when the dynamically-allocated temporaries are no longer in scope, and cleans up that memory. This process can cause slowdowns in performance critical code however, especially in more complicated expressions where a lot of temporaries are created.","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"The macro @FastGTPSA basically tells the code to instead use a permanent, pre-allocated buffer of TPSs to contain the temporaries during evaluation of the expression, so there is no dynamic memory allocation until the result is obtained; the number of allocations is reduced to 1. Furthermore, these temporaries are accessed and deleted in a stack-like manner from the buffer, so that temporaries involved in operations are right next to each other in memory. This ensures minimal cache misses throughout the evaluation of the expression.","category":"page"},{"location":"man/l_fastgtpsa/","page":"@FastGTPSA","title":"@FastGTPSA","text":"The speedup of using the macro can be quite significant. See our example, where we observe a roughly x2.5 speedup.","category":"page"},{"location":"man/c_descriptor/#descriptor","page":"Descriptor","title":"Descriptor","text":"","category":"section"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"Defines the number of variables, number of parameters, and order(s) for each in the GTPSA","category":"page"},{"location":"man/c_descriptor/#Syntax","page":"Descriptor","title":"Syntax","text":"","category":"section"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order)     \nd = Descriptor(vars_orders, max_order)\nd = Descriptor(num_vars, max_order, num_params, param_order)   \nd = Descriptor(vars_orders, max_order, params_orders, param_order)\n\nGTPSA.desc_current = d","category":"page"},{"location":"man/c_descriptor/#Description","page":"Descriptor","title":"Description","text":"","category":"section"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order) defines a GTPSA Descriptor with num_vars variables and a maximum truncation order max_order","category":"page"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(vars_orders, max_order) defines a GTPSA Descriptor with length(var_orders) variables each having individual truncation orders specified in the var_orders vector, and a maximum truncation order max_order for the entire monomial","category":"page"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(num_vars, max_order, num_params, param_order) defines a GTPSA Descriptor with num_vars variables and num_params parameters. The parameters part of a monomial is truncated at param_order, and the entire monomial is truncated at max_order (so param_order <= max_order)","category":"page"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"d = Descriptor(vars_orders, max_order, params_orders, param_order) defines a GTPSA Descriptor with length(var_orders) variables each having individual truncation orders specified in the vars_orders vector, and length(param_orders) parameters each having individual truncation orders specified in the params_orders vector. The parameters part of the monomial is truncated at param_order,  and the entire monomial is truncated at max_order (so param_order <= max_order)","category":"page"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"","category":"page"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"GTPSA.desc_current is a global variable that is set each time a user creates a new Descriptor, and can also be set manually by a user. GTPSA.desc_current defines the Descriptor to use when that information is not explicitly (or implicitly in a TPS copy constructor) available, e.g. when calling TPS(a) where a is not a TPS. This also allows one to use general Number commands like convert(TPS, a) and zeros(TPS, 6).","category":"page"},{"location":"man/c_descriptor/#Examples","page":"Descriptor","title":"Examples","text":"","category":"section"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"using GTPSA #hide\nd1 = Descriptor(2, 10)         \nd2 = Descriptor([1, 2, 3], 5)     \nd3 = Descriptor(3, 4, 1, 2)    \nd4 = Descriptor([6, 5], 8, [4, 3], 7)   \nGTPSA.desc_current = d1","category":"page"},{"location":"man/c_descriptor/#Documentation","page":"Descriptor","title":"Documentation","text":"","category":"section"},{"location":"man/c_descriptor/","page":"Descriptor","title":"Descriptor","text":"Descriptor","category":"page"},{"location":"man/c_descriptor/#GTPSA.Descriptor","page":"Descriptor","title":"GTPSA.Descriptor","text":"Descriptor(nv::Integer, mo::Integer)::Descriptor\n\nCreates a TPSA Descriptor with nv variables, and a maximum truncation order mo.\n\nInput\n\nnv – Number of variables in the TPSA\nmo – Maximum truncation order of the TPSA\n\n\n\n\n\nDescriptor(vos::Vector{<:Integer}, mo::Integer)::Descriptor\n\nCreates a TPSA Descriptor with length(vos) variables with individual truncation  orders specified in the Vector vos, and a maximum truncation order mo for the TPSA.\n\nInput\n\nvos – Vector of the individual truncation orders of each variable\nmo  – Maximum truncation order of the TPSA, <= sum(vos)\n\n\n\n\n\nDescriptor(nv::Integer, mo::Integer, np::Integer, po::Integer)::Descriptor\n\nCreates a TPSA Descriptor with nv variables and np parameters. The maximum  truncation order is mo (including the parameters), and the truncation order for  the parameters part of a monomial is po.\n\nInput\n\nnv – Number of variables in the TPSA\nmo – Maximum truncation order of the TPSA including variables and parameters\nnp – Number of parameters in the TPSA\npo – Truncation order of the parameters part of a monomial\n\n\n\n\n\nDescriptor(vos::Vector{<:Integer}, mo::Integer, pos::Vector{<:Integer}, po::Integer)::Descriptor\n\nCreates a TPSA Descriptor with length(vos) variables with individual truncation  orders specified in vos, and length(pos) parameters with individual truncation  orders specified in pos. The maximum truncation order including both variables and  parameters is mo, and the truncation order for just the parameters part of the is po.\n\nInput\n\nvos – Vector of the individual truncation orders of each variable\nmo  – Maximum truncation order of the TPSA including variables and parameters\npos – Vector of the individual truncation orders of each parameter\npo – Truncation order of the parameters part of a monomial\n\n\n\n\n\n","category":"type"},{"location":"man/h_mono/#mono","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"Creates a TPS corresponding to a specific monomial","category":"page"},{"location":"man/h_mono/#Syntax","page":"mono/complexmono","title":"Syntax","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono(orders [, use=(descriptor|tps|complextps)])\n\nm = mono([vars_sparse_mono] [, params=params_sparse_mono] [, use=(descriptor|tps|complextps)])\n\nm = mono(idx [, use=(descriptor|tps|complextps)])\nm = mono(param=param_idx [, use=(descriptor|tps|complextps)])\n\nm = complexmono(...)","category":"page"},{"location":"man/h_mono/#Description","page":"mono/complexmono","title":"Description","text":"","category":"section"},{"location":"man/h_mono/#Indexing-by-Order","page":"mono/complexmono","title":"Indexing by Order","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono(orders) creates a TPS equal to the monomial specified by the indexing-by-order vector/tuple orders using the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"page"},{"location":"man/h_mono/#Indexing-by-Sparse-Monomial","page":"mono/complexmono","title":"Indexing by Sparse Monomial","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono(vars_sparse_mono, params=params_sparse_mono) creates a TPS equal to the monomial specified by the indexing-by-sparse monomial vector/tuple vars_sparse_mono and params_sparse_mono using the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"page"},{"location":"man/h_mono/#Indexing-by-Monomial-Index","page":"mono/complexmono","title":"Indexing by Monomial Index","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono(idx) creates a TPS equal to the monomial specified by idx and the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"m = mono(param=param_idx) creates a TPS equal to the monomial specified by param_idx + nv where nv is the number of variables in the GTPSA, using the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"page"},{"location":"man/h_mono/#Optional-Keyword-Argument","page":"mono/complexmono","title":"Optional Keyword Argument","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"use=(descriptor|tps|complextps) creates a mono using any of the above methods but using the Descriptor specified by use","category":"page"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"","category":"page"},{"location":"man/h_mono/#Complex-Monomial","page":"mono/complexmono","title":"Complex Monomial","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"complexmono will create a ComplexTPS using any of the above methods without the overhead of creating a TPS and converting it to a ComplexTPS","category":"page"},{"location":"man/h_mono/#Examples","page":"mono/complexmono","title":"Examples","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"using GTPSA; GTPSA.show_sparse = false;  GTPSA.show_header=false;#hide\nd1 = Descriptor(3, 15, 2, 15); # 3 vars, 2 params, all to order 15\nx1 = mono(1)\nk1 = mono(param=1)\nm312 = mono([3,1,2])\nm31221 = mono((3,1,2,2,1)) # Tuples allowed for indexing\nm312 = mono([1=>3, 2=>1, 3=>3])\nm31221 = mono((1=>3, 2=>1, 3=>2), params=(1=>2, 2=>1))","category":"page"},{"location":"man/h_mono/#Documentation","page":"mono/complexmono","title":"Documentation","text":"","category":"section"},{"location":"man/h_mono/","page":"mono/complexmono","title":"mono/complexmono","text":"mono","category":"page"},{"location":"man/h_mono/#GTPSA.mono","page":"mono/complexmono","title":"GTPSA.mono","text":"mono(v::Union{Integer, Vector{<:Union{<:Pair{<:Integer,<:Integer},<:Integer}}, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{Vector{<:Pair{<:Integer,<:Integer}}, Nothing}=nothing, use::Descriptor=GTPSA.desc_current)::TPS\n\nReturns a TPS corresponding to a specific monomial, specified using the variable/parameter index, or  monomial indexing-by-order OR monomial indexing-by-sparse monomial. \n\nInput\n\nv      – An integer (for variable index), an array of orders for each variable (for indexing-by-order), or an array of pairs (sparse monomial)\nparam  – (Keyword argument, optional) An integer for the parameter index\nparams – (Keyword argument, optional) An array of pairs for sparse-monomial indexing\nuse    – (Keyword argument, optional) The descriptor to use to generate the monomial. Default is most recently-defined.\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(3,10,2,10);\n\njulia> mono(1)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0    0    0    0\n\n\njulia> mono(2, use=d)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1    0    0    0\n\n\njulia> mono(param=2)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    0    0    0    1\n\nExamples: Monomial Index-by-Order\n\njulia> mono([1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0    0    0    0\n\n\njulia> mono([0,1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1    0    0    0\n\n\njulia> mono([0,0,0,0,1], use=d)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    0    0    0    1\n\n\njulia> mono([1,0,0,0,1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    2        1    0    0    0    1\n\nExamples: Monomial Index-by-Sparse Monomial\n\njulia> mono([1=>1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        1    0    0    0    0\n\n\njulia> mono([2=>1])\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    1        0    1    0    0    0\n\n\njulia> mono([1=>1], params=[2=>1], use=d)\nTPS:\n  Coefficient              Order     Exponent\n   1.0000000000000000e+00    2        1    0    0    0    1\n\n\n\n\n\n","category":"function"},{"location":"man/g_monoindex/#monoindex","page":"Monomial Indexing","title":"Monomial Indexing","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"Get/set individual monomial coefficients","category":"page"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"Individual monomial coefficients in a TPS can be get/set with two methods of indexing: by order, and by sparse monomial. ","category":"page"},{"location":"man/g_monoindex/#By-Order","page":"Monomial Indexing","title":"By Order","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[[<var_1 order>, ..., <var_N order>,<param_1 order>, ..., <param_M order>]]\nt[(<var_1 order>, ..., <var_N order>,<param_1 order>, ..., <param_M order>)]","category":"page"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"A particular monomial can be indexed by specifying the orders of each variable and parameter. For example, for a TPS t with variables x_1, x_2 and parameters k_1, k_2, the x_1^3x_2^1k_1^2 monomial coefficient is accessed with t[[3,1,2,0]] or equivalently t[[3,1,2]], as leaving out trailing zeros for unincluded variables/parameters is allowed. A tuple is also allowed instead of a vector for the list of orders.","category":"page"},{"location":"man/g_monoindex/#Examples","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header=false;#hide\nd = Descriptor(2, 6, 3, 6); # 2 variables, 3 parameters all to 6th order\nx = vars(d);\nk = params(d);\nf = 5 + sin(x[1])*sin(x[2])*cos(k[1])\nf[[3,1,2]] # Leave out trailing zeros for unincluded variables/parameters\nf[[0]] # Scalar part\nf[(1,1,1,1,1)] = 123; # Set monomial coefficient\nprint(f)","category":"page"},{"location":"man/g_monoindex/#By-Sparse-Monomial","page":"Monomial Indexing","title":"By Sparse Monomial","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[[<ix_var> => <order>, ...], params=[<ix_param> => <order>, ...]]\nt[(<ix_var> => <order>, ...), params=(<ix_param> => <order>, ...)]","category":"page"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"In GTPSAs with many variables and parameters, indexing-by-order is inconvenient because each order needs to be included up to the last included variable/parameter with nonzero order. In this case, a particular monomial can be indexed instead by specifying each variable/parameter number and its corresponding order in pairs. For example, for a TPS with variables x_1  x_15 and parameters k_1  k_10, the x_1^3x_15^1k_10^2 monomial coefficient is accessed with t[[1=>3, 15=>1], params=[10=>2]]. The scalar part of the TPS cannot be get/set with this method. A tuple is also allowed instead of a vector for the list of pairs.","category":"page"},{"location":"man/g_monoindex/#Examples-2","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false;  GTPSA.show_header=false; #hide\nd = Descriptor(15, 6, 10, 6); # 15 variables, 10 parameters all to 6th order\nGTPSA.show_sparse = true; # Use sparse output\nx = vars(d);\nk = params(d);\nf = 5 + sin(x[1])*sin(x[15])*cos(k[10])\nf[[1=>3, 15=>1], params=[10=>2]]\nf[(1=>1, 15=>2), params=(10=>3,)] = 123; # Set monomial coefficient\nprint(f)","category":"page"},{"location":"man/g_monoindex/#By-Monomial-Index","page":"Monomial Indexing","title":"By Monomial Index","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"t[idx]\nt[param=param_idx]","category":"page"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"This indexing method is not recommended/requires care when indexing monomials above first order. Indexes the TPS with all monomials sorted by order. For example, for a TPS with one variable x_1 and one parameter k_1 the x_1 monomial is indexed with t[1] and the x_1^2 monomial is indexed with either t[3]. The k_1 monomial can be indexed with either t[2] or equivalently using the param helper kwarg t[param=1], which simply adds the number of variables in the GTPSA to the provided index. Note that above first-order, the param kwarg is basically useless. The zeroth order part, or the scalar part of the TPS, can be set with t[0]. This method requires zero allocations for indexing, unlike the other two.","category":"page"},{"location":"man/g_monoindex/#Examples-3","page":"Monomial Indexing","title":"Examples","text":"","category":"section"},{"location":"man/g_monoindex/","page":"Monomial Indexing","title":"Monomial Indexing","text":"using GTPSA; GTPSA.show_sparse = false;  GTPSA.show_header=false; #hide\n# Example of indexing by monomial index -----------\nd = Descriptor(2, 10, 1, 10);\nt = TPS(use=d); # Create zero TPS based on d\n\nt[0] = 0;\nt[1] = 1;\nt[2] = 2;\nt[3] = 3;  # or t[param=1] = 3\nt[4] = 4;\nt[5] = 5; \nt[6] = 6;\nt[7] = 7;\nt[8] = 8;\nt[9] = 9;\nt[10] = 10;\nprint(t)","category":"page"},{"location":"man/e_complextps/#complextps","page":"ComplexTPS","title":"ComplexTPS","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"Complex Truncated Power Series struct ComplexTPS <: Number","category":"page"},{"location":"man/e_complextps/#Syntax","page":"ComplexTPS","title":"Syntax","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"ct = ComplexTPS([number] [, use=(descriptor|tps|complextps)])\n\nct = ComplexTPS([real1, real2] [, use=(descriptor|tps|complextps)])","category":"page"},{"location":"man/e_complextps/#Description","page":"ComplexTPS","title":"Description","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"ct = ComplexTPS() creates a new ComplexTPS with all coefficients equal to zero using the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"ct = ComplexTPS(number) creates a new ComplexTPS equal to number. If number is a TPS/ComplexTPS, then its Descriptor is used (equivalent to a copy constructor). Else, the Descriptor in GTPSA.desc_current is used","category":"page"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"ct = ComplexTPS(real1, real2) creates a new ComplexTPS equal to complex(real1, real2). If real1 or real2 is a TPS then its Descriptor is used. Else, the Descriptor in GTPSA.desc_current is used","category":"page"},{"location":"man/e_complextps/#Optional-Keyword-Argument","page":"ComplexTPS","title":"Optional Keyword Argument","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"use=descriptor creates a new ComplexTPS having a Descriptor equal to that passed","category":"page"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"use=(tps|complextps) creates a new ComplexTPS having a Descriptor equal to that used by the passed TPS or ComplexTPS","category":"page"},{"location":"man/e_complextps/#Examples","page":"ComplexTPS","title":"Examples","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nGTPSA.show_header = true\nd1 = Descriptor(1, 1); # 1 variable to order 1\nt1_1 = ComplexTPS()\nt2_1 = ComplexTPS(5)\nt3_1 = ComplexTPS(6, TPS(5))\nt3_1 = ComplexTPS(TPS(5))\nd2 = Descriptor(1, 10); # New Descriptor to order 10\nt3_2 = ComplexTPS(t3_1, use=d2) # Copies and changes Descriptor\nGTPSA.show_header = false #hide","category":"page"},{"location":"man/e_complextps/#Documentation","page":"ComplexTPS","title":"Documentation","text":"","category":"section"},{"location":"man/e_complextps/","page":"ComplexTPS","title":"ComplexTPS","text":"ComplexTPS","category":"page"},{"location":"man/e_complextps/#GTPSA.ComplexTPS","page":"ComplexTPS","title":"GTPSA.ComplexTPS","text":"ComplexTPS(cta::Union{Number,Nothing}=nothing; use::Union{Descriptor,TPS,ComplexTPS,Nothing}=nothing)::ComplexTPS\n\nConstructor to create a new ComplexTPS equal to the number cta. If cta is a ComplexTPS (or TPS), this  is equivalent to a copy constructor, with the result by default having the same Descriptor as cta. If cta  is not a TPS orComplexTPS, then the Descriptor used will by default be GTPSA.desc_current. The Descriptor  for the constructed ComplexTPS can be set using use. If a TPS or ComplexTPS is passed to use,  the Descriptor for that TPS will be used.\n\nThe constructor can also be used to create a copy of a ComplexTPS under one Descriptor to instead  have a different Descriptor. In this case, invalid monomials under the new Descriptor are removed.\n\nInput\n\ncta  – Any Number\nuse – (Optional) specify which Descriptor to use, default is nothing which uses the Descriptor for cta if cta <: Union{TPS,ComplexTPS}, else uses GTPSA.desc_current\n\nOutput\n\nret – New ComplexTPS equal to cta with removal of invalid monomials if cta is a TPS/ComplexTPS and a new Descriptor is specified\n\n\n\n\n\n","category":"type"},{"location":"man/j_slice/#slice","page":"Slicing and par","title":"Slicing and par","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"Indexing a specific polynomial within the TPS","category":"page"},{"location":"man/j_slice/#Slicing-a-TPS","page":"Slicing and par","title":"Slicing a TPS","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"A polynomial within the TPS with certain variable orders can be extracted by slicing the TPS. When indexing by order, a colon (:) can be used in place for a variable order to include all orders of that variable. If the last specified index is a colon, then the rest of the variable indices are assumed to be colons (else, they are assumed to be zero, following the convention of monomial coefficient indexing).","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header = false; #hide\nd = Descriptor(5, 10, 2, 10);\nx = vars(d);\nk = params(d);\n f = 2*x[1]^2*x[3] + 3*x[1]^2*x[2]*x[3]*x[4]^2*x[5]*k[1] + 6*x[3] + 5\ng = f[[2,:,1]]\nh = f[[2,:,1,:]]","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"A TPS can also be sliced with indexing by sparse monomial. In this case, if a colon is included anywhere in the sparse monomial variable index, then all orders of all variables and parameters not explicity specified will be included (colon position does not matter in sparse monomial indexing):","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"g = f[[1=>2, :, 3=>1, 4=>0, 5=>0], params=[1=>0, 2=>0]]\nh = f[(1=>2, 3=>1, :)]  # Colon position is irrelevant in slicing with sparse monomial indexing","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"When indexing by monomial index, a colon simply needs to be included after the variable index, or just a colon if a parameter is specified:","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"fx3 = f[3,:]\nfk1 = f[:,param=1]","category":"page"},{"location":"man/j_slice/#par","page":"Slicing and par","title":"par","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"par is very similar to slicing a TPS, with two differences:","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"The specified variables and parameters are removed from the resulting slice\nWhen indexing by order, a colon is always presumed for unincluded variables/parameters","category":"page"},{"location":"man/j_slice/#Syntax","page":"Slicing and par","title":"Syntax","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, orders)\n\nf = par(tps [, vars_sparse_mono] [, params=params_sparse_mono])\n\nf = par(tps, idx)\nf = par(tps, param=param_idx)","category":"page"},{"location":"man/j_slice/#Description","page":"Slicing and par","title":"Description","text":"","category":"section"},{"location":"man/j_slice/#Indexing-by-Order","page":"Slicing and par","title":"Indexing by Order","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, orders) extracts the polynomial from the TPS with the monomial indexed-by-order in orders, and removes the variables/parameters included in the indexing from the polynomial","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"","category":"page"},{"location":"man/j_slice/#Indexing-by-Sparse-Monomial","page":"Slicing and par","title":"Indexing by Sparse Monomial","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, vars_sparse_mono) extracts the polynomial from the TPS with the monomial indexed-by-sparse monomial in vars_sparse_mono, and removes the variables included in the indexing from the polynomial","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, params=params_sparse_mono) extracts the polynomial from the TPS with the monomial indexed-by-sparse monomial in params_sparse_mono, and removes the parameters included in the indexing from the polynomial","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, vars_sparse_mono, params=params_sparse_mono) extracts the polynomial from the TPS with the monomial indexed-by-sparse monomial in vars_sparse_mono and params_sparse_mono, and removes the variables and/or parameters included in the indexing from the polynomial","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"","category":"page"},{"location":"man/j_slice/#Indexing-by-Monomial-Index","page":"Slicing and par","title":"Indexing by Monomial Index","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, idx) extracts the polynomial from the TPS with a first-order dependence on the specified monomial, and removes the variable from the polynomial","category":"page"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"f = par(tps, param=param_idx) extracts the polynomial from the TPS with a first-order dependence on the specified monomial with index param_idx+nv where nv is the number of variables in the GTPSA, and removes the parameter from the polynomial","category":"page"},{"location":"man/j_slice/#Examples","page":"Slicing and par","title":"Examples","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header=false; #hide\nd = Descriptor(5, 10, 2, 10);\nx = vars(d);\nk = params(d);\nf = 2*x[1]^2*x[3] + 3*x[1]^2*x[2]*x[3]*x[4]^2*x[5]*k[1] + 6*x[3] + 5\npar(f, 3)\npar(f, param=1)\npar(f, [2,:,1])\npar(f, [2,0,1])\npar(f, [1=>2, 3=>1])\npar(f, params=[1=>1])","category":"page"},{"location":"man/j_slice/#Documentation","page":"Slicing and par","title":"Documentation","text":"","category":"section"},{"location":"man/j_slice/","page":"Slicing and par","title":"Slicing and par","text":"par","category":"page"},{"location":"man/j_slice/#GTPSA.par","page":"Slicing and par","title":"GTPSA.par","text":"par(t::Union{TPS,ComplexTPS}, v::Union{TPSColonIndexType, Vector{Pair{<:Integer,<:Integer}}, Vector{<:Integer}, Integer, Colon, Nothing}=nothing; param::Union{Integer,Nothing}=nothing, params::Union{SMIndexType, Nothing}=nothing)\n\nExtracts a polynomial from the TPS containing the specified monomial, and removes the monomial.\n\nInput\n\nv      – An integer (for variable index), an array/tuple of orders for each variable (for indexing-by-order), or an array/tuple of pairs (sparse monomial)\nparam  – (Keyword argument, optional) An integer for the parameter index\nparams – (Keyword argument, optional) An array of pairs for sparse-monomial indexing\n\nExamples: Variable/Parameter Index:\n\njulia> d = Descriptor(5, 10, 2, 10); x = vars(d); k = params(d);\n\njulia> f = 2*x[1]^2*x[3] + 3*x[1]^2*x[2]*x[3]*x[4]^2*x[5]*k[1] + 6*x[3] + 5\nTPS:\n Coefficient                Order   Exponent\n  5.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  6.0000000000000000e+00      1      0   0   1   0   0   |   0   0\n  2.0000000000000000e+00      3      2   0   1   0   0   |   0   0\n  3.0000000000000000e+00      8      2   1   1   2   1   |   1   0\n\n\njulia> par(f, 3)\nTPS:\n Coefficient                Order   Exponent\n  6.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  2.0000000000000000e+00      2      2   0   0   0   0   |   0   0\n  3.0000000000000000e+00      7      2   1   0   2   1   |   1   0\n\n\njulia> par(f, param=1)\nTPS:\n Coefficient                Order   Exponent\n  3.0000000000000000e+00      7      2   1   1   2   1   |   0   0\n\nExamples: Monomial Index-by-Order\n\njulia> par(f, [2,:,1])\nTPS:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  3.0000000000000000e+00      5      0   1   0   2   1   |   1   0\n\n\njulia> par(f, [2,0,1])\nTPS:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n\nExamples: Monomial Index-by-Sparse Monomial\n\njulia> par(f, [1=>2, 3=>1])\nTPS:\n Coefficient                Order   Exponent\n  2.0000000000000000e+00      0      0   0   0   0   0   |   0   0\n  3.0000000000000000e+00      5      0   1   0   2   1   |   1   0\n\n  \njulia> par(f, params=[1=>1])\nTPS:\n Coefficient                Order   Exponent\n  3.0000000000000000e+00      7      2   1   1   2   1   |   0   0\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quickstart-Guide","page":"Quickstart Guide","title":"Quickstart Guide","text":"","category":"section"},{"location":"quickstart/#Defining-the-GTPSA","page":"Quickstart Guide","title":"Defining the GTPSA","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"A Descriptor defines all information about the GTPSA, including the number of variables and truncation orders for each variable. The constructors for a Descriptor including only variables are:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA #hide\n# 2 variables with max truncation order 10\nd1 = Descriptor(2, 10)     ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"# 3 variables with individual truncation orders 1, 2, 3 and max truncation order 6\nd2 = Descriptor([1, 2, 3], 6)","category":"page"},{"location":"quickstart/#Calculating-a-TPS","page":"Quickstart Guide","title":"Calculating a TPS","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"After defining a Descriptor for the TPSA, the variables (which themselves are represented as TPSs) can be obtained using vars or complexvars. For example, to calculate the Taylor series for f(x_1x_2) = cos(x_1) + sqrt1+x_2 to 4th order in x_1 and but only 1st order in x_2 (up to maximally 1 + 4 = 5th order):","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false;#hide\nd = Descriptor([4, 1], 5);\n\n# Returns a Vector of each variable as a TPS\nx = vars(d) ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"These TPSs can then be manipulated just like any other mathematical quantity in Julia:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"f = cos(x[1]) + sqrt(1 + x[2])","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"A blank TPS or ComplexTPS, with all coefficients equal to zero, can be created using TPS(use=d) or ComplexTPS(use=d) respectively. If use is not explicitly passed, then the global GTPSA.desc_current, which is set each time a new Descriptor is defined, will be used.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"When a TPS contains a lot of variables, the default output showing each variable exponent can be larger than the screen can show. A global variable GTPSA.show_sparse, which is by default set to false, can be set to true to instead show each specific monomial instead of the exponents for each variable:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false;#hide\nd = Descriptor(10, 10);\nx = vars(d);\n\nGTPSA.show_sparse = true;\ng = sin(x[1]*x[3]^2) + cos(x[2]*x[7]);\n\nprint(g)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Another global variable GTPSA.show_eps can be set to exclude showing monomials with coefficients having an absolute value less than GTPSA.show_eps.","category":"page"},{"location":"quickstart/#Partial-Derivative-Getting/Setting","page":"Quickstart Guide","title":"Partial Derivative Getting/Setting","text":"","category":"section"},{"location":"quickstart/#Individual-Monomial-Coefficient","page":"Quickstart Guide","title":"Individual Monomial Coefficient","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"note: Note\nThe value of a partial derivative is equal to the monomial coefficient in the Taylor series multiplied by a constant factor. E.g. for an expansion around zero f(x)approx f(0) + fracpartial fpartial xrvert_0x + frac12fracpartial^2 fpartial x^2rvert_0 x^2 + , the 2nd order monomial coefficient is frac12fracpartial^2 fpartial x^2rvert_0. ","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Individual monomial coefficients in a TPS t can be get/set with three methods of indexing:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"By Order: t[[<x_1 order>, ..., <x_nv order>]]. For example, for a TPS with three variables x_1, x_2, and x_3, the x_1^3x_2^1 monomial coefficient is accessed with t[[3,1,0]] or equivalently t[[3,1]], as leaving out trailing zeros for unincluded variables is allowed. A tuple is also allowed instead of a vector for the list of orders.\nBy Sparse Monomial t[[<ix_var> => <order>, ...]]. This method of indexing is convenient when a TPS contains many variables and parameters. For example, for a TPS with variables x_1x_2x_100, the x_1^3x_99^1 monomial coefficient is accessed with t[[1=>3, 99=>1]]. A tuple is also allowed instead of a vector for the list of pairs.\nBy Monomial Index t[idx]. This method is not recommended for indexing above first order. Indexes the TPS with all monomials sorted by order. For example, for a TPS with two variables x_1 and x_2, the x_1 monomial is indexed with t[1] and the x_1^2 monomial is indexed with t[3]. The zeroth order part, or the scalar part of the TPS, can be set with t[0]. This method requires zero allocations for indexing, unlike the other two.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"These three methods of indexing are best shown with an example:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false;#hide\n# Example of indexing by order -----------\nd = Descriptor(3, 10);\nt = TPS(use=d); # Create zero TPS based on d\n\nt[[0]] = 1;\nt[[1]] = 2;\nt[[0,1]] = 3;\nt[(0,0,1)] = 4;  # Tuples also allowed\nt[(2,1,3)] = 5;\n\nprint(t)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false; #hide\n# Example of indexing by sparse monomial -----------\nd = Descriptor(3, 10);\nt = TPS(use=d); # Create zero TPS based on d\n\nt[[1=>1]] = 2;\nt[[2=>1]] = 3;\nt[[3=>1]] = 4;\nt[(1=>2,2=>1,3=>3)] = 5;  # Tuples also allowed\n\nprint(t)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_sparse = false;  GTPSA.show_header=false; #hide\n# Example of indexing by monomial index -----------\nd = Descriptor(3, 10);\nt = TPS(use=d); # Create zero TPS based on d\n\nt[0] = 0;\nt[1] = 1;\nt[2] = 2;\nt[3] = 3;\nt[4] = 4;\nt[5] = 5; \nt[6] = 6;\nt[7] = 7;\nt[8] = 8;\nt[9] = 9;\nt[10] = 10;\nprint(t)","category":"page"},{"location":"quickstart/#Gradients,-Jacobians,-Hessians","page":"Quickstart Guide","title":"Gradients, Jacobians, Hessians","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The convenience getters gradient, jacobian, and hessian (as well as their corresponding in-place methods gradient!, jacobian!, and hessian!) are also provided for extracting partial derivatives from a TPS/Vector of TPSs. Note that these functions are not actually calculating anything - at this point the TPS should already have been propagated through the system, and these functions are just extracting the corresponding partial derivatives.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false; #hide\n# 2nd Order TPSA with 100 variables\nd = Descriptor(100, 2);\nx = vars(d);\n\nout = cumsum(x);\n\n# Convenience getters for partial derivative extracting:\ngrad1 = gradient(out[1]);\nJ = jacobian(out);\nh1 = hessian(out[1]);\n\n# Also in-place getters\ngradient!(grad1, out[1]);\njacobian!(J, out);\nhessian!(h1, out[1]);","category":"page"},{"location":"quickstart/#Slicing-a-TPS","page":"Quickstart Guide","title":"Slicing a TPS","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"Parts of a TPS with certain variable orders can be extracted by slicing the TPS. When indexing by order, a colon (:) can be used in place for a variable order to include all orders of that variable. If the last specified index is a colon, then the rest of the variable indices are assumed to be colons:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA; GTPSA.show_header=false; GTPSA.show_sparse=false; #hide\nd = Descriptor(5, 10);\nx = vars(d);\n\nf = 2*x[1]^2*x[3] + 3*x[1]^2*x[2]*x[3]*x[4]^2*x[5] + 6*x[3] + 5;\ng = f[[2,:,1]];\nh = f[[2,:,1,:]];\n\nprint(f)\nprint(g)\nprint(h)","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"A TPS can also be sliced with indexing by sparse monomial. In this case, if a colon is included anywhere in the sparse monomial index, then all orders of all variables not explicity specified will be included:","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":" # Colon position does not matter in sparse-monomial indexing\ng = f[[1=>2, :, 3=>1, 4=>0, 5=>0]];\nh = f[[1=>2, 3=>1, :]];\n\n\nprint(g)\nprint(h)","category":"page"},{"location":"quickstart/#@FastGTPSA-Macro","page":"Quickstart Guide","title":"@FastGTPSA Macro","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The macro @FastGTPSA can be used to speed up evaluation of expressions that contain TPSs and/or ComplexTPSs. The macro is completely transparent to all other types, so it can be prepended to any existing expressions while still maintaining generic code. Any functions in the expression that are not overloaded by GTPSA will be ignored.","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"using GTPSA, BenchmarkTools\n\nd = Descriptor(3, 5);\nx = vars(d);\n\n@btime $x[1]^3*sin($x[2])/log(2+$x[3])-exp($x[1]*$x[2])*im;\n\n@btime @FastGTPSA $x[1]^3*sin($x[2])/log(2+$x[3])-exp($x[1]*$x[2])*im;","category":"page"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"The advantages of using the macro become especially apparent in more complicated systems, for example in benchmark/track.jl. ","category":"page"},{"location":"quickstart/#Promotion-of-TPS-to-ComplexTPS","page":"Quickstart Guide","title":"Promotion of TPS to ComplexTPS","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart Guide","title":"Quickstart Guide","text":"TPSs and ComplexTPSs can be mixed freely without concern. Any time an operation with a TPS and a ComplexTPS or a Complex number occurs, the result will be a ComplexTPS. A ComplexTPS can be converted back to a TPS using the real and imag operators.","category":"page"},{"location":"man/n_global/#global","page":"Global Variables","title":"Global Variables","text":"","category":"section"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"The following non-constant global variables can be set:","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"desc_current::Descriptor     # Current Descriptor to use\nshow_eps::Float64 =  0.0     # Print epsilon\nshow_sparse::Bool = false    # Use sparse monomial print\nshow_header::Bool = false    # Print a header above each TPS","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"desc_current defines the Descriptor to use when that information is not explicitly (or implicitly in a TPS copy constructor) available, e.g. when calling TPS(a) where a is not a TPS. This also allows one to use general Number commands like convert(TPS, a) and zeros(TPS, 6) ","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"show_eps defines the value below which the absolute value of a monomial coefficient is NOT printed","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"show_sparse specifies whether the sparse monomial format is used for printing. This is useful for GTPSAs containing a large number of variables and parameters","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"show_header specifies whether or not to print the GTPSA Descriptor information above each TPS output","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"","category":"page"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"Global variables can be get/set using either the standard syntax (e.g. GTPSA.show_header = true), or using the helper functions getGTPSA and setGTPSA!.","category":"page"},{"location":"man/n_global/#Examples","page":"Global Variables","title":"Examples","text":"","category":"section"},{"location":"man/n_global/","page":"Global Variables","title":"Global Variables","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header=false; #hide\nd1 = Descriptor(1, 6);\nx = vars()\nGTPSA.show_sparse = true;\nx\nsetGTPSA!(\"show_sparse\", false);\ngetGTPSA(\"show_sparse\")\nx","category":"page"},{"location":"man/d_tps/#tps","page":"TPS","title":"TPS","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"Truncated Power Series struct TPS <: Real","category":"page"},{"location":"man/d_tps/#Syntax","page":"TPS","title":"Syntax","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"t = TPS([real] [, use=(descriptor|tps|complextps)])","category":"page"},{"location":"man/d_tps/#Description","page":"TPS","title":"Description","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"t = TPS() creates a new TPS with all coefficients equal to zero using the Descriptor in GTPSA.desc_current","category":"page"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"t = TPS(real) creates a new TPS equal to real. If real is a TPS, then its Descriptor is used (equivalent to a copy constructor). Else, the Descriptor in GTPSA.desc_current is used","category":"page"},{"location":"man/d_tps/#Optional-Keyword-Argument","page":"TPS","title":"Optional Keyword Argument","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"use=descriptor creates a new TPS having a Descriptor equal to that passed","category":"page"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"use=(tps|complextps) creates a new TPS having a Descriptor equal to that used by the passed TPS or ComplexTPS","category":"page"},{"location":"man/d_tps/#Examples","page":"TPS","title":"Examples","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"using GTPSA; GTPSA.show_sparse = false; #hide\nGTPSA.show_header = true\nd1 = Descriptor(1, 1); # 1 variable to order 1\nt1_1 = TPS()\nt2_1 = TPS(5)\nt3_1 = TPS(t2_1)\nd2 = Descriptor(1, 10); # New Descriptor to order 10\nt1_2 = TPS() # Uses d2\nt2_2 = TPS(6)\nt3_2 = TPS(t3_1, use=d2) # Copies and changes Descriptor\nGTPSA.show_header = false #hide","category":"page"},{"location":"man/d_tps/#Documentation","page":"TPS","title":"Documentation","text":"","category":"section"},{"location":"man/d_tps/","page":"TPS","title":"TPS","text":"TPS","category":"page"},{"location":"man/d_tps/#GTPSA.TPS","page":"TPS","title":"GTPSA.TPS","text":"TPS(ta::Union{Real,Nothing}=nothing; use::Union{Descriptor,TPS,ComplexTPS,Nothing}=nothing)::TPS\n\nConstructor to create a new TPS equal to the real value ta. If ta is a TPS, this  is equivalent to a copy constructor, with the result by default having the same Descriptor as ta. If ta is not a TPS, then the Descriptor used will by default be GTPSA.desc_current. The Descriptor  for the constructed TPS can be set using use. If a TPS or ComplexTPS is passed to use,  the Descriptor for that TPS will be used.\n\nThe constructor can also be used to create a copy of a TPS under one Descriptor to instead  have a different Descriptor. In this case, invalid monomials under the new Descriptor are removed.\n\nInput\n\nta  – Any Real\nuse – (Optional) specify which Descriptor to use, default is nothing which uses the Descriptor for ta if ta isa TPS, else uses GTPSA.desc_current\n\nOutput\n\nret – New TPS equal to ta with removal of invalid monomials if ta is a TPS and a new Descriptor is specified\n\n\n\n\n\n","category":"type"},{"location":"man/m_io/#io","page":"I/O","title":"I/O","text":"","category":"section"},{"location":"man/m_io/#Global-Variables","page":"I/O","title":"Global Variables","text":"","category":"section"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"There are three non-constant global variables which can be set to customize the printed output of TPSs:","category":"page"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"show_eps::Float64 =  0.0     # Print epsilon\nshow_sparse::Bool = false    # Use sparse monomial print\nshow_header::Bool = false    # Print a header above each TPS","category":"page"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"show_eps defines the value below which the absolute value of a monomial coefficient is NOT printed","category":"page"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"show_sparse specifies whether the sparse monomial format is used for printing. This is useful for GTPSAs containing a large number of variables and parameters","category":"page"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"show_header specifies whether or not to print the GTPSA Descriptor information above each TPS output","category":"page"},{"location":"man/m_io/#Examples","page":"I/O","title":"Examples","text":"","category":"section"},{"location":"man/m_io/","page":"I/O","title":"I/O","text":"using GTPSA; GTPSA.show_sparse = false; GTPSA.show_header=false; #hide\nd = Descriptor(100, 1, 10, 1)\nx = vars() # Doesn't fit on screen\nGTPSA.show_sparse = true;\nx\nGTPSA.show_header = true\nx[1]","category":"page"},{"location":"#GTPSA.jl","page":"Home","title":"GTPSA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A full-featured Julia interface to the Generalised Truncated Power Series Algebra library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a full-featured Julia interface to the Generalised Truncated Power Series Algebra (GTPSA) library, which computes Taylor expansions, or Truncated Power Series (TPSs) of real and complex multivariable functions to arbitrary orders. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Truncated Power Series Algebra (TPSA) performs forward-mode automatic differentation (AD) similar to the dual-number implementation of ForwardDiff.jl. However, instead of nesting derivatives for higher orders, TPSA naturally extends to arbitary orders by directly using the power series expansions. This, paired with a highly optimized monomial indexing function/storage for propagating the partial derivatives, makes GTPSA.jl significantly faster for 2nd-order calculations and above (for 1st-order calculations the performance is similar to ForwardDiff.jl). See the benchmark/track.jl example for a speed comparison of GTPSA.jl with ForwardDiff.jl in calculating the partial derivatives for a system with 58 inputs and 6 outputs. In this example, GTPSA was nearly x3 faster than ForwardDiff to 2nd order, and x15 faster to 3rd order.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GTPSA provides several advantages over current Julia AD packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Speed: GTPSA.jl is significantly faster than ForwardDiff.jl for 2nd-order calculations and above, and has similar performance at 1st-order\nCustom Orders in Individual Variables: Other packages use a single maximum order for all variables. With GTPSA, the maximum order can be set differently for different variables. For example, computing the Taylor expansion of f(x_1x_2) to 2nd order in x_1 and 6th order in x_2 is possible\nComplex Numbers: GTPSA natively supports complex numbers and allows for mixing of complex and real truncated power series\nDistinction Between State Variables and Parameters: Distinguishing between dependent variables and parameters in the solution of a differential equation expressed as a power series in the dependent variables/parameters can be advantageous in analysis","category":"page"},{"location":"#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use GTPSA.jl, in the Julia REPL run","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"GTPSA\")","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First, a Descriptor must be created specifying the number of variables, number of parameters, and truncation order for each variable/parameter in the TPSA. A TPS or ComplexTPS can then be created based on the Descriptor. TPSs can be manipulated using all of the arithmetic operators (+,-,*,/,^) and math functions (e.g. abs, sqrt, sin, exp, log, tanh, etc.).","category":"page"},{"location":"","page":"Home","title":"Home","text":"TPSs can be viewed as structures containing the coefficients for all of the monomials of a multivariable Taylor expansion up to the orders specified in the Descriptor. As an example, to compute the truncated power series of a function f(x_1 x_2) = cos(x_1)+isin(x_2) to 6th order in x_1 and x_2:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GTPSA\n\n# Descriptor for TPSA with 2 variables to 6th order\nd = Descriptor(2, 6)\n\n# Get the TPSs corresponding to each variable based on the Descriptor\nx = vars()\n# x[1] corresponds to the first variable and x[2] corresponds to the second variable\n\n# Manipulate the TPSs as you would any other mathematical variable in Julia\nf = cos(x[1]) + im*sin(x[2])\n# This creates a new TPS called f","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that scalars do not need to be defined as TPSs when writing expressions. Running print(f) gives the output","category":"page"},{"location":"","page":"Home","title":"Home","text":"ComplexTPS:\n Real                     Imag                       Order   Exponent\n  1.0000000000000000e+00   0.0000000000000000e+00      0      0   0\n  0.0000000000000000e+00   1.0000000000000000e+00      1      0   1\n -5.0000000000000000e-01   0.0000000000000000e+00      2      2   0\n  0.0000000000000000e+00  -1.6666666666666666e-01      3      0   3\n  4.1666666666666664e-02   0.0000000000000000e+00      4      4   0\n  0.0000000000000000e+00   8.3333333333333332e-03      5      0   5\n -1.3888888888888887e-03   0.0000000000000000e+00      6      6   0","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Much thanks must be given to Laurent Deniau, the creator of the C GTPSA library, for his time and great patience in explaining his code. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Advanced users are referred to this paper discussing the inner workings of the C GTPSA library.","category":"page"},{"location":"man/b_definitions/#definitions","page":"Definitions","title":"Definitions","text":"","category":"section"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"This section is incomplete, and will be expanded in the near future","category":"page"},{"location":"man/b_definitions/#cto","page":"Definitions","title":"Custom Truncation Orders","text":"","category":"section"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"GTPSA allows for significant customization in the truncation of specific variables within  a monomial of the truncated power series (TPS). One can specify individually the truncation orders for each variable in a truncated power series, as well as the maximum truncation order for an entire monomial in the TPS. This is best shown with an example:","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"Suppose we'd like to express a function f(x_1x_2) as a truncated power series, and keep only terms that are up to 1st-order in x_1 but up to 2nd order in x_2; basically, we should not have any monomials where x_1 has an exponent > 1, nor any monomials where x_2 has an exponent > 2. GTPSA allows one to select the individual truncation orders for variables in a monomial in this manner. The next question to consider is the maximum truncation order for the entire monomial; in the above example, note that the 3rd-order term x_1x_2^2 follows the rules we layed out so far. But what if we'd also like to truncate all monomials with order 3 and above, and not allow this monomial? This can be achieved by setting the maximum truncation order equal to 2. When defining a GTPSA, the user must always specify the maximum truncation order, which when specifying individual truncation orders must lie within the range max(textrmindividual truncation orders) sum(textrmindividual truncation orders). If individual truncation orders are not specified, then they are automatically set to the maximum truncation order.","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"Example: allowed monomials for f(x_1x_2) with individual variable truncation orders [1,2] and different maximum truncation orders:","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"Exponents Max Order = 2 Max Order = 3\n1quad 0 ✅ ✅\n0quad 1 ✅ ✅\n2quad 0 ❌ ❌\n1quad 1 ✅ ✅\n0quad 2 ✅ ✅\n3quad 0 ❌ ❌\n2quad 1 ❌ ❌\n1quad 2 ❌ ✅\n0quad 3 ❌ ❌","category":"page"},{"location":"man/b_definitions/#Parameters","page":"Definitions","title":"Parameters","text":"","category":"section"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"GTPSA allows one to explicitly distinguish between variables and parameters. Generally, a variable would be a dependent variable in a differential equation, and a parameter would be a variation in something defining or influencing the system (for example, in a harmonic oscillator the restoring constant k would be a parameter). Individual truncation orders can be specified for the parameters in the same way as described for the variables, however there is a special extra truncation order the can be specified for solely the parameters part of the monomial, referred to as the parameter order. The parameter order defines the truncation order for only the parameters part of a monomial. ","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"Example: allowed monomials for f(x_1k_1k_2) (one variable, two parameters) with individual variable truncation order [1], individual parameter truncation orders [1,1], maximum order = 3, and different parameter orders:","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"Exponents Parameter Order = 1 Parameter Order = 2\n0quad  quad 1 quad 0 ✅ ✅\n0quad  quad 0 quad 1 ✅ ✅\n0quad  quad 1 quad 1 ❌ ✅\n1quad  quad 1 quad 0 ✅ ✅\n1quad  quad 0 quad 1 ✅ ✅\n1quad  quad 1 quad 1 ❌ ✅","category":"page"},{"location":"man/b_definitions/","page":"Definitions","title":"Definitions","text":"(Note: many monomials are excluded for brevity in the above table)","category":"page"}]
}
