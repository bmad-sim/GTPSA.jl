<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart Guide · GTPSA.jl</title><meta name="title" content="Quickstart Guide · GTPSA.jl"/><meta property="og:title" content="Quickstart Guide · GTPSA.jl"/><meta property="twitter:title" content="Quickstart Guide · GTPSA.jl"/><meta name="description" content="Documentation for GTPSA.jl."/><meta property="og:description" content="Documentation for GTPSA.jl."/><meta property="twitter:description" content="Documentation for GTPSA.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GTPSA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Quickstart Guide</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-GTPSA"><span>Defining the GTPSA</span></a></li><li><a class="tocitem" href="#Calculating-a-Truncated-Power-Series"><span>Calculating a Truncated Power Series</span></a></li><li><a class="tocitem" href="#TPS-Evaluation,-Composition,-Translation,-and-Inversion"><span>TPS Evaluation, Composition, Translation, and Inversion</span></a></li><li><a class="tocitem" href="#Other-TPS-Constructors"><span>Other TPS Constructors</span></a></li><li><a class="tocitem" href="#Partial-Derivative-Getting/Setting"><span>Partial Derivative Getting/Setting</span></a></li><li><a class="tocitem" href="#Slicing-a-TPS"><span>Slicing a <code>TPS</code></span></a></li><li><a class="tocitem" href="#@FastGTPSA/@FastGTPSA!-Macros"><span><code>@FastGTPSA</code>/<code>@FastGTPSA!</code> Macros</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation-using-GTPSA.jl"><span>Automatic Differentiation using <code>GTPSA.jl</code></span></a></li><li><a class="tocitem" href="#Compatibility-with-DifferentialEquations.jl"><span>Compatibility with <code>DifferentialEquations.jl</code></span></a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Usage</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/a_toc/">Table of Contents</a></li><li><a class="tocitem" href="../man/b_descriptor/"><code>Descriptor</code></a></li><li><a class="tocitem" href="../man/c_tps/"><code>TPS</code></a></li><li><a class="tocitem" href="../man/d_varsparams/"><code>@vars</code>, <code>@params</code></a></li><li><a class="tocitem" href="../man/e_monoindex/">Monomial Indexing</a></li><li><a class="tocitem" href="../man/f_mono/"><code>mono</code>/<code>complexmono</code></a></li><li><a class="tocitem" href="../man/g_gjh/"><code>gradient</code>, <code>jacobian</code>, <code>hessian</code></a></li><li><a class="tocitem" href="../man/h_slice/">Slicing and <code>par</code></a></li><li><a class="tocitem" href="../man/i_methods/"><code>TPS</code>-Specific Functions</a></li><li><a class="tocitem" href="../man/j_fastgtpsa/"><code>@FastGTPSA</code>/<code>@FastGTPSA!</code> Macros</a></li><li><a class="tocitem" href="../man/k_io/">I/O</a></li><li><a class="tocitem" href="../man/l_global/">Global Variables</a></li><li><a class="tocitem" href="../man/m_all/">All Overloaded Functions</a></li></ul></li><li><a class="tocitem" href="../devel/">For Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quickstart Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart Guide</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bmad-sim/GTPSA.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bmad-sim/GTPSA.jl/blob/main/docs/src/quickstart.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quickstart-Guide"><a class="docs-heading-anchor" href="#Quickstart-Guide">Quickstart Guide</a><a id="Quickstart-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Quickstart-Guide" title="Permalink"></a></h1><h2 id="Defining-the-GTPSA"><a class="docs-heading-anchor" href="#Defining-the-GTPSA">Defining the GTPSA</a><a id="Defining-the-GTPSA-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-GTPSA" title="Permalink"></a></h2><p>We first must define a <code>Descriptor</code> which includes all information about a GTPSA, including the number of variables and truncation order:</p><pre><code class="language-julia hljs"># 2 variables with max truncation order 10
d10 = Descriptor(2, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Descriptor(NV=2, MO=10)</code></pre><h2 id="Calculating-a-Truncated-Power-Series"><a class="docs-heading-anchor" href="#Calculating-a-Truncated-Power-Series">Calculating a Truncated Power Series</a><a id="Calculating-a-Truncated-Power-Series-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-a-Truncated-Power-Series" title="Permalink"></a></h2><p><code>GTPSA.jl</code> centers around the <code>TPS</code> (truncated power series) type, which represents a multivariable Taylor series truncated at the chosen order in the <code>Descriptor</code>. Using <a href="https://en.wikipedia.org/wiki/Einstein_notation">Einstein notation</a> for the variable indices, and letting <span>$n$</span> specify the order up to a maximum truncation order <span>$MO$</span>, we can express a function <span>$f$</span> expanded around <span>$\vec{a}$</span> as a <code>TPS</code>:</p><p class="math-container">\[f(\vec{x}) = f(\vec{a}) + \sum_{n=1}^{MO} \left.\frac{\partial f}{\partial x_{i_1} \partial x_{i_2}\ldots \partial x_{i_n}}\right\rvert_{\vec{a}} \Delta x_{i_1} \Delta x_{i_2} \ldots\Delta x_{i_n}\]</p><p>The <code>TPS</code> type stores all of the monomial coefficients in this Taylor series up to the chosen order (e.g. <span>$f(\vec{a})$</span>, <span>$\partial f /\partial x_i |_{\vec{a}}$</span>, etc.). You can manipulate and propagate a <code>TPS</code> through functions like any other number type, and the result will be a <code>TPS</code> containing the Taylor expansion representing all preceding operations. If you have some familiarity with automatic differentiation, then you can view a <code>TPS</code> as basically a Dual number which has been highly optimized for high order automatic differentiation with high numbers of variables/parameters.</p><p><strong>In the context of <code>GTPSA.jl</code>, we refer to &quot;variables&quot; as each <span>$\Delta x_i$</span> in the <code>TPS</code>.</strong> The reason for this is that one can always choose a coordinate system where <span>$\vec{a}=\vec{0}$</span>, and such a choice greatly simplifies the terminology and analysis. This brings up an important point: the <code>TPS</code> type itself does NOT explicitly store any expansion point. It just stores the monomial coefficients of each term in the Taylor series, truncated at the chosen order of the (tiny) variables. The setup of the problem, done by you our dear user, will decide the expansion point. In the parlance of Dual numbers, the quantity <span>$\Delta x_i$</span> is equivalent to <span>$0+1\epsilon_i$</span>.</p><p>Let&#39;s dive into some examples, which will make these above points clearer. After defining the <code>Descriptor</code>, we can obtain the variables, which themselves are represented as <code>TPS</code>s (with each variable&#39;s first order monomial coefficient set to 1) using <code>@vars</code>:</p><pre><code class="language-julia hljs">d6 = Descriptor(2, 6); # 2 variables to 6th order

# Returns a Vector of each variable as a TPS
Δx = @vars(d6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{TPS64{Descriptor(NV=2, MO=6)}}:
 Index Coefficient                Order   Exponent
----------------------------------------------------
   1:   1.0000000000000000e+00      1      1   0
----------------------------------------------------
   2:   1.0000000000000000e+00      1      0   1
</code></pre><p>The result is a <code>TPS</code> vector function <span>$\begin{bmatrix} \Delta x_1 \\ \Delta x_2 \end{bmatrix}$</span> corresponding directly to each variable. <code>TPS64</code> is an alias for <code>TPS{Float64}</code>, which are <code>TPS</code>s that represent 64-bit floats. Likewise, <code>ComplexTPS64</code> is an alias for <code>TPS{ComplexF64}</code>. Currently, GTPSA only supports <code>TPS</code>s which represent <code>Float64</code> and <code>ComplexF64</code> numbers. </p><p>Now let&#39;s use this to compute the Maclaurin series of the function <span>$f(\vec{x}) = \cos{(x_1)} + \textrm{i}\sin{(x_2)}$</span>:</p><pre><code class="language-julia hljs">f(x) = cos(x[1]) + im*sin(x[2]); # Define the function

f(Δx) # Maclaurin series</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComplexTPS64{Descriptor(NV=2, MO=6)}:
 Real                     Imag                       Order   Exponent
  1.0000000000000000e+00   0.0000000000000000e+00      0      0   0
  0.0000000000000000e+00   1.0000000000000000e+00      1      0   1
 -5.0000000000000000e-01   0.0000000000000000e+00      2      2   0
  0.0000000000000000e+00  -1.6666666666666666e-01      3      0   3
  4.1666666666666664e-02   0.0000000000000000e+00      4      4   0
  0.0000000000000000e+00   8.3333333333333332e-03      5      0   5
 -1.3888888888888887e-03   0.0000000000000000e+00      6      6   0
</code></pre><p>Another way to view &quot;variables&quot; in the context of <code>GTPSA.jl</code> are as tiny &quot;wiggles&quot;. Specifically, if you wiggle the input, how does the output depend on those input wiggles?. The vector of variables <code>Δx</code> are thus just unit wiggles.</p><p>To instead compute the Taylor series of <code>f</code> expanded around <span>$(-\pi/2,\pi/2)$</span>, we simply &quot;wiggle&quot; around <span>$(-\pi/2,\pi/2)$</span>:</p><pre><code class="language-julia hljs">x0 = [-pi/2, pi/2];

ft = f(x0 + Δx)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComplexTPS64{Descriptor(NV=2, MO=6)}:
 Real                     Imag                       Order   Exponent
  6.1232339957367660e-17   1.0000000000000000e+00      0      0   0
  1.0000000000000000e+00   0.0000000000000000e+00      1      1   0
  0.0000000000000000e+00   6.1232339957367660e-17      1      0   1
 -3.0616169978683830e-17   0.0000000000000000e+00      2      2   0
  0.0000000000000000e+00  -5.0000000000000000e-01      2      0   2
 -1.6666666666666666e-01   0.0000000000000000e+00      3      3   0
  0.0000000000000000e+00  -1.0205389992894610e-17      3      0   3
  2.5513474982236524e-18   0.0000000000000000e+00      4      4   0
  0.0000000000000000e+00   4.1666666666666664e-02      4      0   4
  8.3333333333333332e-03   0.0000000000000000e+00      5      5   0
  0.0000000000000000e+00   5.1026949964473050e-19      5      0   5
 -8.5044916607455075e-20   0.0000000000000000e+00      6      6   0
  0.0000000000000000e+00  -1.3888888888888887e-03      6      0   6
</code></pre><p><code>ft</code> is a <code>TPS</code> containing the expansion of <code>f</code> around <span>$(-\pi/2,\pi/2)$</span> up to 6th order, with the variables specifying deviations from <span>$(-\pi/2,\pi/2)$</span>. Note how some of the monomial coefficients are small but nonzero due to floating point roundoff error. To hide the display of small monomial coefficients below a certain absolute value, we can set the global variable <code>GTPSA.show_eps</code>:</p><pre><code class="language-julia hljs">GTPSA.show_eps = 1e-15
println(ft)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComplexTPS64{Descriptor(NV=2, MO=6)}:
 Real                     Imag                       Order   Exponent
  0.0000000000000000e+00   1.0000000000000000e+00      0      0   0
  1.0000000000000000e+00   0.0000000000000000e+00      1      1   0
  0.0000000000000000e+00  -5.0000000000000000e-01      2      0   2
 -1.6666666666666666e-01   0.0000000000000000e+00      3      3   0
  0.0000000000000000e+00   4.1666666666666664e-02      4      0   4
  8.3333333333333332e-03   0.0000000000000000e+00      5      5   0
  0.0000000000000000e+00  -1.3888888888888887e-03      6      0   6</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Setting <code>GTPSA.show_eps</code> does not actually reset any monomial coefficients in the <code>TPS</code>s equal to zero, rather just suppresses their output when <code>show</code>ing any <code>TPS</code>.</p></div></div><h2 id="TPS-Evaluation,-Composition,-Translation,-and-Inversion"><a class="docs-heading-anchor" href="#TPS-Evaluation,-Composition,-Translation,-and-Inversion">TPS Evaluation, Composition, Translation, and Inversion</a><a id="TPS-Evaluation,-Composition,-Translation,-and-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#TPS-Evaluation,-Composition,-Translation,-and-Inversion" title="Permalink"></a></h2><p>We can evaluate <code>TPS</code>s just like any other function. Continuing with our example above, let&#39;s evaluate <code>ft</code>, which is an expansion around <span>$(-\pi/2,\pi/2)$</span> at, say, <span>$(\Delta x_1,\Delta x_2)=(\pi,-\pi)$</span>, and see how well it agrees with the exact calculation using <code>f</code>:</p><pre><code class="language-julia hljs">abs(ft([-pi, pi]) - f(x0 + [-pi, pi]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.565059330890453</code></pre><p>The disagreement is quite large! This is due to the truncation error of the <code>TPS</code>. If we increase the maximum order of the GTPSA, we can obtain a better approximation of the function <code>f</code> for such large variables. Let&#39;s test that now, setting the truncation order to 20 for both variables:</p><pre><code class="language-julia hljs">d20 = Descriptor(2, 20); # two variables to 20th order
Δx = @vars(d20);
ft = f(x0 + Δx);
abs(ft([-pi, pi]) - f(x0 + [-pi, pi]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5.343014327042979e-10</code></pre><p><code>ft</code> now approximates <code>f</code> much better for such large variables!</p><p>We also can <em>compose</em> <code>TPS</code>s. For this example, let&#39;s define a new GTPSA with only 1 variable to 1st order, and define the functions <span>$f(x) = x^2+2x$</span> and <span>$g(x)=3+4x$</span>:</p><pre><code class="language-julia hljs">d = Descriptor(1, 1);
Δx = first(@vars(d));
f(x) = x^2 + 2*x;
g(x) = 3 + 4*x;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">g (generic function with 1 method)</code></pre><p>Of course, we can compute a <code>TPS</code> representing the expansion of <span>$f\circ g$</span> around <span>$x=0$</span> by:</p><pre><code class="language-julia hljs">fg_exact = f(g(Δx))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=1, MO=1)}:
 Coefficient                Order   Exponent
  1.5000000000000000e+01      0      0
  3.2000000000000000e+01      1      1
</code></pre><p>However, we can also separately compute <code>TPS</code>s for <span>$f$</span> and <span>$g$</span> around <span>$x=0$</span>, and then <em>compose</em> them:</p><pre><code class="language-julia hljs">ft = f(Δx);
gt = g(Δx);
fg_composed = ft ∘ gt # Or equivalently ft(gt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=1, MO=1)}:
 Coefficient                Order   Exponent
  6.0000000000000000e+00      0      0
  8.0000000000000000e+00      1      1
</code></pre><p>Wait a minute, what happened here? <code>fg_composed</code> certainly is not equal to <code>fg_exact</code>.</p><p>This example presents the important concept of <code>TPS</code> <em>feed-down error</em>. The explanation is simple; for <code>fg_composed</code>, we separately obtained <code>TPS</code>s expanded around <span>$x=0$</span>, and then tried to compose them. However, after passing through <span>$g$</span>, a nonzero 0th order term (also called the <em>scalar</em> part of the <code>TPS</code>) was picked up. Thus, we should have expanded <span>$f$</span> around the scalar part of <code>gt</code>, instead of <span>$x=0$</span>. Then, to keep the same coordinates as initially inputted into <code>gt</code>, we&#39;ll also need to <code>translate</code> this <code>TPS</code> expansion point back to the original expansion point:</p><pre><code class="language-julia hljs"># First find the expansion of `f` around the 0th order (scalar part) of `g`
ft1 = f(scalar(gt) + Δx); # We can use `scalar` to get the scalar part of a `TPS`

# Then `translate` the expansion point back to the original expansion point
ft = translate(ft1, -scalar(gt));

fg_composed = ft ∘ gt</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=1, MO=1)}:
 Coefficient                Order   Exponent
  1.5000000000000000e+01      0      0
  3.2000000000000000e+01      1      1
</code></pre><p><code>fg_composed</code> now fully agrees with <code>fg_exact</code>.</p><p>This example shows the care that must be taken when composing two separate truncated power series. Another, perhaps simpler, way of dealing with this problem is to always chose a coordinate system such that the scalar part of a <code>TPS</code> is equal to zero.</p><p>GTPSA also includes a routine to invert a <code>TPS</code> map. The inversion routine ignores any scalar part of the <code>TPS</code>, so it is the responsibility of the user to ensure the coordinate system is consistent by either translating the <code>TPS</code>s or using a coordinate system where the scalar part is zero. </p><p>As an example, let&#39;s invert the following <code>TPS</code> map, which has no scalar part:</p><pre><code class="language-julia hljs">d = Descriptor(2, 2);
Δx = @vars(d);
M = [  Δx[1] + 2*Δx[2] + 3*Δx[1]*Δx[2],
     3*Δx[1] + 4*Δx[2] + Δx[1]^2 + Δx[2]^2]
M_inv = inv(M)

M_inv ∘ M</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{TPS64{Descriptor(NV=2, MO=2)}}:
 Index Coefficient                Order   Exponent
----------------------------------------------------
   1:   1.0000000000000000e+00      1      1   0
----------------------------------------------------
   2:   1.0000000000000000e+00      1      0   1
</code></pre><h2 id="Other-TPS-Constructors"><a class="docs-heading-anchor" href="#Other-TPS-Constructors">Other TPS Constructors</a><a id="Other-TPS-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Other-TPS-Constructors" title="Permalink"></a></h2><p>After defining a <code>Descriptor</code>, we can construct a <code>TPS</code> using any of the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Descriptor(3, 5); # 3 variables to 5th order</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = TPS64{d}() # Constructs a blank `TPS`, equivalent to `TPS{Float64,d}()`</code><code class="nohighlight hljs ansi" style="display:block;">TPS64{Descriptor(NV=3, MO=5)}:
 Coefficient                Order   Exponent
  0.0000000000000000e+00      0      0   0   0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1 = TPS64{d}(1.0) # Constructs a `TPS` with scalar part set to 1.0</code><code class="nohighlight hljs ansi" style="display:block;">TPS64{Descriptor(NV=3, MO=5)}:
 Coefficient                Order   Exponent
  1.0000000000000000e+00      0      0   0   0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1c = ComplexTPS64{d}(1.0) # Equivalent to `TPS{ComplexF64,d}(1.0)`</code><code class="nohighlight hljs ansi" style="display:block;">ComplexTPS64{Descriptor(NV=3, MO=5)}:
 Real                     Imag                       Order   Exponent
  1.0000000000000000e+00   0.0000000000000000e+00      0      0   0   0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t1im = TPS{d}(1.0im) # If the number type is not specified, then it is inferred</code><code class="nohighlight hljs ansi" style="display:block;">ComplexTPS64{Descriptor(NV=3, MO=5)}:
 Real                     Imag                       Order   Exponent
  0.0000000000000000e+00   1.0000000000000000e+00      0      0   0   0</code></pre><p>When constructing <code>TPS</code>s in this manner, it is important to include the <code>Descriptor</code> in the type parameter of the constructor, to ensure the <code>Descriptor</code> of the <code>TPS</code> is resolved statically (at compile time). If it is not included, then the <code>Descriptor</code> of the <code>TPS</code> will be resolved dynamically instead, at runtime. <code>GTPSA.jl</code> provides both static and dynamic <code>Descriptor</code> resolution modes, each of which have certain advantages in different use cases. See the <a href="../advanced/#descmodes">advanced topics</a> section of the documentation for more details.</p><h2 id="Partial-Derivative-Getting/Setting"><a class="docs-heading-anchor" href="#Partial-Derivative-Getting/Setting">Partial Derivative Getting/Setting</a><a id="Partial-Derivative-Getting/Setting-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-Derivative-Getting/Setting" title="Permalink"></a></h2><h3 id="Individual-Monomial-Coefficient"><a class="docs-heading-anchor" href="#Individual-Monomial-Coefficient">Individual Monomial Coefficient</a><a id="Individual-Monomial-Coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Individual-Monomial-Coefficient" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The value of a partial derivative is equal to the monomial coefficient in the Taylor series multiplied by a constant factor. E.g. for an expansion around zero <span>$f(x)\approx f(0) + \frac{\partial f}{\partial x}\rvert_0x + \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}\rvert_0 x^2 + ...$</span>, the 2nd order monomial coefficient is <span>$\frac{1}{2!}\frac{\partial^2 f}{\partial x^2}\rvert_0$</span>. </p></div></div><p>Individual monomial coefficients in a <code>TPS</code> <code>t</code> can be get/set with three methods of indexing:</p><ol><li><strong>By Monomial Index:</strong> <code>t[idx::Integer]</code>. Indexes the <code>TPS</code> with all monomials sorted by order. For example, for a <code>TPS</code> with two variables <span>$Δx_1$</span> and <span>$Δx_2$</span>, the <span>$Δx_1$</span> monomial is indexed with <code>t[1]</code> and the <span>$Δx_1^2$</span> monomial is indexed with <code>t[3]</code>. The zeroth order part, or the <em>scalar</em> part of the TPS, can be indexed with <code>t[0]</code>.</li><li><strong>By Order:</strong> <code>t[[&lt;Δx_1 order&gt;, ..., &lt;Δx_NV order&gt;]]</code>. For example, for a <code>TPS</code> with three variables <span>$Δx_1$</span>, <span>$Δx_2$</span>, and <span>$Δx_3$</span>, the <span>$Δx_1^3Δx_2^1$</span> monomial coefficient is accessed with <code>t[[3,1,0]]</code> or equivalently <code>t[[3,1]]</code>, as leaving out trailing zeros for unincluded variables is allowed. A tuple is also allowed instead of a vector for the list of orders.</li><li><strong>By Sparse Monomial:</strong> <code>t[[&lt;ix_var&gt; =&gt; &lt;order&gt;, ...]]</code>. This method of indexing is convenient when a <code>TPS</code> contains many variables and parameters. For example, for a <code>TPS</code> with variables <span>$Δx_1,Δx_2,...Δx_{100}$</span>, the <span>$Δx_{1}^3Δx_{99}^1$</span> monomial coefficient is accessed with <code>t[[1=&gt;3, 99=&gt;1]]</code>. A tuple is also allowed instead of a vector for the list of pairs.</li></ol><p>These three methods of indexing are best shown with an example:</p><pre><code class="language-julia hljs"># Example of indexing by monomial index -----------
d = Descriptor(3, 10);
t = TPS{d}(); # or equivalently TPS{Float64,d}()

t[0] = 0;
t[1] = 1;
t[2] = 2;
t[3] = 3;
t[4] = 4;
t[5] = 5;
t[6] = 6;
t[7] = 7;
t[8] = 8;
t[9] = 9;
t[10] = 10;

t</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=3, MO=10)}:
 Coefficient                Order   Exponent
  1.0000000000000000e+00      1      1   0   0
  2.0000000000000000e+00      1      0   1   0
  3.0000000000000000e+00      1      0   0   1
  4.0000000000000000e+00      2      2   0   0
  5.0000000000000000e+00      2      1   1   0
  6.0000000000000000e+00      2      0   2   0
  7.0000000000000000e+00      2      1   0   1
  8.0000000000000000e+00      2      0   1   1
  9.0000000000000000e+00      2      0   0   2
  1.0000000000000000e+01      3      3   0   0
</code></pre><pre><code class="language-julia hljs"># Example of indexing by order -----------
d = Descriptor(3, 10);
t = TPS{d}();

t[[0]] = 1;
t[[1]] = 2;
t[[0,1]] = 3;
t[(0,0,1)] = 4;  # Tuples also allowed
t[(2,1,3)] = 5;

t</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=3, MO=10)}:
 Coefficient                Order   Exponent
  1.0000000000000000e+00      0      0   0   0
  2.0000000000000000e+00      1      1   0   0
  3.0000000000000000e+00      1      0   1   0
  4.0000000000000000e+00      1      0   0   1
  5.0000000000000000e+00      6      2   1   3
</code></pre><pre><code class="language-julia hljs"># Example of indexing by sparse monomial -----------
d = Descriptor(3, 10);
t = TPS{d}();

t[[1=&gt;1]] = 2;
t[[2=&gt;1]] = 3;
t[[3=&gt;1]] = 4;
t[(1=&gt;2,2=&gt;1,3=&gt;3)] = 5;  # Tuples also allowed

t</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=3, MO=10)}:
 Coefficient                Order   Exponent
  2.0000000000000000e+00      1      1   0   0
  3.0000000000000000e+00      1      0   1   0
  4.0000000000000000e+00      1      0   0   1
  5.0000000000000000e+00      6      2   1   3
</code></pre><p>The <a href="../man/i_methods/#GTPSA.cycle!"><code>GTPSA.cycle!</code></a> function can also be used to cycle through all nonzero monomials in a <code>TPS</code>.</p><h3 id="Gradients,-Jacobians,-Hessians"><a class="docs-heading-anchor" href="#Gradients,-Jacobians,-Hessians">Gradients, Jacobians, Hessians</a><a id="Gradients,-Jacobians,-Hessians-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients,-Jacobians,-Hessians" title="Permalink"></a></h3><p>The convenience getters <code>gradient</code>, <code>jacobian</code>, and <code>hessian</code> (as well as their corresponding in-place methods <code>gradient!</code>, <code>jacobian!</code>, and <code>hessian!</code>) are also provided for extracting partial derivatives from a <code>TPS</code>/array of <code>TPS</code>s. Note that these functions are not actually calculating anything - at this point the <code>TPS</code> should already have been propagated through, and these functions are just extracting the corresponding partial derivatives.</p><pre><code class="language-julia hljs">using GTPSA; GTPSA.show_sparse=false; #hide
# 2nd Order TPSA with 100 variables
d = Descriptor(100, 2);
Δx = @vars(d);

out = cumsum(Δx);

# Convenience getters for partial derivative extracting:
grad1 = GTPSA.gradient(out[1]);
J = GTPSA.jacobian(out);
h1 = GTPSA.hessian(out[1]);

# Also in-place getters
GTPSA.gradient!(grad1, out[1]);
GTPSA.jacobian!(J, out);
GTPSA.hessian!(h1, out[1]);</code></pre><h2 id="Slicing-a-TPS"><a class="docs-heading-anchor" href="#Slicing-a-TPS">Slicing a <code>TPS</code></a><a id="Slicing-a-TPS-1"></a><a class="docs-heading-anchor-permalink" href="#Slicing-a-TPS" title="Permalink"></a></h2><p>Parts of a <code>TPS</code> with certain variable orders can be extracted by slicing the <code>TPS</code>. When indexing by order, a colon (<code>:</code>) can be used in place for a variable order to include all orders of that variable. If the last specified index is a colon, then the rest of the variable indices are assumed to be colons:</p><pre><code class="language-julia hljs">d = Descriptor(5, 10);
Δx = @vars(d);

f = 2*Δx[1]^2*Δx[3] + 3*Δx[1]^2*Δx[2]*Δx[3]*Δx[4]^2*Δx[5] + 6*Δx[3] + 5;
g = f[[2,:,1]];
h = f[[2,:,1,:]];

print(f)
print(g)
print(h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=5, MO=10)}:
 Coefficient                Order   Exponent
  5.0000000000000000e+00      0      0   0   0   0   0
  6.0000000000000000e+00      1      0   0   1   0   0
  2.0000000000000000e+00      3      2   0   1   0   0
  3.0000000000000000e+00      7      2   1   1   2   1
TPS64{Descriptor(NV=5, MO=10)}:
 Coefficient                Order   Exponent
  2.0000000000000000e+00      3      2   0   1   0   0
TPS64{Descriptor(NV=5, MO=10)}:
 Coefficient                Order   Exponent
  2.0000000000000000e+00      3      2   0   1   0   0
  3.0000000000000000e+00      7      2   1   1   2   1</code></pre><p>A <code>TPS</code> can also be sliced with indexing by sparse monomial. In this case, if a colon is included anywhere in the sparse monomial index, then all orders of all variables not explicity specified will be included:</p><pre><code class="language-julia hljs"> # Colon position does not matter in sparse-monomial indexing
g = f[[1=&gt;2, :, 3=&gt;1, 4=&gt;0, 5=&gt;0]];
h = f[[1=&gt;2, 3=&gt;1, :]];

print(g)
print(h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">TPS64{Descriptor(NV=5, MO=10)}:
 Coefficient                Order   Exponent
  2.0000000000000000e+00      3      2   0   1   0   0
TPS64{Descriptor(NV=5, MO=10)}:
 Coefficient                Order   Exponent
  2.0000000000000000e+00      3      2   0   1   0   0
  3.0000000000000000e+00      7      2   1   1   2   1</code></pre><h2 id="@FastGTPSA/@FastGTPSA!-Macros"><a class="docs-heading-anchor" href="#@FastGTPSA/@FastGTPSA!-Macros"><code>@FastGTPSA</code>/<code>@FastGTPSA!</code> Macros</a><a id="@FastGTPSA/@FastGTPSA!-Macros-1"></a><a class="docs-heading-anchor-permalink" href="#@FastGTPSA/@FastGTPSA!-Macros" title="Permalink"></a></h2><p>The macros <a href="../man/j_fastgtpsa/#fastgtpsa"><code>@FastGTPSA</code>/<code>@FastGTPSA!</code></a> can be used to speed up evaluation of expressions that may contain <code>TPS</code>s. <strong>Both macros are completely transparent to all other types, so they can be prepended to any existing expressions while still maintaining type-generic code.</strong> Any functions in the expression that are not overloaded by GTPSA will be ignored. Both macros do <strong>NOT</strong> use any <code>-ffast-math</code> business (so still IEEE compliant), but instead will use a thread-safe pre-allocated buffer in the <code>Descriptor</code> for any temporaries that may be generated during evaluation of the expression.</p><p>The first macro, <code>@FastGTPSA</code> can be prepended to an expression following assignment (<code>=</code>, <code>+=</code>, etc) to only construct one <code>TPS</code> (which requires two allocations), instead of a <code>TPS</code> for every temporary:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GTPSA, BenchmarkTools</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Descriptor(3, 7);  Δx = @vars(d);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  5.711 μs (20 allocations: 11.88 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  5.208 μs (2 allocations: 1.94 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = rand(3); # transparent to non-TPS types</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  20.077 ns (0 allocations: 0 bytes)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  21.304 ns (0 allocations: 0 bytes)</code></pre><p>The second macro, <code>@FastGTPSA!</code> can be prepended to the left-hand side of an assignment, and will fill a preallocated <code>TPS</code> with the result of an expression. <code>@FastGTPSA!</code> will calculate a <code>TPS</code> expression with <em>zero</em> allocations, and will still have no impact if a non-TPS type (even if immutable) is used. The only requirement is that all symbols in the expression are defined:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; t = ComplexTPS64(); # pre-allocate</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA! $t = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  5.085 μs (0 allocations: 0 bytes)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = rand(3); @gensym z; # transparent to non-TPS types</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA! $z = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;</code><code class="nohighlight hljs ansi" style="display:block;">  20.068 ns (0 allocations: 0 bytes)</code></pre><p>Both <code>@FastGTPSA</code> and <code>@FastGTPSA!</code> can also be prepended to a block of code, in which case they are applied to each assignment in the block:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Descriptor(3, 7); Δx = @vars(d);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = rand(3);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA begin
               t1 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;
               t2 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;
               z  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;
              end;</code><code class="nohighlight hljs ansi" style="display:block;">  10.500 μs (4 allocations: 3.88 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; t3 = ComplexTPS64(); t4 = ComplexTPS64(); @gensym w;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA! begin
               $t3 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;
               $t4 = $Δx[1]^3*sin($Δx[2])/log(2+$Δx[3])-exp($Δx[1]*$Δx[2])*im;
               $w  = $y[1]^3*sin($y[2])/log(2+$y[3])-exp($y[1]*$y[2])*im;
              end;</code><code class="nohighlight hljs ansi" style="display:block;">  10.279 μs (0 allocations: 0 bytes)</code></pre><p>Both macros are also compatible with broadcasted, vectorized operators:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; d = Descriptor(3, 7); Δx = @vars(d); y = rand(3);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA begin
               out = @. $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;
              end;</code><code class="nohighlight hljs ansi" style="display:block;">  13.095 μs (7 allocations: 5.89 KiB)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; out = zeros(ComplexTPS64, 3); # pre-allocate</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime @FastGTPSA! begin
               @. $out = $Δx^3*sin($y)/log(2+$Δx)-exp($Δx*$y)*im;
              end;</code><code class="nohighlight hljs ansi" style="display:block;">  12.574 μs (0 allocations: 0 bytes)</code></pre><p>The advantages of using the macros become especially apparent in more complicated systems. See our <a href="https://github.com/bmad-sim/GTPSA.jl/blob/main/benchmark/track.jl">example</a> where we observed a significant speedup.</p><h2 id="Automatic-Differentiation-using-GTPSA.jl"><a class="docs-heading-anchor" href="#Automatic-Differentiation-using-GTPSA.jl">Automatic Differentiation using <code>GTPSA.jl</code></a><a id="Automatic-Differentiation-using-GTPSA.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-using-GTPSA.jl" title="Permalink"></a></h2><p>GTPSA is a supported backend in Julia&#39;s <a href="https://github.com/JuliaDiff/DifferentiationInterface.jl"><code>DifferentiationInterface.jl</code></a> package, which provides a generic interface for computing pushforwards (Jacobian vector products), derivatives, gradients, Jacobians, Hessians, and Hessian vector products using any automatic differentiation (AD) backend. If you are only interested in using GTPSA for these computations, then we strongly recommend using <code>DifferentiationInterface.jl</code> with the <code>AutoGTPSA</code> AD type.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>GTPSA has been highly optimized for high order AD with large numbers of variables and parameters. If you are only interested in first order AD, then other AD backends will likely be faster. GTPSA, however, will likely be faster in cases where the entire Hessian must be materialized.</p></div></div><h2 id="Compatibility-with-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Compatibility-with-DifferentialEquations.jl">Compatibility with <code>DifferentialEquations.jl</code></a><a id="Compatibility-with-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility-with-DifferentialEquations.jl" title="Permalink"></a></h2><p><code>GTPSA.jl</code> bindings have been added to <code>DiffEqBase.jl</code> so that <code>TPS</code>s can be integrated using any of the solvers provided by <a href="https://docs.sciml.ai/DiffEqDocs/stable/">SciML&#39;s extensive Differential Equations ecosystem</a>. Simply specify your initial conditions as <code>TPS</code> types. This allows, for example, for computation of high-order Hamiltonian maps that can then be analyzed using canonical perturbation theory.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../advanced/">Advanced Usage »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 10 April 2025 12:33">Thursday 10 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
